<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>grpc.framework.foundation.future API documentation</title>
<meta name="description" content="A Future interface â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grpc.framework.foundation.future</code></h1>
</header>
<section id="section-intro">
<p>A Future interface.</p>
<p>Python doesn't have a Future interface in its standard library. In the absence
of such a standard, three separate, incompatible implementations
(concurrent.futures.Future, ndb.Future, and asyncio.Future) have appeared. This
interface attempts to be as compatible as possible with
concurrent.futures.Future. From ndb.Future it adopts a traceback-object accessor
method.</p>
<p>Unlike the concrete and implemented Future classes listed above, the Future
class defined in this module is an entirely abstract interface that anyone may
implement and use.</p>
<p>The one known incompatibility between this interface and the interface of
concurrent.futures.Future is that this interface defines its own CancelledError
and TimeoutError exceptions rather than raising the implementation-private
concurrent.futures._base.CancelledError and the
built-in-but-only-in-3.3-and-later TimeoutError.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2015 gRPC authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34;A Future interface.

Python doesn&#39;t have a Future interface in its standard library. In the absence
of such a standard, three separate, incompatible implementations
(concurrent.futures.Future, ndb.Future, and asyncio.Future) have appeared. This
interface attempts to be as compatible as possible with
concurrent.futures.Future. From ndb.Future it adopts a traceback-object accessor
method.

Unlike the concrete and implemented Future classes listed above, the Future
class defined in this module is an entirely abstract interface that anyone may
implement and use.

The one known incompatibility between this interface and the interface of
concurrent.futures.Future is that this interface defines its own CancelledError
and TimeoutError exceptions rather than raising the implementation-private
concurrent.futures._base.CancelledError and the
built-in-but-only-in-3.3-and-later TimeoutError.
&#34;&#34;&#34;

import abc

import six


class TimeoutError(Exception):
    &#34;&#34;&#34;Indicates that a particular call timed out.&#34;&#34;&#34;


class CancelledError(Exception):
    &#34;&#34;&#34;Indicates that the computation underlying a Future was cancelled.&#34;&#34;&#34;


class Future(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;A representation of a computation in another control flow.

  Computations represented by a Future may be yet to be begun, may be ongoing,
  or may have already completed.
  &#34;&#34;&#34;

    # NOTE(nathaniel): This isn&#39;t the return type that I would want to have if it
    # were up to me. Were this interface being written from scratch, the return
    # type of this method would probably be a sum type like:
    #
    # NOT_COMMENCED
    # COMMENCED_AND_NOT_COMPLETED
    # PARTIAL_RESULT&lt;Partial_Result_Type&gt;
    # COMPLETED&lt;Result_Type&gt;
    # UNCANCELLABLE
    # NOT_IMMEDIATELY_DETERMINABLE
    @abc.abstractmethod
    def cancel(self):
        &#34;&#34;&#34;Attempts to cancel the computation.

    This method does not block.

    Returns:
      True if the computation has not yet begun, will not be allowed to take
        place, and determination of both was possible without blocking. False
        under all other circumstances including but not limited to the
        computation&#39;s already having begun, the computation&#39;s already having
        finished, and the computation&#39;s having been scheduled for execution on a
        remote system for which a determination of whether or not it commenced
        before being cancelled cannot be made without blocking.
    &#34;&#34;&#34;
        raise NotImplementedError()

    # NOTE(nathaniel): Here too this isn&#39;t the return type that I&#39;d want this
    # method to have if it were up to me. I think I&#39;d go with another sum type
    # like:
    #
    # NOT_CANCELLED (this object&#39;s cancel method hasn&#39;t been called)
    # NOT_COMMENCED
    # COMMENCED_AND_NOT_COMPLETED
    # PARTIAL_RESULT&lt;Partial_Result_Type&gt;
    # COMPLETED&lt;Result_Type&gt;
    # UNCANCELLABLE
    # NOT_IMMEDIATELY_DETERMINABLE
    #
    # Notice how giving the cancel method the right semantics obviates most
    # reasons for this method to exist.
    @abc.abstractmethod
    def cancelled(self):
        &#34;&#34;&#34;Describes whether the computation was cancelled.

    This method does not block.

    Returns:
      True if the computation was cancelled any time before its result became
        immediately available. False under all other circumstances including but
        not limited to this object&#39;s cancel method not having been called and
        the computation&#39;s result having become immediately available.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def running(self):
        &#34;&#34;&#34;Describes whether the computation is taking place.

    This method does not block.

    Returns:
      True if the computation is scheduled to take place in the future or is
        taking place now, or False if the computation took place in the past or
        was cancelled.
    &#34;&#34;&#34;
        raise NotImplementedError()

    # NOTE(nathaniel): These aren&#39;t quite the semantics I&#39;d like here either. I
    # would rather this only returned True in cases in which the underlying
    # computation completed successfully. A computation&#39;s having been cancelled
    # conflicts with considering that computation &#34;done&#34;.
    @abc.abstractmethod
    def done(self):
        &#34;&#34;&#34;Describes whether the computation has taken place.

    This method does not block.

    Returns:
      True if the computation is known to have either completed or have been
        unscheduled or interrupted. False if the computation may possibly be
        executing or scheduled to execute later.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def result(self, timeout=None):
        &#34;&#34;&#34;Accesses the outcome of the computation or raises its exception.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        finish or be cancelled, or None if this method should block until the
        computation has finished or is cancelled no matter how long that takes.

    Returns:
      The return value of the computation.

    Raises:
      TimeoutError: If a timeout value is passed and the computation does not
        terminate within the allotted time.
      CancelledError: If the computation was cancelled.
      Exception: If the computation raised an exception, this call will raise
        the same exception.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def exception(self, timeout=None):
        &#34;&#34;&#34;Return the exception raised by the computation.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        terminate or be cancelled, or None if this method should block until
        the computation is terminated or is cancelled no matter how long that
        takes.

    Returns:
      The exception raised by the computation, or None if the computation did
        not raise an exception.

    Raises:
      TimeoutError: If a timeout value is passed and the computation does not
        terminate within the allotted time.
      CancelledError: If the computation was cancelled.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def traceback(self, timeout=None):
        &#34;&#34;&#34;Access the traceback of the exception raised by the computation.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        terminate or be cancelled, or None if this method should block until
        the computation is terminated or is cancelled no matter how long that
        takes.

    Returns:
      The traceback of the exception raised by the computation, or None if the
        computation did not raise an exception.

    Raises:
      TimeoutError: If a timeout value is passed and the computation does not
        terminate within the allotted time.
      CancelledError: If the computation was cancelled.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_done_callback(self, fn):
        &#34;&#34;&#34;Adds a function to be called at completion of the computation.

    The callback will be passed this Future object describing the outcome of
    the computation.

    If the computation has already completed, the callback will be called
    immediately.

    Args:
      fn: A callable taking this Future object as its single parameter.
    &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grpc.framework.foundation.future.CancelledError"><code class="flex name class">
<span>class <span class="ident">CancelledError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates that the computation underlying a Future was cancelled.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CancelledError(Exception):
    &#34;&#34;&#34;Indicates that the computation underlying a Future was cancelled.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="grpc.framework.foundation.future.Future"><code class="flex name class">
<span>class <span class="ident">Future</span></span>
</code></dt>
<dd>
<section class="desc"><p>A representation of a computation in another control flow.</p>
<p>Computations represented by a Future may be yet to be begun, may be ongoing,
or may have already completed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Future(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;A representation of a computation in another control flow.

  Computations represented by a Future may be yet to be begun, may be ongoing,
  or may have already completed.
  &#34;&#34;&#34;

    # NOTE(nathaniel): This isn&#39;t the return type that I would want to have if it
    # were up to me. Were this interface being written from scratch, the return
    # type of this method would probably be a sum type like:
    #
    # NOT_COMMENCED
    # COMMENCED_AND_NOT_COMPLETED
    # PARTIAL_RESULT&lt;Partial_Result_Type&gt;
    # COMPLETED&lt;Result_Type&gt;
    # UNCANCELLABLE
    # NOT_IMMEDIATELY_DETERMINABLE
    @abc.abstractmethod
    def cancel(self):
        &#34;&#34;&#34;Attempts to cancel the computation.

    This method does not block.

    Returns:
      True if the computation has not yet begun, will not be allowed to take
        place, and determination of both was possible without blocking. False
        under all other circumstances including but not limited to the
        computation&#39;s already having begun, the computation&#39;s already having
        finished, and the computation&#39;s having been scheduled for execution on a
        remote system for which a determination of whether or not it commenced
        before being cancelled cannot be made without blocking.
    &#34;&#34;&#34;
        raise NotImplementedError()

    # NOTE(nathaniel): Here too this isn&#39;t the return type that I&#39;d want this
    # method to have if it were up to me. I think I&#39;d go with another sum type
    # like:
    #
    # NOT_CANCELLED (this object&#39;s cancel method hasn&#39;t been called)
    # NOT_COMMENCED
    # COMMENCED_AND_NOT_COMPLETED
    # PARTIAL_RESULT&lt;Partial_Result_Type&gt;
    # COMPLETED&lt;Result_Type&gt;
    # UNCANCELLABLE
    # NOT_IMMEDIATELY_DETERMINABLE
    #
    # Notice how giving the cancel method the right semantics obviates most
    # reasons for this method to exist.
    @abc.abstractmethod
    def cancelled(self):
        &#34;&#34;&#34;Describes whether the computation was cancelled.

    This method does not block.

    Returns:
      True if the computation was cancelled any time before its result became
        immediately available. False under all other circumstances including but
        not limited to this object&#39;s cancel method not having been called and
        the computation&#39;s result having become immediately available.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def running(self):
        &#34;&#34;&#34;Describes whether the computation is taking place.

    This method does not block.

    Returns:
      True if the computation is scheduled to take place in the future or is
        taking place now, or False if the computation took place in the past or
        was cancelled.
    &#34;&#34;&#34;
        raise NotImplementedError()

    # NOTE(nathaniel): These aren&#39;t quite the semantics I&#39;d like here either. I
    # would rather this only returned True in cases in which the underlying
    # computation completed successfully. A computation&#39;s having been cancelled
    # conflicts with considering that computation &#34;done&#34;.
    @abc.abstractmethod
    def done(self):
        &#34;&#34;&#34;Describes whether the computation has taken place.

    This method does not block.

    Returns:
      True if the computation is known to have either completed or have been
        unscheduled or interrupted. False if the computation may possibly be
        executing or scheduled to execute later.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def result(self, timeout=None):
        &#34;&#34;&#34;Accesses the outcome of the computation or raises its exception.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        finish or be cancelled, or None if this method should block until the
        computation has finished or is cancelled no matter how long that takes.

    Returns:
      The return value of the computation.

    Raises:
      TimeoutError: If a timeout value is passed and the computation does not
        terminate within the allotted time.
      CancelledError: If the computation was cancelled.
      Exception: If the computation raised an exception, this call will raise
        the same exception.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def exception(self, timeout=None):
        &#34;&#34;&#34;Return the exception raised by the computation.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        terminate or be cancelled, or None if this method should block until
        the computation is terminated or is cancelled no matter how long that
        takes.

    Returns:
      The exception raised by the computation, or None if the computation did
        not raise an exception.

    Raises:
      TimeoutError: If a timeout value is passed and the computation does not
        terminate within the allotted time.
      CancelledError: If the computation was cancelled.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def traceback(self, timeout=None):
        &#34;&#34;&#34;Access the traceback of the exception raised by the computation.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        terminate or be cancelled, or None if this method should block until
        the computation is terminated or is cancelled no matter how long that
        takes.

    Returns:
      The traceback of the exception raised by the computation, or None if the
        computation did not raise an exception.

    Raises:
      TimeoutError: If a timeout value is passed and the computation does not
        terminate within the allotted time.
      CancelledError: If the computation was cancelled.
    &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_done_callback(self, fn):
        &#34;&#34;&#34;Adds a function to be called at completion of the computation.

    The callback will be passed this Future object describing the outcome of
    the computation.

    If the computation has already completed, the callback will be called
    immediately.

    Args:
      fn: A callable taking this Future object as its single parameter.
    &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>grpc.beta._client_adaptations._Rendezvous</li>
<li>grpc.beta.utilities._ChannelReadyFuture</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.framework.foundation.future.Future.add_done_callback"><code class="name flex">
<span>def <span class="ident">add_done_callback</span></span>(<span>self, fn)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a function to be called at completion of the computation.</p>
<p>The callback will be passed this Future object describing the outcome of
the computation.</p>
<p>If the computation has already completed, the callback will be called
immediately.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fn</code></strong></dt>
<dd>A callable taking this Future object as its single parameter.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_done_callback(self, fn):
    &#34;&#34;&#34;Adds a function to be called at completion of the computation.

The callback will be passed this Future object describing the outcome of
the computation.

If the computation has already completed, the callback will be called
immediately.

Args:
  fn: A callable taking this Future object as its single parameter.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to cancel the computation.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>the</code> <code>computation</code> <code>has</code> <code>not</code> <code>yet</code> <code>begun</code>, <code>will</code> <code>not</code> <code>be</code> <code>allowed</code> <code>to</code> <code>take</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>place, and determination of both was possible without blocking. False
under all other circumstances including but not limited to the
computation's already having begun, the computation's already having
finished, and the computation's having been scheduled for execution on a
remote system for which a determination of whether or not it commenced
before being cancelled cannot be made without blocking.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def cancel(self):
    &#34;&#34;&#34;Attempts to cancel the computation.

This method does not block.

Returns:
  True if the computation has not yet begun, will not be allowed to take
    place, and determination of both was possible without blocking. False
    under all other circumstances including but not limited to the
    computation&#39;s already having begun, the computation&#39;s already having
    finished, and the computation&#39;s having been scheduled for execution on a
    remote system for which a determination of whether or not it commenced
    before being cancelled cannot be made without blocking.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.cancelled"><code class="name flex">
<span>def <span class="ident">cancelled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the computation was cancelled.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>the</code> <code>computation</code> <code>was</code> <code>cancelled</code> <code>any</code> <code>time</code> <code>before</code> <code>its</code> <code>result</code> <code>became</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>immediately available. False under all other circumstances including but
not limited to this object's cancel method not having been called and
the computation's result having become immediately available.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def cancelled(self):
    &#34;&#34;&#34;Describes whether the computation was cancelled.

This method does not block.

Returns:
  True if the computation was cancelled any time before its result became
    immediately available. False under all other circumstances including but
    not limited to this object&#39;s cancel method not having been called and
    the computation&#39;s result having become immediately available.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the computation has taken place.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>the</code> <code>computation</code> <code>is</code> <code>known</code> <code>to</code> <code>have</code> <code>either</code> <code>completed</code> or <code>have</code> <code>been</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>unscheduled or interrupted. False if the computation may possibly be
executing or scheduled to execute later.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def done(self):
    &#34;&#34;&#34;Describes whether the computation has taken place.

This method does not block.

Returns:
  True if the computation is known to have either completed or have been
    unscheduled or interrupted. False if the computation may possibly be
    executing or scheduled to execute later.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.exception"><code class="name flex">
<span>def <span class="ident">exception</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the exception raised by the computation.</p>
<p>This method may return immediately or may block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>The length of time in seconds to wait for the computation to
terminate or be cancelled, or None if this method should block until
the computation is terminated or is cancelled no matter how long that
takes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>exception</code> <code>raised</code> <code>by</code> <code>the</code> <code>computation</code>, or <code>None</code> <code>if</code> <code>the</code> <code>computation</code> <code>did</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>not raise an exception.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.framework.foundation.future.TimeoutError" href="#grpc.framework.foundation.future.TimeoutError"><code>TimeoutError</code></a></strong></dt>
<dd>If a timeout value is passed and the computation does not
terminate within the allotted time.</dd>
<dt><strong><a title="grpc.framework.foundation.future.CancelledError" href="#grpc.framework.foundation.future.CancelledError"><code>CancelledError</code></a></strong></dt>
<dd>If the computation was cancelled.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def exception(self, timeout=None):
    &#34;&#34;&#34;Return the exception raised by the computation.

This method may return immediately or may block.

Args:
  timeout: The length of time in seconds to wait for the computation to
    terminate or be cancelled, or None if this method should block until
    the computation is terminated or is cancelled no matter how long that
    takes.

Returns:
  The exception raised by the computation, or None if the computation did
    not raise an exception.

Raises:
  TimeoutError: If a timeout value is passed and the computation does not
    terminate within the allotted time.
  CancelledError: If the computation was cancelled.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Accesses the outcome of the computation or raises its exception.</p>
<p>This method may return immediately or may block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>The length of time in seconds to wait for the computation to
finish or be cancelled, or None if this method should block until the
computation has finished or is cancelled no matter how long that takes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The return value of the computation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.framework.foundation.future.TimeoutError" href="#grpc.framework.foundation.future.TimeoutError"><code>TimeoutError</code></a></strong></dt>
<dd>If a timeout value is passed and the computation does not
terminate within the allotted time.</dd>
<dt><strong><a title="grpc.framework.foundation.future.CancelledError" href="#grpc.framework.foundation.future.CancelledError"><code>CancelledError</code></a></strong></dt>
<dd>If the computation was cancelled.</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>If the computation raised an exception, this call will raise
the same exception.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def result(self, timeout=None):
    &#34;&#34;&#34;Accesses the outcome of the computation or raises its exception.

This method may return immediately or may block.

Args:
  timeout: The length of time in seconds to wait for the computation to
    finish or be cancelled, or None if this method should block until the
    computation has finished or is cancelled no matter how long that takes.

Returns:
  The return value of the computation.

Raises:
  TimeoutError: If a timeout value is passed and the computation does not
    terminate within the allotted time.
  CancelledError: If the computation was cancelled.
  Exception: If the computation raised an exception, this call will raise
    the same exception.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.running"><code class="name flex">
<span>def <span class="ident">running</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the computation is taking place.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>the</code> <code>computation</code> <code>is</code> <code>scheduled</code> <code>to</code> <code>take</code> <code>place</code> <code>in</code> <code>the</code> <code>future</code> or <code>is</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>taking place now, or False if the computation took place in the past or
was cancelled.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def running(self):
    &#34;&#34;&#34;Describes whether the computation is taking place.

This method does not block.

Returns:
  True if the computation is scheduled to take place in the future or is
    taking place now, or False if the computation took place in the past or
    was cancelled.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.framework.foundation.future.Future.traceback"><code class="name flex">
<span>def <span class="ident">traceback</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Access the traceback of the exception raised by the computation.</p>
<p>This method may return immediately or may block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>The length of time in seconds to wait for the computation to
terminate or be cancelled, or None if this method should block until
the computation is terminated or is cancelled no matter how long that
takes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>traceback</code> of <code>the</code> <code>exception</code> <code>raised</code> <code>by</code> <code>the</code> <code>computation</code>, or <code>None</code> <code>if</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>computation did not raise an exception.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.framework.foundation.future.TimeoutError" href="#grpc.framework.foundation.future.TimeoutError"><code>TimeoutError</code></a></strong></dt>
<dd>If a timeout value is passed and the computation does not
terminate within the allotted time.</dd>
<dt><strong><a title="grpc.framework.foundation.future.CancelledError" href="#grpc.framework.foundation.future.CancelledError"><code>CancelledError</code></a></strong></dt>
<dd>If the computation was cancelled.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def traceback(self, timeout=None):
    &#34;&#34;&#34;Access the traceback of the exception raised by the computation.

This method may return immediately or may block.

Args:
  timeout: The length of time in seconds to wait for the computation to
    terminate or be cancelled, or None if this method should block until
    the computation is terminated or is cancelled no matter how long that
    takes.

Returns:
  The traceback of the exception raised by the computation, or None if the
    computation did not raise an exception.

Raises:
  TimeoutError: If a timeout value is passed and the computation does not
    terminate within the allotted time.
  CancelledError: If the computation was cancelled.
&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.framework.foundation.future.TimeoutError"><code class="flex name class">
<span>class <span class="ident">TimeoutError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates that a particular call timed out.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeoutError(Exception):
    &#34;&#34;&#34;Indicates that a particular call timed out.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grpc.framework.foundation" href="index.html">grpc.framework.foundation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grpc.framework.foundation.future.CancelledError" href="#grpc.framework.foundation.future.CancelledError">CancelledError</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.framework.foundation.future.Future" href="#grpc.framework.foundation.future.Future">Future</a></code></h4>
<ul class="two-column">
<li><code><a title="grpc.framework.foundation.future.Future.add_done_callback" href="#grpc.framework.foundation.future.Future.add_done_callback">add_done_callback</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.cancel" href="#grpc.framework.foundation.future.Future.cancel">cancel</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.cancelled" href="#grpc.framework.foundation.future.Future.cancelled">cancelled</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.done" href="#grpc.framework.foundation.future.Future.done">done</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.exception" href="#grpc.framework.foundation.future.Future.exception">exception</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.result" href="#grpc.framework.foundation.future.Future.result">result</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.running" href="#grpc.framework.foundation.future.Future.running">running</a></code></li>
<li><code><a title="grpc.framework.foundation.future.Future.traceback" href="#grpc.framework.foundation.future.Future.traceback">traceback</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.framework.foundation.future.TimeoutError" href="#grpc.framework.foundation.future.TimeoutError">TimeoutError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>