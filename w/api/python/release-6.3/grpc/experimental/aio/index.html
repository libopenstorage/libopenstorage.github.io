<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>grpc.experimental.aio API documentation</title>
<meta name="description" content="gRPC&#39;s Asynchronous Python API." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grpc.experimental.aio</code></h1>
</header>
<section id="section-intro">
<p>gRPC's Asynchronous Python API.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2019 gRPC authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34;gRPC&#39;s Asynchronous Python API.&#34;&#34;&#34;

import abc
import six

import grpc
from grpc import _common
from grpc._cython import cygrpc
from grpc._cython.cygrpc import init_grpc_aio

from ._call import AioRpcError
from ._call import Call
from ._channel import Channel
from ._channel import UnaryUnaryMultiCallable
from ._server import server


def insecure_channel(target, options=None, compression=None):
    &#34;&#34;&#34;Creates an insecure asynchronous Channel to a server.

    Args:
      target: The server address
      options: An optional list of key-value pairs (channel args
        in gRPC Core runtime) to configure the channel.
      compression: An optional value indicating the compression method to be
        used over the lifetime of the channel. This is an EXPERIMENTAL option.

    Returns:
      A Channel.
    &#34;&#34;&#34;
    return Channel(target, ()
                   if options is None else options, None, compression)


###################################  __all__  #################################

__all__ = (&#39;AioRpcError&#39;, &#39;Call&#39;, &#39;init_grpc_aio&#39;, &#39;Channel&#39;,
           &#39;UnaryUnaryMultiCallable&#39;, &#39;insecure_channel&#39;, &#39;server&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grpc.experimental.aio.init_grpc_aio"><code class="name flex">
<span>def <span class="ident">init_grpc_aio</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="grpc.experimental.aio.insecure_channel"><code class="name flex">
<span>def <span class="ident">insecure_channel</span></span>(<span>target, options=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an insecure asynchronous Channel to a server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>The server address</dd>
<dt><strong><code>options</code></strong></dt>
<dd>An optional list of key-value pairs (channel args
in gRPC Core runtime) to configure the channel.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An optional value indicating the compression method to be
used over the lifetime of the channel. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insecure_channel(target, options=None, compression=None):
    &#34;&#34;&#34;Creates an insecure asynchronous Channel to a server.

    Args:
      target: The server address
      options: An optional list of key-value pairs (channel args
        in gRPC Core runtime) to configure the channel.
      compression: An optional value indicating the compression method to be
        used over the lifetime of the channel. This is an EXPERIMENTAL option.

    Returns:
      A Channel.
    &#34;&#34;&#34;
    return Channel(target, ()
                   if options is None else options, None, compression)</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.server"><code class="name flex">
<span>def <span class="ident">server</span></span>(<span>migration_thread_pool=None, handlers=None, interceptors=None, options=None, maximum_concurrent_rpcs=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a Server with which RPCs can be serviced.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>migration_thread_pool</code></strong></dt>
<dd>A futures.ThreadPoolExecutor to be used by the
Server to execute non-AsyncIO RPC handlers for migration purpose.</dd>
<dt><strong><code>handlers</code></strong></dt>
<dd>An optional list of GenericRpcHandlers used for executing RPCs.
More handlers may be added by calling add_generic_rpc_handlers any time
before the server is started.</dd>
<dt><strong><code>interceptors</code></strong></dt>
<dd>An optional list of ServerInterceptor objects that observe
and optionally manipulate the incoming RPCs before handing them over to
handlers. The interceptors are given control in the order they are
specified. This is an EXPERIMENTAL API.</dd>
<dt><strong><code>options</code></strong></dt>
<dd>An optional list of key-value pairs (channel args in gRPC runtime)
to configure the channel.</dd>
<dt><strong><code>maximum_concurrent_rpcs</code></strong></dt>
<dd>The maximum number of concurrent RPCs this server
will service before returning RESOURCE_EXHAUSTED status, or None to
indicate no limit.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This compression algorithm will be used for the
lifetime of the server unless overridden. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Server object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server(migration_thread_pool=None,
           handlers=None,
           interceptors=None,
           options=None,
           maximum_concurrent_rpcs=None,
           compression=None):
    &#34;&#34;&#34;Creates a Server with which RPCs can be serviced.

    Args:
      migration_thread_pool: A futures.ThreadPoolExecutor to be used by the
        Server to execute non-AsyncIO RPC handlers for migration purpose.
      handlers: An optional list of GenericRpcHandlers used for executing RPCs.
        More handlers may be added by calling add_generic_rpc_handlers any time
        before the server is started.
      interceptors: An optional list of ServerInterceptor objects that observe
        and optionally manipulate the incoming RPCs before handing them over to
        handlers. The interceptors are given control in the order they are
        specified. This is an EXPERIMENTAL API.
      options: An optional list of key-value pairs (channel args in gRPC runtime)
        to configure the channel.
      maximum_concurrent_rpcs: The maximum number of concurrent RPCs this server
        will service before returning RESOURCE_EXHAUSTED status, or None to
        indicate no limit.
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This compression algorithm will be used for the
        lifetime of the server unless overridden. This is an EXPERIMENTAL option.

    Returns:
      A Server object.
    &#34;&#34;&#34;
    return Server(migration_thread_pool, ()
                  if handlers is None else handlers, ()
                  if interceptors is None else interceptors, ()
                  if options is None else options, maximum_concurrent_rpcs,
                  compression)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grpc.experimental.aio.AioRpcError"><code class="flex name class">
<span>class <span class="ident">AioRpcError</span></span>
<span>(</span><span>code, details=None, initial_metadata=None, trailing_metadata=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An RpcError to be used by the asynchronous API.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong></dt>
<dd>The status code with which the RPC has been finalized.</dd>
<dt><strong><code>details</code></strong></dt>
<dd>Optional details explaining the reason of the error.</dd>
<dt><strong><code>initial_metadata</code></strong></dt>
<dd>Optional initial metadata that could be sent by the
Server.</dd>
<dt><strong><code>trailing_metadata</code></strong></dt>
<dd>Optional metadata that could be sent by the Server.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AioRpcError(grpc.RpcError):
    &#34;&#34;&#34;An RpcError to be used by the asynchronous API.&#34;&#34;&#34;

    # TODO(https://github.com/grpc/grpc/issues/20144) Metadata
    # type returned by `initial_metadata` and `trailing_metadata`
    # and also taken in the constructor needs to be revisit and make
    # it more specific.

    _code: grpc.StatusCode
    _details: Optional[str]
    _initial_metadata: Optional[Dict]
    _trailing_metadata: Optional[Dict]

    def __init__(self,
                 code: grpc.StatusCode,
                 details: Optional[str] = None,
                 initial_metadata: Optional[Dict] = None,
                 trailing_metadata: Optional[Dict] = None):
        &#34;&#34;&#34;Constructor.

        Args:
          code: The status code with which the RPC has been finalized.
          details: Optional details explaining the reason of the error.
          initial_metadata: Optional initial metadata that could be sent by the
            Server.
          trailing_metadata: Optional metadata that could be sent by the Server.
        &#34;&#34;&#34;

        super().__init__(self)
        self._code = code
        self._details = details
        self._initial_metadata = initial_metadata
        self._trailing_metadata = trailing_metadata

    def code(self) -&gt; grpc.StatusCode:
        &#34;&#34;&#34;
        Returns:
          The `grpc.StatusCode` status code.
        &#34;&#34;&#34;
        return self._code

    def details(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns:
          The description of the error.
        &#34;&#34;&#34;
        return self._details

    def initial_metadata(self) -&gt; Optional[Dict]:
        &#34;&#34;&#34;
        Returns:
          The inital metadata received.
        &#34;&#34;&#34;
        return self._initial_metadata

    def trailing_metadata(self) -&gt; Optional[Dict]:
        &#34;&#34;&#34;
        Returns:
          The trailing metadata received.
        &#34;&#34;&#34;
        return self._trailing_metadata</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="grpc.RpcError" href="../../index.html#grpc.RpcError">RpcError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.experimental.aio.AioRpcError.code"><code class="name flex">
<span>def <span class="ident">code</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p>The <a title="grpc.StatusCode" href="../../index.html#grpc.StatusCode"><code>StatusCode</code></a> status code.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code(self) -&gt; grpc.StatusCode:
    &#34;&#34;&#34;
    Returns:
      The `grpc.StatusCode` status code.
    &#34;&#34;&#34;
    return self._code</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.AioRpcError.details"><code class="name flex">
<span>def <span class="ident">details</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p>The description of the error.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def details(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns:
      The description of the error.
    &#34;&#34;&#34;
    return self._details</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.AioRpcError.initial_metadata"><code class="name flex">
<span>def <span class="ident">initial_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p>The inital metadata received.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initial_metadata(self) -&gt; Optional[Dict]:
    &#34;&#34;&#34;
    Returns:
      The inital metadata received.
    &#34;&#34;&#34;
    return self._initial_metadata</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.AioRpcError.trailing_metadata"><code class="name flex">
<span>def <span class="ident">trailing_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p>The trailing metadata received.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trailing_metadata(self) -&gt; Optional[Dict]:
    &#34;&#34;&#34;
    Returns:
      The trailing metadata received.
    &#34;&#34;&#34;
    return self._trailing_metadata</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.experimental.aio.Call"><code class="flex name class">
<span>class <span class="ident">Call</span></span>
<span>(</span><span>call, response_deserializer, call_cancel_status)</span>
</code></dt>
<dd>
<section class="desc"><p>Object for managing RPC calls,
returned when an instance of <a title="grpc.experimental.aio.UnaryUnaryMultiCallable" href="#grpc.experimental.aio.UnaryUnaryMultiCallable"><code>UnaryUnaryMultiCallable</code></a> object is called.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>call</code></strong></dt>
<dd>Asyncio Task that holds the RPC execution.</dd>
<dt><strong><code>response_deserializer</code></strong></dt>
<dd>Deserializer used for parsing the reponse.</dd>
<dt><strong><code>call_cancel_status</code></strong></dt>
<dd>A cygrpc.AioCancelStatus used for giving a
specific error when the RPC is canceled.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Call:
    &#34;&#34;&#34;Object for managing RPC calls,
    returned when an instance of `UnaryUnaryMultiCallable` object is called.
    &#34;&#34;&#34;

    _cancellation_details: ClassVar[str] = &#39;Locally cancelled by application!&#39;

    _state: _RpcState
    _exception: Optional[Exception]
    _response: Optional[bytes]
    _code: grpc.StatusCode
    _details: Optional[str]
    _initial_metadata: Optional[Dict]
    _trailing_metadata: Optional[Dict]
    _call: asyncio.Task
    _call_cancel_status: cygrpc.AioCancelStatus
    _response_deserializer: DeserializingFunction

    def __init__(self, call: asyncio.Task,
                 response_deserializer: DeserializingFunction,
                 call_cancel_status: cygrpc.AioCancelStatus) -&gt; None:
        &#34;&#34;&#34;Constructor.

        Args:
          call: Asyncio Task that holds the RPC execution.
          response_deserializer: Deserializer used for parsing the reponse.
          call_cancel_status: A cygrpc.AioCancelStatus used for giving a
            specific error when the RPC is canceled.
        &#34;&#34;&#34;

        self._state = _RpcState.ONGOING
        self._exception = None
        self._response = None
        self._code = grpc.StatusCode.UNKNOWN
        self._details = None
        self._initial_metadata = None
        self._trailing_metadata = None
        self._call = call
        self._call_cancel_status = call_cancel_status
        self._response_deserializer = response_deserializer

    def __del__(self):
        self.cancel()

    def cancel(self) -&gt; bool:
        &#34;&#34;&#34;Cancels the ongoing RPC request.

        Returns:
          True if the RPC can be canceled, False if was already cancelled or terminated.
        &#34;&#34;&#34;
        if self.cancelled() or self.done():
            return False

        code = grpc.StatusCode.CANCELLED
        self._call_cancel_status.cancel(
            _common.STATUS_CODE_TO_CYGRPC_STATUS_CODE[code],
            details=Call._cancellation_details)
        self._call.cancel()
        self._details = Call._cancellation_details
        self._code = code
        self._state = _RpcState.CANCELLED
        return True

    def cancelled(self) -&gt; bool:
        &#34;&#34;&#34;Returns if the RPC was cancelled.

        Returns:
          True if the requests was cancelled, False if not.
        &#34;&#34;&#34;
        return self._state is _RpcState.CANCELLED

    def running(self) -&gt; bool:
        &#34;&#34;&#34;Returns if the RPC is running.

        Returns:
          True if the requests is running, False if it already terminated.
        &#34;&#34;&#34;
        return not self.done()

    def done(self) -&gt; bool:
        &#34;&#34;&#34;Returns if the RPC has finished.

        Returns:
          True if the requests has finished, False is if still ongoing.
        &#34;&#34;&#34;
        return self._state is not _RpcState.ONGOING

    async def initial_metadata(self):
        raise NotImplementedError()

    async def trailing_metadata(self):
        raise NotImplementedError()

    async def code(self) -&gt; grpc.StatusCode:
        &#34;&#34;&#34;Returns the `grpc.StatusCode` if the RPC is finished,
        otherwise first waits until the RPC finishes.

        Returns:
          The `grpc.StatusCode` status code.
        &#34;&#34;&#34;
        if not self.done():
            try:
                await self
            except (asyncio.CancelledError, AioRpcError):
                pass

        return self._code

    async def details(self) -&gt; str:
        &#34;&#34;&#34;Returns the details if the RPC is finished, otherwise first waits till the
        RPC finishes.

        Returns:
          The details.
        &#34;&#34;&#34;
        if not self.done():
            try:
                await self
            except (asyncio.CancelledError, AioRpcError):
                pass

        return self._details

    def __await__(self):
        &#34;&#34;&#34;Wait till the ongoing RPC request finishes.

        Returns:
          Response of the RPC call.

        Raises:
          AioRpcError: Indicating that the RPC terminated with non-OK status.
          asyncio.CancelledError: Indicating that the RPC was canceled.
        &#34;&#34;&#34;
        # We can not relay on the `done()` method since some exceptions
        # might be pending to be catched, like `asyncio.CancelledError`.
        if self._response:
            return self._response
        elif self._exception:
            raise self._exception

        try:
            buffer_ = yield from self._call.__await__()
        except cygrpc.AioRpcError as aio_rpc_error:
            self._state = _RpcState.ABORT
            self._code = _common.CYGRPC_STATUS_CODE_TO_STATUS_CODE[
                aio_rpc_error.code()]
            self._details = aio_rpc_error.details()
            self._initial_metadata = aio_rpc_error.initial_metadata()
            self._trailing_metadata = aio_rpc_error.trailing_metadata()

            # Propagates the pure Python class
            self._exception = AioRpcError(self._code, self._details,
                                          self._initial_metadata,
                                          self._trailing_metadata)
            raise self._exception from aio_rpc_error
        except asyncio.CancelledError as cancel_error:
            # _state, _code, _details are managed in the `cancel` method
            self._exception = cancel_error
            raise

        self._response = _common.deserialize(buffer_,
                                             self._response_deserializer)
        self._code = grpc.StatusCode.OK
        self._state = _RpcState.FINISHED
        return self._response</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.experimental.aio.Call.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Cancels the ongoing RPC request.</p>
<h2 id="returns">Returns</h2>
<p>True if the RPC can be canceled, False if was already cancelled or terminated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self) -&gt; bool:
    &#34;&#34;&#34;Cancels the ongoing RPC request.

    Returns:
      True if the RPC can be canceled, False if was already cancelled or terminated.
    &#34;&#34;&#34;
    if self.cancelled() or self.done():
        return False

    code = grpc.StatusCode.CANCELLED
    self._call_cancel_status.cancel(
        _common.STATUS_CODE_TO_CYGRPC_STATUS_CODE[code],
        details=Call._cancellation_details)
    self._call.cancel()
    self._details = Call._cancellation_details
    self._code = code
    self._state = _RpcState.CANCELLED
    return True</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.cancelled"><code class="name flex">
<span>def <span class="ident">cancelled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns if the RPC was cancelled.</p>
<h2 id="returns">Returns</h2>
<p>True if the requests was cancelled, False if not.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancelled(self) -&gt; bool:
    &#34;&#34;&#34;Returns if the RPC was cancelled.

    Returns:
      True if the requests was cancelled, False if not.
    &#34;&#34;&#34;
    return self._state is _RpcState.CANCELLED</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.code"><code class="name flex">
<span>async def <span class="ident">code</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the <a title="grpc.StatusCode" href="../../index.html#grpc.StatusCode"><code>StatusCode</code></a> if the RPC is finished,
otherwise first waits until the RPC finishes.</p>
<h2 id="returns">Returns</h2>
<p>The <a title="grpc.StatusCode" href="../../index.html#grpc.StatusCode"><code>StatusCode</code></a> status code.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def code(self) -&gt; grpc.StatusCode:
    &#34;&#34;&#34;Returns the `grpc.StatusCode` if the RPC is finished,
    otherwise first waits until the RPC finishes.

    Returns:
      The `grpc.StatusCode` status code.
    &#34;&#34;&#34;
    if not self.done():
        try:
            await self
        except (asyncio.CancelledError, AioRpcError):
            pass

    return self._code</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.details"><code class="name flex">
<span>async def <span class="ident">details</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the details if the RPC is finished, otherwise first waits till the
RPC finishes.</p>
<h2 id="returns">Returns</h2>
<p>The details.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def details(self) -&gt; str:
    &#34;&#34;&#34;Returns the details if the RPC is finished, otherwise first waits till the
    RPC finishes.

    Returns:
      The details.
    &#34;&#34;&#34;
    if not self.done():
        try:
            await self
        except (asyncio.CancelledError, AioRpcError):
            pass

    return self._details</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns if the RPC has finished.</p>
<h2 id="returns">Returns</h2>
<p>True if the requests has finished, False is if still ongoing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self) -&gt; bool:
    &#34;&#34;&#34;Returns if the RPC has finished.

    Returns:
      True if the requests has finished, False is if still ongoing.
    &#34;&#34;&#34;
    return self._state is not _RpcState.ONGOING</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.initial_metadata"><code class="name flex">
<span>async def <span class="ident">initial_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def initial_metadata(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.running"><code class="name flex">
<span>def <span class="ident">running</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns if the RPC is running.</p>
<h2 id="returns">Returns</h2>
<p>True if the requests is running, False if it already terminated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def running(self) -&gt; bool:
    &#34;&#34;&#34;Returns if the RPC is running.

    Returns:
      True if the requests is running, False if it already terminated.
    &#34;&#34;&#34;
    return not self.done()</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Call.trailing_metadata"><code class="name flex">
<span>async def <span class="ident">trailing_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def trailing_metadata(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.experimental.aio.Channel"><code class="flex name class">
<span>class <span class="ident">Channel</span></span>
<span>(</span><span>target, options, credentials, compression)</span>
</code></dt>
<dd>
<section class="desc"><p>Asynchronous Channel implementation.</p>
<p>A cygrpc.AioChannel-backed implementation.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>The target to which to connect.</dd>
<dt><strong><code>options</code></strong></dt>
<dd>Configuration options for the channel.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>A cygrpc.ChannelCredentials or None.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An optional value indicating the compression method to be
used over the lifetime of the channel.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Channel:
    &#34;&#34;&#34;Asynchronous Channel implementation.

    A cygrpc.AioChannel-backed implementation.
    &#34;&#34;&#34;

    def __init__(self, target, options, credentials, compression):
        &#34;&#34;&#34;Constructor.

        Args:
          target: The target to which to connect.
          options: Configuration options for the channel.
          credentials: A cygrpc.ChannelCredentials or None.
          compression: An optional value indicating the compression method to be
            used over the lifetime of the channel.
        &#34;&#34;&#34;

        if options:
            raise NotImplementedError(&#34;TODO: options not implemented yet&#34;)

        if credentials:
            raise NotImplementedError(&#34;TODO: credentials not implemented yet&#34;)

        if compression:
            raise NotImplementedError(&#34;TODO: compression not implemented yet&#34;)

        self._channel = cygrpc.AioChannel(_common.encode(target))

    def unary_unary(self,
                    method,
                    request_serializer=None,
                    response_deserializer=None):
        &#34;&#34;&#34;Creates a UnaryUnaryMultiCallable for a unary-unary method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None
            is passed.

        Returns:
          A UnaryUnaryMultiCallable value for the named unary-unary method.
        &#34;&#34;&#34;
        return UnaryUnaryMultiCallable(self._channel, _common.encode(method),
                                       request_serializer,
                                       response_deserializer)

    async def _close(self):
        # TODO: Send cancellation status
        self._channel.close()

    async def __aenter__(self):
        &#34;&#34;&#34;Starts an asynchronous context manager.

        Returns:
          Channel the channel that was instantiated.
        &#34;&#34;&#34;
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        &#34;&#34;&#34;Finishes the asynchronous context manager by closing gracefully the channel.&#34;&#34;&#34;
        await self._close()

    async def close(self):
        &#34;&#34;&#34;Closes this Channel and releases all resources held by it.

        Closing the Channel will proactively terminate all RPCs active with the
        Channel and it is not valid to invoke new RPCs with the Channel.

        This method is idempotent.
        &#34;&#34;&#34;
        await self._close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.experimental.aio.Channel.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Closes this Channel and releases all resources held by it.</p>
<p>Closing the Channel will proactively terminate all RPCs active with the
Channel and it is not valid to invoke new RPCs with the Channel.</p>
<p>This method is idempotent.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    &#34;&#34;&#34;Closes this Channel and releases all resources held by it.

    Closing the Channel will proactively terminate all RPCs active with the
    Channel and it is not valid to invoke new RPCs with the Channel.

    This method is idempotent.
    &#34;&#34;&#34;
    await self._close()</code></pre>
</details>
</dd>
<dt id="grpc.experimental.aio.Channel.unary_unary"><code class="name flex">
<span>def <span class="ident">unary_unary</span></span>(<span>self, method, request_serializer=None, response_deserializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a UnaryUnaryMultiCallable for a unary-unary method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The name of the RPC method.</dd>
<dt><strong><code>request_serializer</code></strong></dt>
<dd>Optional behaviour for serializing the request
message. Request goes unserialized in case None is passed.</dd>
<dt><strong><code>response_deserializer</code></strong></dt>
<dd>Optional behaviour for deserializing the
response message. Response goes undeserialized in case None
is passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A UnaryUnaryMultiCallable value for the named unary-unary method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unary_unary(self,
                method,
                request_serializer=None,
                response_deserializer=None):
    &#34;&#34;&#34;Creates a UnaryUnaryMultiCallable for a unary-unary method.

    Args:
      method: The name of the RPC method.
      request_serializer: Optional behaviour for serializing the request
        message. Request goes unserialized in case None is passed.
      response_deserializer: Optional behaviour for deserializing the
        response message. Response goes undeserialized in case None
        is passed.

    Returns:
      A UnaryUnaryMultiCallable value for the named unary-unary method.
    &#34;&#34;&#34;
    return UnaryUnaryMultiCallable(self._channel, _common.encode(method),
                                   request_serializer,
                                   response_deserializer)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.experimental.aio.UnaryUnaryMultiCallable"><code class="flex name class">
<span>class <span class="ident">UnaryUnaryMultiCallable</span></span>
<span>(</span><span>channel, method, request_serializer, response_deserializer)</span>
</code></dt>
<dd>
<section class="desc"><p>Afford invoking a unary-unary RPC from client-side in an asynchronous way.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryUnaryMultiCallable:
    &#34;&#34;&#34;Afford invoking a unary-unary RPC from client-side in an asynchronous way.&#34;&#34;&#34;

    def __init__(self, channel: cygrpc.AioChannel, method: bytes,
                 request_serializer: SerializingFunction,
                 response_deserializer: DeserializingFunction) -&gt; None:
        self._channel = channel
        self._method = method
        self._request_serializer = request_serializer
        self._response_deserializer = response_deserializer
        self._loop = asyncio.get_event_loop()

    def _timeout_to_deadline(self, timeout: int) -&gt; Optional[int]:
        if timeout is None:
            return None
        return self._loop.time() + timeout

    def __call__(self,
                 request,
                 *,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None) -&gt; Call:
        &#34;&#34;&#34;Asynchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow
            for the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          A Call object instance which is an awaitable object.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;

        if metadata:
            raise NotImplementedError(&#34;TODO: metadata not implemented yet&#34;)

        if credentials:
            raise NotImplementedError(&#34;TODO: credentials not implemented yet&#34;)

        if wait_for_ready:
            raise NotImplementedError(
                &#34;TODO: wait_for_ready not implemented yet&#34;)

        if compression:
            raise NotImplementedError(&#34;TODO: compression not implemented yet&#34;)

        serialized_request = _common.serialize(request,
                                               self._request_serializer)
        timeout = self._timeout_to_deadline(timeout)
        aio_cancel_status = cygrpc.AioCancelStatus()
        aio_call = asyncio.ensure_future(
            self._channel.unary_unary(self._method, serialized_request, timeout,
                                      aio_cancel_status),
            loop=self._loop)
        return Call(aio_call, self._response_deserializer, aio_cancel_status)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grpc.experimental" href="../index.html">grpc.experimental</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="grpc.experimental.aio.init_grpc_aio" href="#grpc.experimental.aio.init_grpc_aio">init_grpc_aio</a></code></li>
<li><code><a title="grpc.experimental.aio.insecure_channel" href="#grpc.experimental.aio.insecure_channel">insecure_channel</a></code></li>
<li><code><a title="grpc.experimental.aio.server" href="#grpc.experimental.aio.server">server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grpc.experimental.aio.AioRpcError" href="#grpc.experimental.aio.AioRpcError">AioRpcError</a></code></h4>
<ul class="">
<li><code><a title="grpc.experimental.aio.AioRpcError.code" href="#grpc.experimental.aio.AioRpcError.code">code</a></code></li>
<li><code><a title="grpc.experimental.aio.AioRpcError.details" href="#grpc.experimental.aio.AioRpcError.details">details</a></code></li>
<li><code><a title="grpc.experimental.aio.AioRpcError.initial_metadata" href="#grpc.experimental.aio.AioRpcError.initial_metadata">initial_metadata</a></code></li>
<li><code><a title="grpc.experimental.aio.AioRpcError.trailing_metadata" href="#grpc.experimental.aio.AioRpcError.trailing_metadata">trailing_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.experimental.aio.Call" href="#grpc.experimental.aio.Call">Call</a></code></h4>
<ul class="two-column">
<li><code><a title="grpc.experimental.aio.Call.cancel" href="#grpc.experimental.aio.Call.cancel">cancel</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.cancelled" href="#grpc.experimental.aio.Call.cancelled">cancelled</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.code" href="#grpc.experimental.aio.Call.code">code</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.details" href="#grpc.experimental.aio.Call.details">details</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.done" href="#grpc.experimental.aio.Call.done">done</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.initial_metadata" href="#grpc.experimental.aio.Call.initial_metadata">initial_metadata</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.running" href="#grpc.experimental.aio.Call.running">running</a></code></li>
<li><code><a title="grpc.experimental.aio.Call.trailing_metadata" href="#grpc.experimental.aio.Call.trailing_metadata">trailing_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.experimental.aio.Channel" href="#grpc.experimental.aio.Channel">Channel</a></code></h4>
<ul class="">
<li><code><a title="grpc.experimental.aio.Channel.close" href="#grpc.experimental.aio.Channel.close">close</a></code></li>
<li><code><a title="grpc.experimental.aio.Channel.unary_unary" href="#grpc.experimental.aio.Channel.unary_unary">unary_unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.experimental.aio.UnaryUnaryMultiCallable" href="#grpc.experimental.aio.UnaryUnaryMultiCallable">UnaryUnaryMultiCallable</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>