<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.protobuf.internal.message_test API documentation</title>
<meta name="description" content="Tests python protocol buffers against the golden message …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.protobuf.internal.message_test</code></h1>
</header>
<section id="section-intro">
<p>Tests python protocol buffers against the golden message.</p>
<p>Note that the golden messages exercise every known field type, thus this
test ends up exercising and verifying nearly all of the parsing and
serialization code in the whole library.</p>
<p>TODO(kenton):
Merge with wire_format_test?
It doesn't make a whole lot of
sense to call this a test of the "message" module, which only declares an
abstract interface.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Protocol Buffers - Google&#39;s data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

&#34;&#34;&#34;Tests python protocol buffers against the golden message.

Note that the golden messages exercise every known field type, thus this
test ends up exercising and verifying nearly all of the parsing and
serialization code in the whole library.

TODO(kenton):  Merge with wire_format_test?  It doesn&#39;t make a whole lot of
sense to call this a test of the &#34;message&#34; module, which only declares an
abstract interface.
&#34;&#34;&#34;

__author__ = &#39;gps@google.com (Gregory P. Smith)&#39;


import copy
import math
import operator
import pickle
import pydoc
import six
import sys
import warnings

try:
  # Since python 3
  import collections.abc as collections_abc
except ImportError:
  # Won&#39;t work after python 3.8
  import collections as collections_abc

try:
  import unittest2 as unittest  # PY26
except ImportError:
  import unittest
try:
  cmp                                   # Python 2
except NameError:
  cmp = lambda x, y: (x &gt; y) - (x &lt; y)  # Python 3

from google.protobuf import map_proto2_unittest_pb2
from google.protobuf import map_unittest_pb2
from google.protobuf import unittest_pb2
from google.protobuf import unittest_proto3_arena_pb2
from google.protobuf import descriptor_pb2
from google.protobuf import descriptor_pool
from google.protobuf import message_factory
from google.protobuf import text_format
from google.protobuf.internal import api_implementation
from google.protobuf.internal import encoder
from google.protobuf.internal import more_extensions_pb2
from google.protobuf.internal import packed_field_test_pb2
from google.protobuf.internal import test_util
from google.protobuf.internal import testing_refleaks
from google.protobuf import message
from google.protobuf.internal import _parameterized

UCS2_MAXUNICODE = 65535
if six.PY3:
  long = int


# Python pre-2.6 does not have isinf() or isnan() functions, so we have
# to provide our own.
def isnan(val):
  # NaN is never equal to itself.
  return val != val
def isinf(val):
  # Infinity times zero equals NaN.
  return not isnan(val) and isnan(val * 0)
def IsPosInf(val):
  return isinf(val) and (val &gt; 0)
def IsNegInf(val):
  return isinf(val) and (val &lt; 0)


@_parameterized.named_parameters(
    (&#39;_proto2&#39;, unittest_pb2),
    (&#39;_proto3&#39;, unittest_proto3_arena_pb2))
@testing_refleaks.TestCase
class MessageTest(unittest.TestCase):

  def testBadUtf8String(self, message_module):
    if api_implementation.Type() != &#39;python&#39;:
      self.skipTest(&#34;Skipping testBadUtf8String, currently only the python &#34;
                    &#34;api implementation raises UnicodeDecodeError when a &#34;
                    &#34;string field contains bad utf-8.&#34;)
    bad_utf8_data = test_util.GoldenFileData(&#39;bad_utf8_string&#39;)
    with self.assertRaises(UnicodeDecodeError) as context:
      message_module.TestAllTypes.FromString(bad_utf8_data)
    self.assertIn(&#39;TestAllTypes.optional_string&#39;, str(context.exception))

  def testGoldenMessage(self, message_module):
    # Proto3 doesn&#39;t have the &#34;default_foo&#34; members or foreign enums,
    # and doesn&#39;t preserve unknown fields, so for proto3 we use a golden
    # message that doesn&#39;t have these fields set.
    if message_module is unittest_pb2:
      golden_data = test_util.GoldenFileData(
          &#39;golden_message_oneof_implemented&#39;)
    else:
      golden_data = test_util.GoldenFileData(&#39;golden_message_proto3&#39;)

    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    if message_module is unittest_pb2:
      test_util.ExpectAllFieldsSet(self, golden_message)
    self.assertEqual(golden_data, golden_message.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testGoldenPackedMessage(self, message_module):
    golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
    golden_message = message_module.TestPackedTypes()
    parsed_bytes = golden_message.ParseFromString(golden_data)
    all_set = message_module.TestPackedTypes()
    test_util.SetAllPackedFields(all_set)
    self.assertEqual(parsed_bytes, len(golden_data))
    self.assertEqual(all_set, golden_message)
    self.assertEqual(golden_data, all_set.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testParseErrors(self, message_module):
    msg = message_module.TestAllTypes()
    self.assertRaises(TypeError, msg.FromString, 0)
    self.assertRaises(Exception, msg.FromString, &#39;0&#39;)
    # TODO(jieluo): Fix cpp extension to raise error instead of warning.
    # b/27494216
    end_tag = encoder.TagBytes(1, 4)
    if api_implementation.Type() == &#39;python&#39;:
      with self.assertRaises(message.DecodeError) as context:
        msg.FromString(end_tag)
      self.assertEqual(&#39;Unexpected end-group tag.&#39;, str(context.exception))

    # Field number 0 is illegal.
    self.assertRaises(message.DecodeError, msg.FromString, b&#39;\3\4&#39;)

  def testDeterminismParameters(self, message_module):
    # This message is always deterministically serialized, even if determinism
    # is disabled, so we can use it to verify that all the determinism
    # parameters work correctly.
    golden_data = (b&#39;\xe2\x02\nOne string&#39;
                   b&#39;\xe2\x02\nTwo string&#39;
                   b&#39;\xe2\x02\nRed string&#39;
                   b&#39;\xe2\x02\x0bBlue string&#39;)
    golden_message = message_module.TestAllTypes()
    golden_message.repeated_string.extend([
        &#39;One string&#39;,
        &#39;Two string&#39;,
        &#39;Red string&#39;,
        &#39;Blue string&#39;,
    ])
    self.assertEqual(golden_data,
                     golden_message.SerializeToString(deterministic=None))
    self.assertEqual(golden_data,
                     golden_message.SerializeToString(deterministic=False))
    self.assertEqual(golden_data,
                     golden_message.SerializeToString(deterministic=True))

    class BadArgError(Exception):
      pass

    class BadArg(object):

      def __nonzero__(self):
        raise BadArgError()

      def __bool__(self):
        raise BadArgError()

    with self.assertRaises(BadArgError):
      golden_message.SerializeToString(deterministic=BadArg())

  def testPickleSupport(self, message_module):
    golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    pickled_message = pickle.dumps(golden_message)

    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)

  def testPickleNestedMessage(self, message_module):
    golden_message = message_module.TestPickleNestedMessage.NestedMessage(bb=1)
    pickled_message = pickle.dumps(golden_message)
    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)

  def testPickleNestedNestedMessage(self, message_module):
    cls = message_module.TestPickleNestedMessage.NestedMessage
    golden_message = cls.NestedNestedMessage(cc=1)
    pickled_message = pickle.dumps(golden_message)
    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)

  def testPositiveInfinity(self, message_module):
    if message_module is unittest_pb2:
      golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                     b&#39;\xCD\x02\x00\x00\x80\x7F&#39;
                     b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
    else:
      golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                     b&#39;\xCA\x02\x04\x00\x00\x80\x7F&#39;
                     b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)

    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsPosInf(golden_message.optional_float))
    self.assertTrue(IsPosInf(golden_message.optional_double))
    self.assertTrue(IsPosInf(golden_message.repeated_float[0]))
    self.assertTrue(IsPosInf(golden_message.repeated_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNegativeInfinity(self, message_module):
    if message_module is unittest_pb2:
      golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                     b&#39;\xCD\x02\x00\x00\x80\xFF&#39;
                     b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
    else:
      golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                     b&#39;\xCA\x02\x04\x00\x00\x80\xFF&#39;
                     b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)

    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsNegInf(golden_message.optional_float))
    self.assertTrue(IsNegInf(golden_message.optional_double))
    self.assertTrue(IsNegInf(golden_message.repeated_float[0]))
    self.assertTrue(IsNegInf(golden_message.repeated_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNotANumber(self, message_module):
    golden_data = (b&#39;\x5D\x00\x00\xC0\x7F&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;
                   b&#39;\xCD\x02\x00\x00\xC0\x7F&#39;
                   b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(isnan(golden_message.optional_float))
    self.assertTrue(isnan(golden_message.optional_double))
    self.assertTrue(isnan(golden_message.repeated_float[0]))
    self.assertTrue(isnan(golden_message.repeated_double[0]))

    # The protocol buffer may serialize to any one of multiple different
    # representations of a NaN.  Rather than verify a specific representation,
    # verify the serialized string can be converted into a correctly
    # behaving protocol buffer.
    serialized = golden_message.SerializeToString()
    message = message_module.TestAllTypes()
    message.ParseFromString(serialized)
    self.assertTrue(isnan(message.optional_float))
    self.assertTrue(isnan(message.optional_double))
    self.assertTrue(isnan(message.repeated_float[0]))
    self.assertTrue(isnan(message.repeated_double[0]))

  def testPositiveInfinityPacked(self, message_module):
    golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\x7F&#39;
                   b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
    golden_message = message_module.TestPackedTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsPosInf(golden_message.packed_float[0]))
    self.assertTrue(IsPosInf(golden_message.packed_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNegativeInfinityPacked(self, message_module):
    golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\xFF&#39;
                   b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
    golden_message = message_module.TestPackedTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsNegInf(golden_message.packed_float[0]))
    self.assertTrue(IsNegInf(golden_message.packed_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNotANumberPacked(self, message_module):
    golden_data = (b&#39;\xA2\x06\x04\x00\x00\xC0\x7F&#39;
                   b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
    golden_message = message_module.TestPackedTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(isnan(golden_message.packed_float[0]))
    self.assertTrue(isnan(golden_message.packed_double[0]))

    serialized = golden_message.SerializeToString()
    message = message_module.TestPackedTypes()
    message.ParseFromString(serialized)
    self.assertTrue(isnan(message.packed_float[0]))
    self.assertTrue(isnan(message.packed_double[0]))

  def testExtremeFloatValues(self, message_module):
    message = message_module.TestAllTypes()

    # Most positive exponent, no significand bits set.
    kMostPosExponentNoSigBits = math.pow(2, 127)
    message.optional_float = kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostPosExponentNoSigBits)

    # Most positive exponent, one significand bit set.
    kMostPosExponentOneSigBit = 1.5 * math.pow(2, 127)
    message.optional_float = kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostPosExponentOneSigBit)

    # Repeat last two cases with values of same magnitude, but negative.
    message.optional_float = -kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostPosExponentNoSigBits)

    message.optional_float = -kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostPosExponentOneSigBit)

    # Most negative exponent, no significand bits set.
    kMostNegExponentNoSigBits = math.pow(2, -127)
    message.optional_float = kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostNegExponentNoSigBits)

    # Most negative exponent, one significand bit set.
    kMostNegExponentOneSigBit = 1.5 * math.pow(2, -127)
    message.optional_float = kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostNegExponentOneSigBit)

    # Repeat last two cases with values of the same magnitude, but negative.
    message.optional_float = -kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostNegExponentNoSigBits)

    message.optional_float = -kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostNegExponentOneSigBit)

    # Max 4 bytes float value
    max_float = float.fromhex(&#39;0x1.fffffep+127&#39;)
    message.optional_float = max_float
    self.assertAlmostEqual(message.optional_float, max_float)
    serialized_data = message.SerializeToString()
    message.ParseFromString(serialized_data)
    self.assertAlmostEqual(message.optional_float, max_float)

    # Test set double to float field.
    message.optional_float = 3.4028235e+39
    self.assertEqual(message.optional_float, float(&#39;inf&#39;))
    serialized_data = message.SerializeToString()
    message.ParseFromString(serialized_data)
    self.assertEqual(message.optional_float, float(&#39;inf&#39;))

    message.optional_float = -3.4028235e+39
    self.assertEqual(message.optional_float, float(&#39;-inf&#39;))

    message.optional_float = 1.4028235e-39
    self.assertAlmostEqual(message.optional_float, 1.4028235e-39)

  def testExtremeDoubleValues(self, message_module):
    message = message_module.TestAllTypes()

    # Most positive exponent, no significand bits set.
    kMostPosExponentNoSigBits = math.pow(2, 1023)
    message.optional_double = kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostPosExponentNoSigBits)

    # Most positive exponent, one significand bit set.
    kMostPosExponentOneSigBit = 1.5 * math.pow(2, 1023)
    message.optional_double = kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostPosExponentOneSigBit)

    # Repeat last two cases with values of same magnitude, but negative.
    message.optional_double = -kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostPosExponentNoSigBits)

    message.optional_double = -kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostPosExponentOneSigBit)

    # Most negative exponent, no significand bits set.
    kMostNegExponentNoSigBits = math.pow(2, -1023)
    message.optional_double = kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostNegExponentNoSigBits)

    # Most negative exponent, one significand bit set.
    kMostNegExponentOneSigBit = 1.5 * math.pow(2, -1023)
    message.optional_double = kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostNegExponentOneSigBit)

    # Repeat last two cases with values of the same magnitude, but negative.
    message.optional_double = -kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostNegExponentNoSigBits)

    message.optional_double = -kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostNegExponentOneSigBit)

  def testFloatPrinting(self, message_module):
    message = message_module.TestAllTypes()
    message.optional_float = 2.0
    self.assertEqual(str(message), &#39;optional_float: 2.0\n&#39;)

  def testHighPrecisionFloatPrinting(self, message_module):
    message = message_module.TestAllTypes()
    message.optional_double = 0.12345678912345678
    if sys.version_info &gt;= (3,):
      self.assertEqual(str(message), &#39;optional_double: 0.12345678912345678\n&#39;)
    else:
      self.assertEqual(str(message), &#39;optional_double: 0.123456789123\n&#39;)

  def testUnknownFieldPrinting(self, message_module):
    populated = message_module.TestAllTypes()
    test_util.SetAllNonLazyFields(populated)
    empty = message_module.TestEmptyMessage()
    empty.ParseFromString(populated.SerializeToString())
    self.assertEqual(str(empty), &#39;&#39;)

  def testAppendRepeatedCompositeField(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_nested_message.append(
        message_module.TestAllTypes.NestedMessage(bb=1))
    nested = message_module.TestAllTypes.NestedMessage(bb=2)
    msg.repeated_nested_message.append(nested)
    try:
      msg.repeated_nested_message.append(1)
    except TypeError:
      pass
    self.assertEqual(2, len(msg.repeated_nested_message))
    self.assertEqual([1, 2],
                     [m.bb for m in msg.repeated_nested_message])

  def testInsertRepeatedCompositeField(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_nested_message.insert(
        -1, message_module.TestAllTypes.NestedMessage(bb=1))
    sub_msg = msg.repeated_nested_message[0]
    msg.repeated_nested_message.insert(
        0, message_module.TestAllTypes.NestedMessage(bb=2))
    msg.repeated_nested_message.insert(
        99, message_module.TestAllTypes.NestedMessage(bb=3))
    msg.repeated_nested_message.insert(
        -2, message_module.TestAllTypes.NestedMessage(bb=-1))
    msg.repeated_nested_message.insert(
        -1000, message_module.TestAllTypes.NestedMessage(bb=-1000))
    try:
      msg.repeated_nested_message.insert(1, 999)
    except TypeError:
      pass
    self.assertEqual(5, len(msg.repeated_nested_message))
    self.assertEqual([-1000, 2, -1, 1, 3],
                     [m.bb for m in msg.repeated_nested_message])
    self.assertEqual(str(msg),
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: -1000\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: 2\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: -1\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: 1\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: 3\n&#39;
                     &#39;}\n&#39;)
    self.assertEqual(sub_msg.bb, 1)

  def testMergeFromRepeatedField(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_int32.append(1)
    msg.repeated_int32.append(3)
    msg.repeated_nested_message.add(bb=1)
    msg.repeated_nested_message.add(bb=2)
    other_msg = message_module.TestAllTypes()
    other_msg.repeated_nested_message.add(bb=3)
    other_msg.repeated_nested_message.add(bb=4)
    other_msg.repeated_int32.append(5)
    other_msg.repeated_int32.append(7)

    msg.repeated_int32.MergeFrom(other_msg.repeated_int32)
    self.assertEqual(4, len(msg.repeated_int32))

    msg.repeated_nested_message.MergeFrom(other_msg.repeated_nested_message)
    self.assertEqual([1, 2, 3, 4],
                     [m.bb for m in msg.repeated_nested_message])

  def testAddWrongRepeatedNestedField(self, message_module):
    msg = message_module.TestAllTypes()
    try:
      msg.repeated_nested_message.add(&#39;wrong&#39;)
    except TypeError:
      pass
    try:
      msg.repeated_nested_message.add(value_field=&#39;wrong&#39;)
    except ValueError:
      pass
    self.assertEqual(len(msg.repeated_nested_message), 0)

  def testRepeatedContains(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_int32.extend([1, 2, 3])
    self.assertIn(2, msg.repeated_int32)
    self.assertNotIn(0, msg.repeated_int32)

    msg.repeated_nested_message.add(bb=1)
    sub_msg1 = msg.repeated_nested_message[0]
    sub_msg2 = message_module.TestAllTypes.NestedMessage(bb=2)
    sub_msg3 = message_module.TestAllTypes.NestedMessage(bb=3)
    msg.repeated_nested_message.append(sub_msg2)
    msg.repeated_nested_message.insert(0, sub_msg3)
    self.assertIn(sub_msg1, msg.repeated_nested_message)
    self.assertIn(sub_msg2, msg.repeated_nested_message)
    self.assertIn(sub_msg3, msg.repeated_nested_message)

  def testRepeatedScalarIterable(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_int32.extend([1, 2, 3])
    add = 0
    for item in msg.repeated_int32:
      add += item
    self.assertEqual(add, 6)

  def testRepeatedNestedFieldIteration(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_nested_message.add(bb=1)
    msg.repeated_nested_message.add(bb=2)
    msg.repeated_nested_message.add(bb=3)
    msg.repeated_nested_message.add(bb=4)

    self.assertEqual([1, 2, 3, 4],
                     [m.bb for m in msg.repeated_nested_message])
    self.assertEqual([4, 3, 2, 1],
                     [m.bb for m in reversed(msg.repeated_nested_message)])
    self.assertEqual([4, 3, 2, 1],
                     [m.bb for m in msg.repeated_nested_message[::-1]])

  def testSortingRepeatedScalarFieldsDefaultComparator(self, message_module):
    &#34;&#34;&#34;Check some different types with the default comparator.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    # TODO(mattp): would testing more scalar types strengthen test?
    message.repeated_int32.append(1)
    message.repeated_int32.append(3)
    message.repeated_int32.append(2)
    message.repeated_int32.sort()
    self.assertEqual(message.repeated_int32[0], 1)
    self.assertEqual(message.repeated_int32[1], 2)
    self.assertEqual(message.repeated_int32[2], 3)
    self.assertEqual(str(message.repeated_int32), str([1, 2, 3]))

    message.repeated_float.append(1.1)
    message.repeated_float.append(1.3)
    message.repeated_float.append(1.2)
    message.repeated_float.sort()
    self.assertAlmostEqual(message.repeated_float[0], 1.1)
    self.assertAlmostEqual(message.repeated_float[1], 1.2)
    self.assertAlmostEqual(message.repeated_float[2], 1.3)

    message.repeated_string.append(&#39;a&#39;)
    message.repeated_string.append(&#39;c&#39;)
    message.repeated_string.append(&#39;b&#39;)
    message.repeated_string.sort()
    self.assertEqual(message.repeated_string[0], &#39;a&#39;)
    self.assertEqual(message.repeated_string[1], &#39;b&#39;)
    self.assertEqual(message.repeated_string[2], &#39;c&#39;)
    self.assertEqual(str(message.repeated_string), str([u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;]))

    message.repeated_bytes.append(b&#39;a&#39;)
    message.repeated_bytes.append(b&#39;c&#39;)
    message.repeated_bytes.append(b&#39;b&#39;)
    message.repeated_bytes.sort()
    self.assertEqual(message.repeated_bytes[0], b&#39;a&#39;)
    self.assertEqual(message.repeated_bytes[1], b&#39;b&#39;)
    self.assertEqual(message.repeated_bytes[2], b&#39;c&#39;)
    self.assertEqual(str(message.repeated_bytes), str([b&#39;a&#39;, b&#39;b&#39;, b&#39;c&#39;]))

  def testSortingRepeatedScalarFieldsCustomComparator(self, message_module):
    &#34;&#34;&#34;Check some different types with custom comparator.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_int32.append(-3)
    message.repeated_int32.append(-2)
    message.repeated_int32.append(-1)
    message.repeated_int32.sort(key=abs)
    self.assertEqual(message.repeated_int32[0], -1)
    self.assertEqual(message.repeated_int32[1], -2)
    self.assertEqual(message.repeated_int32[2], -3)

    message.repeated_string.append(&#39;aaa&#39;)
    message.repeated_string.append(&#39;bb&#39;)
    message.repeated_string.append(&#39;c&#39;)
    message.repeated_string.sort(key=len)
    self.assertEqual(message.repeated_string[0], &#39;c&#39;)
    self.assertEqual(message.repeated_string[1], &#39;bb&#39;)
    self.assertEqual(message.repeated_string[2], &#39;aaa&#39;)

  def testSortingRepeatedCompositeFieldsCustomComparator(self, message_module):
    &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_nested_message.add().bb = 1
    message.repeated_nested_message.add().bb = 3
    message.repeated_nested_message.add().bb = 2
    message.repeated_nested_message.add().bb = 6
    message.repeated_nested_message.add().bb = 5
    message.repeated_nested_message.add().bb = 4
    message.repeated_nested_message.sort(key=operator.attrgetter(&#39;bb&#39;))
    self.assertEqual(message.repeated_nested_message[0].bb, 1)
    self.assertEqual(message.repeated_nested_message[1].bb, 2)
    self.assertEqual(message.repeated_nested_message[2].bb, 3)
    self.assertEqual(message.repeated_nested_message[3].bb, 4)
    self.assertEqual(message.repeated_nested_message[4].bb, 5)
    self.assertEqual(message.repeated_nested_message[5].bb, 6)
    self.assertEqual(str(message.repeated_nested_message),
                     &#39;[bb: 1\n, bb: 2\n, bb: 3\n, bb: 4\n, bb: 5\n, bb: 6\n]&#39;)

  def testSortingRepeatedCompositeFieldsStable(self, message_module):
    &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_nested_message.add().bb = 21
    message.repeated_nested_message.add().bb = 20
    message.repeated_nested_message.add().bb = 13
    message.repeated_nested_message.add().bb = 33
    message.repeated_nested_message.add().bb = 11
    message.repeated_nested_message.add().bb = 24
    message.repeated_nested_message.add().bb = 10
    message.repeated_nested_message.sort(key=lambda z: z.bb // 10)
    self.assertEqual(
        [13, 11, 10, 21, 20, 24, 33],
        [n.bb for n in message.repeated_nested_message])

    # Make sure that for the C++ implementation, the underlying fields
    # are actually reordered.
    pb = message.SerializeToString()
    message.Clear()
    message.MergeFromString(pb)
    self.assertEqual(
        [13, 11, 10, 21, 20, 24, 33],
        [n.bb for n in message.repeated_nested_message])

  def testRepeatedCompositeFieldSortArguments(self, message_module):
    &#34;&#34;&#34;Check sorting a repeated composite field using list.sort() arguments.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    get_bb = operator.attrgetter(&#39;bb&#39;)
    cmp_bb = lambda a, b: cmp(a.bb, b.bb)
    message.repeated_nested_message.add().bb = 1
    message.repeated_nested_message.add().bb = 3
    message.repeated_nested_message.add().bb = 2
    message.repeated_nested_message.add().bb = 6
    message.repeated_nested_message.add().bb = 5
    message.repeated_nested_message.add().bb = 4
    message.repeated_nested_message.sort(key=get_bb)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [1, 2, 3, 4, 5, 6])
    message.repeated_nested_message.sort(key=get_bb, reverse=True)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [6, 5, 4, 3, 2, 1])
    if sys.version_info &gt;= (3,): return  # No cmp sorting in PY3.
    message.repeated_nested_message.sort(sort_function=cmp_bb)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [1, 2, 3, 4, 5, 6])
    message.repeated_nested_message.sort(cmp=cmp_bb, reverse=True)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [6, 5, 4, 3, 2, 1])

  def testRepeatedScalarFieldSortArguments(self, message_module):
    &#34;&#34;&#34;Check sorting a scalar field using list.sort() arguments.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_int32.append(-3)
    message.repeated_int32.append(-2)
    message.repeated_int32.append(-1)
    message.repeated_int32.sort(key=abs)
    self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
    message.repeated_int32.sort(key=abs, reverse=True)
    self.assertEqual(list(message.repeated_int32), [-3, -2, -1])
    if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
      abs_cmp = lambda a, b: cmp(abs(a), abs(b))
      message.repeated_int32.sort(sort_function=abs_cmp)
      self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
      message.repeated_int32.sort(cmp=abs_cmp, reverse=True)
      self.assertEqual(list(message.repeated_int32), [-3, -2, -1])

    message.repeated_string.append(&#39;aaa&#39;)
    message.repeated_string.append(&#39;bb&#39;)
    message.repeated_string.append(&#39;c&#39;)
    message.repeated_string.sort(key=len)
    self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
    message.repeated_string.sort(key=len, reverse=True)
    self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])
    if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
      len_cmp = lambda a, b: cmp(len(a), len(b))
      message.repeated_string.sort(sort_function=len_cmp)
      self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
      message.repeated_string.sort(cmp=len_cmp, reverse=True)
      self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])

  def testRepeatedFieldsComparable(self, message_module):
    m1 = message_module.TestAllTypes()
    m2 = message_module.TestAllTypes()
    m1.repeated_int32.append(0)
    m1.repeated_int32.append(1)
    m1.repeated_int32.append(2)
    m2.repeated_int32.append(0)
    m2.repeated_int32.append(1)
    m2.repeated_int32.append(2)
    m1.repeated_nested_message.add().bb = 1
    m1.repeated_nested_message.add().bb = 2
    m1.repeated_nested_message.add().bb = 3
    m2.repeated_nested_message.add().bb = 1
    m2.repeated_nested_message.add().bb = 2
    m2.repeated_nested_message.add().bb = 3

    if sys.version_info &gt;= (3,): return  # No cmp() in PY3.

    # These comparisons should not raise errors.
    _ = m1 &lt; m2
    _ = m1.repeated_nested_message &lt; m2.repeated_nested_message

    # Make sure cmp always works. If it wasn&#39;t defined, these would be
    # id() comparisons and would all fail.
    self.assertEqual(cmp(m1, m2), 0)
    self.assertEqual(cmp(m1.repeated_int32, m2.repeated_int32), 0)
    self.assertEqual(cmp(m1.repeated_int32, [0, 1, 2]), 0)
    self.assertEqual(cmp(m1.repeated_nested_message,
                         m2.repeated_nested_message), 0)
    with self.assertRaises(TypeError):
      # Can&#39;t compare repeated composite containers to lists.
      cmp(m1.repeated_nested_message, m2.repeated_nested_message[:])

    # TODO(anuraag): Implement extensiondict comparison in C++ and then add test

  def testRepeatedFieldsAreSequences(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIsInstance(m.repeated_int32, collections_abc.MutableSequence)
    self.assertIsInstance(m.repeated_nested_message,
                          collections_abc.MutableSequence)

  def testRepeatedFieldsNotHashable(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(TypeError):
      hash(m.repeated_int32)
    with self.assertRaises(TypeError):
      hash(m.repeated_nested_message)

  def testRepeatedFieldInsideNestedMessage(self, message_module):
    m = message_module.NestedTestAllTypes()
    m.payload.repeated_int32.extend([])
    self.assertTrue(m.HasField(&#39;payload&#39;))

  def testMergeFrom(self, message_module):
    m1 = message_module.TestAllTypes()
    m2 = message_module.TestAllTypes()
    # Cpp extension will lazily create a sub message which is immutable.
    nested = m1.optional_nested_message
    self.assertEqual(0, nested.bb)
    m2.optional_nested_message.bb = 1
    # Make sure cmessage pointing to a mutable message after merge instead of
    # the lazily created message.
    m1.MergeFrom(m2)
    self.assertEqual(1, nested.bb)

    # Test more nested sub message.
    msg1 = message_module.NestedTestAllTypes()
    msg2 = message_module.NestedTestAllTypes()
    nested = msg1.child.payload.optional_nested_message
    self.assertEqual(0, nested.bb)
    msg2.child.payload.optional_nested_message.bb = 1
    msg1.MergeFrom(msg2)
    self.assertEqual(1, nested.bb)

    # Test repeated field.
    self.assertEqual(msg1.payload.repeated_nested_message,
                     msg1.payload.repeated_nested_message)
    nested = msg2.payload.repeated_nested_message.add()
    nested.bb = 1
    msg1.MergeFrom(msg2)
    self.assertEqual(1, len(msg1.payload.repeated_nested_message))
    self.assertEqual(1, nested.bb)

  def testMergeFromString(self, message_module):
    m1 = message_module.TestAllTypes()
    m2 = message_module.TestAllTypes()
    # Cpp extension will lazily create a sub message which is immutable.
    self.assertEqual(0, m1.optional_nested_message.bb)
    m2.optional_nested_message.bb = 1
    # Make sure cmessage pointing to a mutable message after merge instead of
    # the lazily created message.
    m1.MergeFromString(m2.SerializeToString())
    self.assertEqual(1, m1.optional_nested_message.bb)

  @unittest.skipIf(six.PY2, &#39;memoryview objects are not supported on py2&#39;)
  def testMergeFromStringUsingMemoryViewWorksInPy3(self, message_module):
    m2 = message_module.TestAllTypes()
    m2.optional_string = &#39;scalar string&#39;
    m2.repeated_string.append(&#39;repeated string&#39;)
    m2.optional_bytes = b&#39;scalar bytes&#39;
    m2.repeated_bytes.append(b&#39;repeated bytes&#39;)

    serialized = m2.SerializeToString()
    memview = memoryview(serialized)
    m1 = message_module.TestAllTypes.FromString(memview)

    self.assertEqual(m1.optional_bytes, b&#39;scalar bytes&#39;)
    self.assertEqual(m1.repeated_bytes, [b&#39;repeated bytes&#39;])
    self.assertEqual(m1.optional_string, &#39;scalar string&#39;)
    self.assertEqual(m1.repeated_string, [&#39;repeated string&#39;])
    # Make sure that the memoryview was correctly converted to bytes, and
    # that a sub-sliced memoryview is not being used.
    self.assertIsInstance(m1.optional_bytes, bytes)
    self.assertIsInstance(m1.repeated_bytes[0], bytes)
    self.assertIsInstance(m1.optional_string, six.text_type)
    self.assertIsInstance(m1.repeated_string[0], six.text_type)

  @unittest.skipIf(six.PY3, &#39;memoryview is supported by py3&#39;)
  def testMergeFromStringUsingMemoryViewIsPy2Error(self, message_module):
    memview = memoryview(b&#39;&#39;)
    with self.assertRaises(TypeError):
      message_module.TestAllTypes.FromString(memview)

  def testMergeFromEmpty(self, message_module):
    m1 = message_module.TestAllTypes()
    # Cpp extension will lazily create a sub message which is immutable.
    self.assertEqual(0, m1.optional_nested_message.bb)
    self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))
    # Make sure the sub message is still immutable after merge from empty.
    m1.MergeFromString(b&#39;&#39;)  # field state should not change
    self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))

  def ensureNestedMessageExists(self, msg, attribute):
    &#34;&#34;&#34;Make sure that a nested message object exists.

    As soon as a nested message attribute is accessed, it will be present in the
    _fields dict, without being marked as actually being set.
    &#34;&#34;&#34;
    getattr(msg, attribute)
    self.assertFalse(msg.HasField(attribute))

  def testOneofGetCaseNonexistingField(self, message_module):
    m = message_module.TestAllTypes()
    self.assertRaises(ValueError, m.WhichOneof, &#39;no_such_oneof_field&#39;)
    self.assertRaises(Exception, m.WhichOneof, 0)

  def testOneofDefaultValues(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))

    # Oneof is set even when setting it to a default value.
    m.oneof_uint32 = 0
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
    self.assertFalse(m.HasField(&#39;oneof_string&#39;))

    m.oneof_string = &#34;&#34;
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))

  def testOneofSemantics(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

    m.oneof_uint32 = 11
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))

    m.oneof_string = u&#39;foo&#39;
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))

    # Read nested message accessor without accessing submessage.
    m.oneof_nested_message
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))
    self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

    # Read accessor of nested message without accessing submessage.
    m.oneof_nested_message.bb
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))
    self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

    m.oneof_nested_message.bb = 11
    self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_string&#39;))
    self.assertTrue(m.HasField(&#39;oneof_nested_message&#39;))

    m.oneof_bytes = b&#39;bb&#39;
    self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))
    self.assertTrue(m.HasField(&#39;oneof_bytes&#39;))

  def testOneofCompositeFieldReadAccess(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11

    self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertEqual(11, m.oneof_uint32)

  def testOneofWhichOneof(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))

    m.oneof_uint32 = 11
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    if message_module is unittest_pb2:
      self.assertTrue(m.HasField(&#39;oneof_field&#39;))

    m.oneof_bytes = b&#39;bb&#39;
    self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))

    m.ClearField(&#39;oneof_bytes&#39;)
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))

  def testOneofClearField(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m.ClearField(&#39;oneof_field&#39;)
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofClearSetField(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m.ClearField(&#39;oneof_uint32&#39;)
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofClearUnsetField(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
    m.ClearField(&#39;oneof_nested_message&#39;)
    self.assertEqual(11, m.oneof_uint32)
    if message_module is unittest_pb2:
      self.assertTrue(m.HasField(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofDeserialize(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m2 = message_module.TestAllTypes()
    m2.ParseFromString(m.SerializeToString())
    self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))

  def testOneofCopyFrom(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m2 = message_module.TestAllTypes()
    m2.CopyFrom(m)
    self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))

  def testOneofNestedMergeFrom(self, message_module):
    m = message_module.NestedTestAllTypes()
    m.payload.oneof_uint32 = 11
    m2 = message_module.NestedTestAllTypes()
    m2.payload.oneof_bytes = b&#39;bb&#39;
    m2.child.payload.oneof_bytes = b&#39;bb&#39;
    m2.MergeFrom(m)
    self.assertEqual(&#39;oneof_uint32&#39;, m2.payload.WhichOneof(&#39;oneof_field&#39;))
    self.assertEqual(&#39;oneof_bytes&#39;, m2.child.payload.WhichOneof(&#39;oneof_field&#39;))

  def testOneofMessageMergeFrom(self, message_module):
    m = message_module.NestedTestAllTypes()
    m.payload.oneof_nested_message.bb = 11
    m.child.payload.oneof_nested_message.bb = 12
    m2 = message_module.NestedTestAllTypes()
    m2.payload.oneof_uint32 = 13
    m2.MergeFrom(m)
    self.assertEqual(&#39;oneof_nested_message&#39;,
                     m2.payload.WhichOneof(&#39;oneof_field&#39;))
    self.assertEqual(&#39;oneof_nested_message&#39;,
                     m2.child.payload.WhichOneof(&#39;oneof_field&#39;))

  def testOneofNestedMessageInit(self, message_module):
    m = message_module.TestAllTypes(
        oneof_nested_message=message_module.TestAllTypes.NestedMessage())
    self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofClear(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m.Clear()
    self.assertIsNone(m.WhichOneof(&#39;oneof_field&#39;))
    m.oneof_bytes = b&#39;bb&#39;
    self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  def testAssignByteStringToUnicodeField(self, message_module):
    &#34;&#34;&#34;Assigning a byte string to a string field should result
    in the value being converted to a Unicode string.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    m.optional_string = str(&#39;&#39;)
    self.assertIsInstance(m.optional_string, six.text_type)

  def testLongValuedSlice(self, message_module):
    &#34;&#34;&#34;It should be possible to use long-valued indicies in slices

    This didn&#39;t used to work in the v2 C++ implementation.
    &#34;&#34;&#34;
    m = message_module.TestAllTypes()

    # Repeated scalar
    m.repeated_int32.append(1)
    sl = m.repeated_int32[long(0):long(len(m.repeated_int32))]
    self.assertEqual(len(m.repeated_int32), len(sl))

    # Repeated composite
    m.repeated_nested_message.add().bb = 3
    sl = m.repeated_nested_message[long(0):long(len(m.repeated_nested_message))]
    self.assertEqual(len(m.repeated_nested_message), len(sl))

  def testExtendShouldNotSwallowExceptions(self, message_module):
    &#34;&#34;&#34;This didn&#39;t use to work in the v2 C++ implementation.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    with self.assertRaises(NameError) as _:
      m.repeated_int32.extend(a for i in range(10))  # pylint: disable=undefined-variable
    with self.assertRaises(NameError) as _:
      m.repeated_nested_enum.extend(
          a for i in range(10))  # pylint: disable=undefined-variable

  FALSY_VALUES = [None, False, 0, 0.0, b&#39;&#39;, u&#39;&#39;, bytearray(), [], {}, set()]

  def testExtendInt32WithNothing(self, message_module):
    &#34;&#34;&#34;Test no-ops extending repeated int32 fields.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_int32)

    # TODO(ptucker): Deprecate this behavior. b/18413862
    for falsy_value in MessageTest.FALSY_VALUES:
      m.repeated_int32.extend(falsy_value)
      self.assertSequenceEqual([], m.repeated_int32)

    m.repeated_int32.extend([])
    self.assertSequenceEqual([], m.repeated_int32)

  def testExtendFloatWithNothing(self, message_module):
    &#34;&#34;&#34;Test no-ops extending repeated float fields.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_float)

    # TODO(ptucker): Deprecate this behavior. b/18413862
    for falsy_value in MessageTest.FALSY_VALUES:
      m.repeated_float.extend(falsy_value)
      self.assertSequenceEqual([], m.repeated_float)

    m.repeated_float.extend([])
    self.assertSequenceEqual([], m.repeated_float)

  def testExtendStringWithNothing(self, message_module):
    &#34;&#34;&#34;Test no-ops extending repeated string fields.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)

    # TODO(ptucker): Deprecate this behavior. b/18413862
    for falsy_value in MessageTest.FALSY_VALUES:
      m.repeated_string.extend(falsy_value)
      self.assertSequenceEqual([], m.repeated_string)

    m.repeated_string.extend([])
    self.assertSequenceEqual([], m.repeated_string)

  def testExtendInt32WithPythonList(self, message_module):
    &#34;&#34;&#34;Test extending repeated int32 fields with python lists.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_int32)
    m.repeated_int32.extend([0])
    self.assertSequenceEqual([0], m.repeated_int32)
    m.repeated_int32.extend([1, 2])
    self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
    m.repeated_int32.extend([3, 4])
    self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)

  def testExtendFloatWithPythonList(self, message_module):
    &#34;&#34;&#34;Test extending repeated float fields with python lists.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_float)
    m.repeated_float.extend([0.0])
    self.assertSequenceEqual([0.0], m.repeated_float)
    m.repeated_float.extend([1.0, 2.0])
    self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
    m.repeated_float.extend([3.0, 4.0])
    self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)

  def testExtendStringWithPythonList(self, message_module):
    &#34;&#34;&#34;Test extending repeated string fields with python lists.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend([&#39;&#39;])
    self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
    m.repeated_string.extend([&#39;11&#39;, &#39;22&#39;])
    self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;], m.repeated_string)
    m.repeated_string.extend([&#39;33&#39;, &#39;44&#39;])
    self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;, &#39;33&#39;, &#39;44&#39;], m.repeated_string)

  def testExtendStringWithString(self, message_module):
    &#34;&#34;&#34;Test extending repeated string fields with characters from a string.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend(&#39;abc&#39;)
    self.assertSequenceEqual([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], m.repeated_string)

  class TestIterable(object):
    &#34;&#34;&#34;This iterable object mimics the behavior of numpy.array.

    __nonzero__ fails for length &gt; 1, and returns bool(item[0]) for length == 1.

    &#34;&#34;&#34;

    def __init__(self, values=None):
      self._list = values or []

    def __nonzero__(self):
      size = len(self._list)
      if size == 0:
        return False
      if size == 1:
        return bool(self._list[0])
      raise ValueError(&#39;Truth value is ambiguous.&#39;)

    def __len__(self):
      return len(self._list)

    def __iter__(self):
      return self._list.__iter__()

  def testExtendInt32WithIterable(self, message_module):
    &#34;&#34;&#34;Test extending repeated int32 fields with iterable.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([]))
    self.assertSequenceEqual([], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([0]))
    self.assertSequenceEqual([0], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([1, 2]))
    self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([3, 4]))
    self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)

  def testExtendFloatWithIterable(self, message_module):
    &#34;&#34;&#34;Test extending repeated float fields with iterable.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([]))
    self.assertSequenceEqual([], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([0.0]))
    self.assertSequenceEqual([0.0], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([1.0, 2.0]))
    self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([3.0, 4.0]))
    self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)

  def testExtendStringWithIterable(self, message_module):
    &#34;&#34;&#34;Test extending repeated string fields with iterable.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([]))
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([&#39;&#39;]))
    self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([&#39;1&#39;, &#39;2&#39;]))
    self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([&#39;3&#39;, &#39;4&#39;]))
    self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;], m.repeated_string)

  def testPickleRepeatedScalarContainer(self, message_module):
    # TODO(tibell): The pure-Python implementation support pickling of
    #   scalar containers in *some* cases. For now the cpp2 version
    #   throws an exception to avoid a segfault. Investigate if we
    #   want to support pickling of these fields.
    #
    # For more information see: https://b2.corp.google.com/u/0/issues/18677897
    if (api_implementation.Type() != &#39;cpp&#39; or
        api_implementation.Version() == 2):
      return
    m = message_module.TestAllTypes()
    with self.assertRaises(pickle.PickleError) as _:
      pickle.dumps(m.repeated_int32, pickle.HIGHEST_PROTOCOL)

  def testSortEmptyRepeatedCompositeContainer(self, message_module):
    &#34;&#34;&#34;Exercise a scenario that has led to segfaults in the past.
    &#34;&#34;&#34;
    m = message_module.TestAllTypes()
    m.repeated_nested_message.sort()

  def testHasFieldOnRepeatedField(self, message_module):
    &#34;&#34;&#34;Using HasField on a repeated field should raise an exception.
    &#34;&#34;&#34;
    m = message_module.TestAllTypes()
    with self.assertRaises(ValueError) as _:
      m.HasField(&#39;repeated_int32&#39;)

  def testRepeatedScalarFieldPop(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(IndexError) as _:
      m.repeated_int32.pop()
    m.repeated_int32.extend(range(5))
    self.assertEqual(4, m.repeated_int32.pop())
    self.assertEqual(0, m.repeated_int32.pop(0))
    self.assertEqual(2, m.repeated_int32.pop(1))
    self.assertEqual([1, 3], m.repeated_int32)

  def testRepeatedCompositeFieldPop(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(IndexError) as _:
      m.repeated_nested_message.pop()
    with self.assertRaises(TypeError) as _:
      m.repeated_nested_message.pop(&#39;0&#39;)
    for i in range(5):
      n = m.repeated_nested_message.add()
      n.bb = i
    self.assertEqual(4, m.repeated_nested_message.pop().bb)
    self.assertEqual(0, m.repeated_nested_message.pop(0).bb)
    self.assertEqual(2, m.repeated_nested_message.pop(1).bb)
    self.assertEqual([1, 3], [n.bb for n in m.repeated_nested_message])

  def testRepeatedCompareWithSelf(self, message_module):
    m = message_module.TestAllTypes()
    for i in range(5):
      m.repeated_int32.insert(i, i)
      n = m.repeated_nested_message.add()
      n.bb = i
    self.assertSequenceEqual(m.repeated_int32, m.repeated_int32)
    self.assertEqual(m.repeated_nested_message, m.repeated_nested_message)

  def testReleasedNestedMessages(self, message_module):
    &#34;&#34;&#34;A case that lead to a segfault when a message detached from its parent
    container has itself a child container.
    &#34;&#34;&#34;
    m = message_module.NestedTestAllTypes()
    m = m.repeated_child.add()
    m = m.child
    m = m.repeated_child.add()
    self.assertEqual(m.payload.optional_int32, 0)

  def testSetRepeatedComposite(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(AttributeError):
      m.repeated_int32 = []
    m.repeated_int32.append(1)
    with self.assertRaises(AttributeError):
      m.repeated_int32 = []

  def testReturningType(self, message_module):
    m = message_module.TestAllTypes()
    self.assertEqual(float, type(m.optional_float))
    self.assertEqual(float, type(m.optional_double))
    self.assertEqual(bool, type(m.optional_bool))
    m.optional_float = 1
    m.optional_double = 1
    m.optional_bool = 1
    m.repeated_float.append(1)
    m.repeated_double.append(1)
    m.repeated_bool.append(1)
    m.ParseFromString(m.SerializeToString())
    self.assertEqual(float, type(m.optional_float))
    self.assertEqual(float, type(m.optional_double))
    self.assertEqual(&#39;1.0&#39;, str(m.optional_double))
    self.assertEqual(bool, type(m.optional_bool))
    self.assertEqual(float, type(m.repeated_float[0]))
    self.assertEqual(float, type(m.repeated_double[0]))
    self.assertEqual(bool, type(m.repeated_bool[0]))
    self.assertEqual(True, m.repeated_bool[0])


# Class to test proto2-only features (required, extensions, etc.)
@testing_refleaks.TestCase
class Proto2Test(unittest.TestCase):

  def testFieldPresence(self):
    message = unittest_pb2.TestAllTypes()

    self.assertFalse(message.HasField(&#34;optional_int32&#34;))
    self.assertFalse(message.HasField(&#34;optional_bool&#34;))
    self.assertFalse(message.HasField(&#34;optional_nested_message&#34;))

    with self.assertRaises(ValueError):
      message.HasField(&#34;field_doesnt_exist&#34;)

    with self.assertRaises(ValueError):
      message.HasField(&#34;repeated_int32&#34;)
    with self.assertRaises(ValueError):
      message.HasField(&#34;repeated_nested_message&#34;)

    self.assertEqual(0, message.optional_int32)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

    # Fields are set even when setting the values to default values.
    message.optional_int32 = 0
    message.optional_bool = False
    message.optional_nested_message.bb = 0
    self.assertTrue(message.HasField(&#34;optional_int32&#34;))
    self.assertTrue(message.HasField(&#34;optional_bool&#34;))
    self.assertTrue(message.HasField(&#34;optional_nested_message&#34;))

    # Set the fields to non-default values.
    message.optional_int32 = 5
    message.optional_bool = True
    message.optional_nested_message.bb = 15

    self.assertTrue(message.HasField(u&#34;optional_int32&#34;))
    self.assertTrue(message.HasField(&#34;optional_bool&#34;))
    self.assertTrue(message.HasField(&#34;optional_nested_message&#34;))

    # Clearing the fields unsets them and resets their value to default.
    message.ClearField(&#34;optional_int32&#34;)
    message.ClearField(u&#34;optional_bool&#34;)
    message.ClearField(&#34;optional_nested_message&#34;)

    self.assertFalse(message.HasField(&#34;optional_int32&#34;))
    self.assertFalse(message.HasField(&#34;optional_bool&#34;))
    self.assertFalse(message.HasField(&#34;optional_nested_message&#34;))
    self.assertEqual(0, message.optional_int32)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

  def testAssignInvalidEnum(self):
    &#34;&#34;&#34;Assigning an invalid enum number is not allowed in proto2.&#34;&#34;&#34;
    m = unittest_pb2.TestAllTypes()

    # Proto2 can not assign unknown enum.
    with self.assertRaises(ValueError) as _:
      m.optional_nested_enum = 1234567
    self.assertRaises(ValueError, m.repeated_nested_enum.append, 1234567)
    # Assignment is a different code path than append for the C++ impl.
    m.repeated_nested_enum.append(2)
    m.repeated_nested_enum[0] = 2
    with self.assertRaises(ValueError):
      m.repeated_nested_enum[0] = 123456

    # Unknown enum value can be parsed but is ignored.
    m2 = unittest_proto3_arena_pb2.TestAllTypes()
    m2.optional_nested_enum = 1234567
    m2.repeated_nested_enum.append(7654321)
    serialized = m2.SerializeToString()

    m3 = unittest_pb2.TestAllTypes()
    m3.ParseFromString(serialized)
    self.assertFalse(m3.HasField(&#39;optional_nested_enum&#39;))
    # 1 is the default value for optional_nested_enum.
    self.assertEqual(1, m3.optional_nested_enum)
    self.assertEqual(0, len(m3.repeated_nested_enum))
    m2.Clear()
    m2.ParseFromString(m3.SerializeToString())
    self.assertEqual(1234567, m2.optional_nested_enum)
    self.assertEqual(7654321, m2.repeated_nested_enum[0])

  def testUnknownEnumMap(self):
    m = map_proto2_unittest_pb2.TestEnumMap()
    m.known_map_field[123] = 0
    with self.assertRaises(ValueError):
      m.unknown_map_field[1] = 123

  def testExtensionsErrors(self):
    msg = unittest_pb2.TestAllTypes()
    self.assertRaises(AttributeError, getattr, msg, &#39;Extensions&#39;)

  def testMergeFromExtensions(self):
    msg1 = more_extensions_pb2.TopLevelMessage()
    msg2 = more_extensions_pb2.TopLevelMessage()
    # Cpp extension will lazily create a sub message which is immutable.
    self.assertEqual(0, msg1.submessage.Extensions[
        more_extensions_pb2.optional_int_extension])
    self.assertFalse(msg1.HasField(&#39;submessage&#39;))
    msg2.submessage.Extensions[
        more_extensions_pb2.optional_int_extension] = 123
    # Make sure cmessage and extensions pointing to a mutable message
    # after merge instead of the lazily created message.
    msg1.MergeFrom(msg2)
    self.assertEqual(123, msg1.submessage.Extensions[
        more_extensions_pb2.optional_int_extension])

  def testGoldenExtensions(self):
    golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
    golden_message = unittest_pb2.TestAllExtensions()
    golden_message.ParseFromString(golden_data)
    all_set = unittest_pb2.TestAllExtensions()
    test_util.SetAllExtensions(all_set)
    self.assertEqual(all_set, golden_message)
    self.assertEqual(golden_data, golden_message.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testGoldenPackedExtensions(self):
    golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
    golden_message = unittest_pb2.TestPackedExtensions()
    golden_message.ParseFromString(golden_data)
    all_set = unittest_pb2.TestPackedExtensions()
    test_util.SetAllPackedExtensions(all_set)
    self.assertEqual(all_set, golden_message)
    self.assertEqual(golden_data, all_set.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testPickleIncompleteProto(self):
    golden_message = unittest_pb2.TestRequired(a=1)
    pickled_message = pickle.dumps(golden_message)

    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)
    self.assertEqual(unpickled_message.a, 1)
    # This is still an incomplete proto - so serializing should fail
    self.assertRaises(message.EncodeError, unpickled_message.SerializeToString)


  # TODO(haberman): this isn&#39;t really a proto2-specific test except that this
  # message has a required field in it.  Should probably be factored out so
  # that we can test the other parts with proto3.
  def testParsingMerge(self):
    &#34;&#34;&#34;Check the merge behavior when a required or optional field appears
    multiple times in the input.&#34;&#34;&#34;
    messages = [
        unittest_pb2.TestAllTypes(),
        unittest_pb2.TestAllTypes(),
        unittest_pb2.TestAllTypes() ]
    messages[0].optional_int32 = 1
    messages[1].optional_int64 = 2
    messages[2].optional_int32 = 3
    messages[2].optional_string = &#39;hello&#39;

    merged_message = unittest_pb2.TestAllTypes()
    merged_message.optional_int32 = 3
    merged_message.optional_int64 = 2
    merged_message.optional_string = &#39;hello&#39;

    generator = unittest_pb2.TestParsingMerge.RepeatedFieldsGenerator()
    generator.field1.extend(messages)
    generator.field2.extend(messages)
    generator.field3.extend(messages)
    generator.ext1.extend(messages)
    generator.ext2.extend(messages)
    generator.group1.add().field1.MergeFrom(messages[0])
    generator.group1.add().field1.MergeFrom(messages[1])
    generator.group1.add().field1.MergeFrom(messages[2])
    generator.group2.add().field1.MergeFrom(messages[0])
    generator.group2.add().field1.MergeFrom(messages[1])
    generator.group2.add().field1.MergeFrom(messages[2])

    data = generator.SerializeToString()
    parsing_merge = unittest_pb2.TestParsingMerge()
    parsing_merge.ParseFromString(data)

    # Required and optional fields should be merged.
    self.assertEqual(parsing_merge.required_all_types, merged_message)
    self.assertEqual(parsing_merge.optional_all_types, merged_message)
    self.assertEqual(parsing_merge.optionalgroup.optional_group_all_types,
                     merged_message)
    self.assertEqual(parsing_merge.Extensions[
                     unittest_pb2.TestParsingMerge.optional_ext],
                     merged_message)

    # Repeated fields should not be merged.
    self.assertEqual(len(parsing_merge.repeated_all_types), 3)
    self.assertEqual(len(parsing_merge.repeatedgroup), 3)
    self.assertEqual(len(parsing_merge.Extensions[
        unittest_pb2.TestParsingMerge.repeated_ext]), 3)

  def testPythonicInit(self):
    message = unittest_pb2.TestAllTypes(
        optional_int32=100,
        optional_fixed32=200,
        optional_float=300.5,
        optional_bytes=b&#39;x&#39;,
        optionalgroup={&#39;a&#39;: 400},
        optional_nested_message={&#39;bb&#39;: 500},
        optional_foreign_message={},
        optional_nested_enum=&#39;BAZ&#39;,
        repeatedgroup=[{&#39;a&#39;: 600},
                       {&#39;a&#39;: 700}],
        repeated_nested_enum=[&#39;FOO&#39;, unittest_pb2.TestAllTypes.BAR],
        default_int32=800,
        oneof_string=&#39;y&#39;)
    self.assertIsInstance(message, unittest_pb2.TestAllTypes)
    self.assertEqual(100, message.optional_int32)
    self.assertEqual(200, message.optional_fixed32)
    self.assertEqual(300.5, message.optional_float)
    self.assertEqual(b&#39;x&#39;, message.optional_bytes)
    self.assertEqual(400, message.optionalgroup.a)
    self.assertIsInstance(message.optional_nested_message,
                          unittest_pb2.TestAllTypes.NestedMessage)
    self.assertEqual(500, message.optional_nested_message.bb)
    self.assertTrue(message.HasField(&#39;optional_foreign_message&#39;))
    self.assertEqual(message.optional_foreign_message,
                     unittest_pb2.ForeignMessage())
    self.assertEqual(unittest_pb2.TestAllTypes.BAZ,
                     message.optional_nested_enum)
    self.assertEqual(2, len(message.repeatedgroup))
    self.assertEqual(600, message.repeatedgroup[0].a)
    self.assertEqual(700, message.repeatedgroup[1].a)
    self.assertEqual(2, len(message.repeated_nested_enum))
    self.assertEqual(unittest_pb2.TestAllTypes.FOO,
                     message.repeated_nested_enum[0])
    self.assertEqual(unittest_pb2.TestAllTypes.BAR,
                     message.repeated_nested_enum[1])
    self.assertEqual(800, message.default_int32)
    self.assertEqual(&#39;y&#39;, message.oneof_string)
    self.assertFalse(message.HasField(&#39;optional_int64&#39;))
    self.assertEqual(0, len(message.repeated_float))
    self.assertEqual(42, message.default_int64)

    message = unittest_pb2.TestAllTypes(optional_nested_enum=u&#39;BAZ&#39;)
    self.assertEqual(unittest_pb2.TestAllTypes.BAZ,
                     message.optional_nested_enum)

    with self.assertRaises(ValueError):
      unittest_pb2.TestAllTypes(
          optional_nested_message={&#39;INVALID_NESTED_FIELD&#39;: 17})

    with self.assertRaises(TypeError):
      unittest_pb2.TestAllTypes(
          optional_nested_message={&#39;bb&#39;: &#39;INVALID_VALUE_TYPE&#39;})

    with self.assertRaises(ValueError):
      unittest_pb2.TestAllTypes(optional_nested_enum=&#39;INVALID_LABEL&#39;)

    with self.assertRaises(ValueError):
      unittest_pb2.TestAllTypes(repeated_nested_enum=&#39;FOO&#39;)

  def testPythonicInitWithDict(self):
    # Both string/unicode field name keys should work.
    kwargs = {
        &#39;optional_int32&#39;: 100,
        u&#39;optional_fixed32&#39;: 200,
    }
    msg = unittest_pb2.TestAllTypes(**kwargs)
    self.assertEqual(100, msg.optional_int32)
    self.assertEqual(200, msg.optional_fixed32)


  def test_documentation(self):
    # Also used by the interactive help() function.
    doc = pydoc.html.document(unittest_pb2.TestAllTypes, &#39;message&#39;)
    self.assertIn(&#39;class TestAllTypes&#39;, doc)
    self.assertIn(&#39;SerializePartialToString&#39;, doc)
    self.assertIn(&#39;repeated_float&#39;, doc)
    base = unittest_pb2.TestAllTypes.__bases__[0]
    self.assertRaises(AttributeError, getattr, base, &#39;_extensions_by_name&#39;)


# Class to test proto3-only features/behavior (updated field presence &amp; enums)
@testing_refleaks.TestCase
class Proto3Test(unittest.TestCase):

  # Utility method for comparing equality with a map.
  def assertMapIterEquals(self, map_iter, dict_value):
    # Avoid mutating caller&#39;s copy.
    dict_value = dict(dict_value)

    for k, v in map_iter:
      self.assertEqual(v, dict_value[k])
      del dict_value[k]

    self.assertEqual({}, dict_value)

  def testFieldPresence(self):
    message = unittest_proto3_arena_pb2.TestAllTypes()

    # We can&#39;t test presence of non-repeated, non-submessage fields.
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_int32&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_float&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_string&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_bool&#39;)

    # But we can still test presence of submessage fields.
    self.assertFalse(message.HasField(&#39;optional_nested_message&#39;))

    # As with proto2, we can&#39;t test presence of fields that don&#39;t exist, or
    # repeated fields.
    with self.assertRaises(ValueError):
      message.HasField(&#39;field_doesnt_exist&#39;)

    with self.assertRaises(ValueError):
      message.HasField(&#39;repeated_int32&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;repeated_nested_message&#39;)

    # Fields should default to their type-specific default.
    self.assertEqual(0, message.optional_int32)
    self.assertEqual(0, message.optional_float)
    self.assertEqual(&#39;&#39;, message.optional_string)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

    # Setting a submessage should still return proper presence information.
    message.optional_nested_message.bb = 0
    self.assertTrue(message.HasField(&#39;optional_nested_message&#39;))

    # Set the fields to non-default values.
    message.optional_int32 = 5
    message.optional_float = 1.1
    message.optional_string = &#39;abc&#39;
    message.optional_bool = True
    message.optional_nested_message.bb = 15

    # Clearing the fields unsets them and resets their value to default.
    message.ClearField(&#39;optional_int32&#39;)
    message.ClearField(&#39;optional_float&#39;)
    message.ClearField(&#39;optional_string&#39;)
    message.ClearField(&#39;optional_bool&#39;)
    message.ClearField(&#39;optional_nested_message&#39;)

    self.assertEqual(0, message.optional_int32)
    self.assertEqual(0, message.optional_float)
    self.assertEqual(&#39;&#39;, message.optional_string)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

  def testAssignUnknownEnum(self):
    &#34;&#34;&#34;Assigning an unknown enum value is allowed and preserves the value.&#34;&#34;&#34;
    m = unittest_proto3_arena_pb2.TestAllTypes()

    # Proto3 can assign unknown enums.
    m.optional_nested_enum = 1234567
    self.assertEqual(1234567, m.optional_nested_enum)
    m.repeated_nested_enum.append(22334455)
    self.assertEqual(22334455, m.repeated_nested_enum[0])
    # Assignment is a different code path than append for the C++ impl.
    m.repeated_nested_enum[0] = 7654321
    self.assertEqual(7654321, m.repeated_nested_enum[0])
    serialized = m.SerializeToString()

    m2 = unittest_proto3_arena_pb2.TestAllTypes()
    m2.ParseFromString(serialized)
    self.assertEqual(1234567, m2.optional_nested_enum)
    self.assertEqual(7654321, m2.repeated_nested_enum[0])

  # Map isn&#39;t really a proto3-only feature. But there is no proto2 equivalent
  # of google/protobuf/map_unittest.proto right now, so it&#39;s not easy to
  # test both with the same test like we do for the other proto2/proto3 tests.
  # (google/protobuf/map_proto2_unittest.proto is very different in the set
  # of messages and fields it contains).
  def testScalarMapDefaults(self):
    msg = map_unittest_pb2.TestMap()

    # Scalars start out unset.
    self.assertFalse(-123 in msg.map_int32_int32)
    self.assertFalse(-2**33 in msg.map_int64_int64)
    self.assertFalse(123 in msg.map_uint32_uint32)
    self.assertFalse(2**33 in msg.map_uint64_uint64)
    self.assertFalse(123 in msg.map_int32_double)
    self.assertFalse(False in msg.map_bool_bool)
    self.assertFalse(&#39;abc&#39; in msg.map_string_string)
    self.assertFalse(111 in msg.map_int32_bytes)
    self.assertFalse(888 in msg.map_int32_enum)

    # Accessing an unset key returns the default.
    self.assertEqual(0, msg.map_int32_int32[-123])
    self.assertEqual(0, msg.map_int64_int64[-2**33])
    self.assertEqual(0, msg.map_uint32_uint32[123])
    self.assertEqual(0, msg.map_uint64_uint64[2**33])
    self.assertEqual(0.0, msg.map_int32_double[123])
    self.assertTrue(isinstance(msg.map_int32_double[123], float))
    self.assertEqual(False, msg.map_bool_bool[False])
    self.assertTrue(isinstance(msg.map_bool_bool[False], bool))
    self.assertEqual(&#39;&#39;, msg.map_string_string[&#39;abc&#39;])
    self.assertEqual(b&#39;&#39;, msg.map_int32_bytes[111])
    self.assertEqual(0, msg.map_int32_enum[888])

    # It also sets the value in the map
    self.assertTrue(-123 in msg.map_int32_int32)
    self.assertTrue(-2**33 in msg.map_int64_int64)
    self.assertTrue(123 in msg.map_uint32_uint32)
    self.assertTrue(2**33 in msg.map_uint64_uint64)
    self.assertTrue(123 in msg.map_int32_double)
    self.assertTrue(False in msg.map_bool_bool)
    self.assertTrue(&#39;abc&#39; in msg.map_string_string)
    self.assertTrue(111 in msg.map_int32_bytes)
    self.assertTrue(888 in msg.map_int32_enum)

    self.assertIsInstance(msg.map_string_string[&#39;abc&#39;], six.text_type)

    # Accessing an unset key still throws TypeError if the type of the key
    # is incorrect.
    with self.assertRaises(TypeError):
      msg.map_string_string[123]

    with self.assertRaises(TypeError):
      123 in msg.map_string_string

  def testMapGet(self):
    # Need to test that get() properly returns the default, even though the dict
    # has defaultdict-like semantics.
    msg = map_unittest_pb2.TestMap()

    self.assertIsNone(msg.map_int32_int32.get(5))
    self.assertEqual(10, msg.map_int32_int32.get(5, 10))
    self.assertEqual(10, msg.map_int32_int32.get(key=5, default=10))
    self.assertIsNone(msg.map_int32_int32.get(5))

    msg.map_int32_int32[5] = 15
    self.assertEqual(15, msg.map_int32_int32.get(5))
    self.assertEqual(15, msg.map_int32_int32.get(5))
    with self.assertRaises(TypeError):
      msg.map_int32_int32.get(&#39;&#39;)

    self.assertIsNone(msg.map_int32_foreign_message.get(5))
    self.assertEqual(10, msg.map_int32_foreign_message.get(5, 10))
    self.assertEqual(10, msg.map_int32_foreign_message.get(key=5, default=10))

    submsg = msg.map_int32_foreign_message[5]
    self.assertIs(submsg, msg.map_int32_foreign_message.get(5))
    with self.assertRaises(TypeError):
      msg.map_int32_foreign_message.get(&#39;&#39;)

  def testScalarMap(self):
    msg = map_unittest_pb2.TestMap()

    self.assertEqual(0, len(msg.map_int32_int32))
    self.assertFalse(5 in msg.map_int32_int32)

    msg.map_int32_int32[-123] = -456
    msg.map_int64_int64[-2**33] = -2**34
    msg.map_uint32_uint32[123] = 456
    msg.map_uint64_uint64[2**33] = 2**34
    msg.map_int32_float[2] = 1.2
    msg.map_int32_double[1] = 3.3
    msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
    msg.map_bool_bool[True] = True
    msg.map_int32_enum[888] = 2
    # Unknown numeric enum is supported in proto3.
    msg.map_int32_enum[123] = 456

    self.assertEqual([], msg.FindInitializationErrors())

    self.assertEqual(1, len(msg.map_string_string))

    # Bad key.
    with self.assertRaises(TypeError):
      msg.map_string_string[123] = &#39;123&#39;

    # Verify that trying to assign a bad key doesn&#39;t actually add a member to
    # the map.
    self.assertEqual(1, len(msg.map_string_string))

    # Bad value.
    with self.assertRaises(TypeError):
      msg.map_string_string[&#39;123&#39;] = 123

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    # Bad key.
    with self.assertRaises(TypeError):
      msg2.map_string_string[123] = &#39;123&#39;

    # Bad value.
    with self.assertRaises(TypeError):
      msg2.map_string_string[&#39;123&#39;] = 123

    self.assertEqual(-456, msg2.map_int32_int32[-123])
    self.assertEqual(-2**34, msg2.map_int64_int64[-2**33])
    self.assertEqual(456, msg2.map_uint32_uint32[123])
    self.assertEqual(2**34, msg2.map_uint64_uint64[2**33])
    self.assertAlmostEqual(1.2, msg.map_int32_float[2])
    self.assertEqual(3.3, msg.map_int32_double[1])
    self.assertEqual(&#39;123&#39;, msg2.map_string_string[&#39;abc&#39;])
    self.assertEqual(True, msg2.map_bool_bool[True])
    self.assertEqual(2, msg2.map_int32_enum[888])
    self.assertEqual(456, msg2.map_int32_enum[123])
    self.assertEqual(&#39;{-123: -456}&#39;,
                     str(msg2.map_int32_int32))

  def testMapEntryAlwaysSerialized(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[0] = 0
    msg.map_string_string[&#39;&#39;] = &#39;&#39;
    self.assertEqual(msg.ByteSize(), 12)
    self.assertEqual(b&#39;\n\x04\x08\x00\x10\x00r\x04\n\x00\x12\x00&#39;,
                     msg.SerializeToString())

  def testStringUnicodeConversionInMap(self):
    msg = map_unittest_pb2.TestMap()

    unicode_obj = u&#39;\u1234&#39;
    bytes_obj = unicode_obj.encode(&#39;utf8&#39;)

    msg.map_string_string[bytes_obj] = bytes_obj

    (key, value) = list(msg.map_string_string.items())[0]

    self.assertEqual(key, unicode_obj)
    self.assertEqual(value, unicode_obj)

    self.assertIsInstance(key, six.text_type)
    self.assertIsInstance(value, six.text_type)

  def testMessageMap(self):
    msg = map_unittest_pb2.TestMap()

    self.assertEqual(0, len(msg.map_int32_foreign_message))
    self.assertFalse(5 in msg.map_int32_foreign_message)

    msg.map_int32_foreign_message[123]
    # get_or_create() is an alias for getitem.
    msg.map_int32_foreign_message.get_or_create(-456)

    self.assertEqual(2, len(msg.map_int32_foreign_message))
    self.assertIn(123, msg.map_int32_foreign_message)
    self.assertIn(-456, msg.map_int32_foreign_message)
    self.assertEqual(2, len(msg.map_int32_foreign_message))

    # Bad key.
    with self.assertRaises(TypeError):
      msg.map_int32_foreign_message[&#39;123&#39;]

    # Can&#39;t assign directly to submessage.
    with self.assertRaises(ValueError):
      msg.map_int32_foreign_message[999] = msg.map_int32_foreign_message[123]

    # Verify that trying to assign a bad key doesn&#39;t actually add a member to
    # the map.
    self.assertEqual(2, len(msg.map_int32_foreign_message))

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    self.assertEqual(2, len(msg2.map_int32_foreign_message))
    self.assertIn(123, msg2.map_int32_foreign_message)
    self.assertIn(-456, msg2.map_int32_foreign_message)
    self.assertEqual(2, len(msg2.map_int32_foreign_message))
    msg2.map_int32_foreign_message[123].c = 1
    # TODO(jieluo): Fix text format for message map.
    self.assertIn(str(msg2.map_int32_foreign_message),
                  (&#39;{-456: , 123: c: 1\n}&#39;, &#39;{123: c: 1\n, -456: }&#39;))

  def testNestedMessageMapItemDelete(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_all_types[1].optional_nested_message.bb = 1
    del msg.map_int32_all_types[1]
    msg.map_int32_all_types[2].optional_nested_message.bb = 2
    self.assertEqual(1, len(msg.map_int32_all_types))
    msg.map_int32_all_types[1].optional_nested_message.bb = 1
    self.assertEqual(2, len(msg.map_int32_all_types))

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)
    keys = [1, 2]
    # The loop triggers PyErr_Occurred() in c extension.
    for key in keys:
      del msg2.map_int32_all_types[key]

  def testMapByteSize(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[1] = 1
    size = msg.ByteSize()
    msg.map_int32_int32[1] = 128
    self.assertEqual(msg.ByteSize(), size + 1)

    msg.map_int32_foreign_message[19].c = 1
    size = msg.ByteSize()
    msg.map_int32_foreign_message[19].c = 128
    self.assertEqual(msg.ByteSize(), size + 1)

  def testMergeFrom(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[12] = 34
    msg.map_int32_int32[56] = 78
    msg.map_int64_int64[22] = 33
    msg.map_int32_foreign_message[111].c = 5
    msg.map_int32_foreign_message[222].c = 10

    msg2 = map_unittest_pb2.TestMap()
    msg2.map_int32_int32[12] = 55
    msg2.map_int64_int64[88] = 99
    msg2.map_int32_foreign_message[222].c = 15
    msg2.map_int32_foreign_message[222].d = 20
    old_map_value = msg2.map_int32_foreign_message[222]

    msg2.MergeFrom(msg)
    # Compare with expected message instead of call
    # msg2.map_int32_foreign_message[222] to make sure MergeFrom does not
    # sync with repeated field and there is no duplicated keys.
    expected_msg = map_unittest_pb2.TestMap()
    expected_msg.CopyFrom(msg)
    expected_msg.map_int64_int64[88] = 99
    self.assertEqual(msg2, expected_msg)

    self.assertEqual(34, msg2.map_int32_int32[12])
    self.assertEqual(78, msg2.map_int32_int32[56])
    self.assertEqual(33, msg2.map_int64_int64[22])
    self.assertEqual(99, msg2.map_int64_int64[88])
    self.assertEqual(5, msg2.map_int32_foreign_message[111].c)
    self.assertEqual(10, msg2.map_int32_foreign_message[222].c)
    self.assertFalse(msg2.map_int32_foreign_message[222].HasField(&#39;d&#39;))
    if api_implementation.Type() != &#39;cpp&#39;:
      # During the call to MergeFrom(), the C++ implementation will have
      # deallocated the underlying message, but this is very difficult to detect
      # properly. The line below is likely to cause a segmentation fault.
      # With the Python implementation, old_map_value is just &#39;detached&#39; from
      # the main message. Using it will not crash of course, but since it still
      # have a reference to the parent message I&#39;m sure we can find interesting
      # ways to cause inconsistencies.
      self.assertEqual(15, old_map_value.c)

    # Verify that there is only one entry per key, even though the MergeFrom
    # may have internally created multiple entries for a single key in the
    # list representation.
    as_dict = {}
    for key in msg2.map_int32_foreign_message:
      self.assertFalse(key in as_dict)
      as_dict[key] = msg2.map_int32_foreign_message[key].c

    self.assertEqual({111: 5, 222: 10}, as_dict)

    # Special case: test that delete of item really removes the item, even if
    # there might have physically been duplicate keys due to the previous merge.
    # This is only a special case for the C++ implementation which stores the
    # map as an array.
    del msg2.map_int32_int32[12]
    self.assertFalse(12 in msg2.map_int32_int32)

    del msg2.map_int32_foreign_message[222]
    self.assertFalse(222 in msg2.map_int32_foreign_message)
    with self.assertRaises(TypeError):
      del msg2.map_int32_foreign_message[&#39;&#39;]

  def testMapMergeFrom(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[12] = 34
    msg.map_int32_int32[56] = 78
    msg.map_int64_int64[22] = 33
    msg.map_int32_foreign_message[111].c = 5
    msg.map_int32_foreign_message[222].c = 10

    msg2 = map_unittest_pb2.TestMap()
    msg2.map_int32_int32[12] = 55
    msg2.map_int64_int64[88] = 99
    msg2.map_int32_foreign_message[222].c = 15
    msg2.map_int32_foreign_message[222].d = 20

    msg2.map_int32_int32.MergeFrom(msg.map_int32_int32)
    self.assertEqual(34, msg2.map_int32_int32[12])
    self.assertEqual(78, msg2.map_int32_int32[56])

    msg2.map_int64_int64.MergeFrom(msg.map_int64_int64)
    self.assertEqual(33, msg2.map_int64_int64[22])
    self.assertEqual(99, msg2.map_int64_int64[88])

    msg2.map_int32_foreign_message.MergeFrom(msg.map_int32_foreign_message)
    # Compare with expected message instead of call
    # msg.map_int32_foreign_message[222] to make sure MergeFrom does not
    # sync with repeated field and no duplicated keys.
    expected_msg = map_unittest_pb2.TestMap()
    expected_msg.CopyFrom(msg)
    expected_msg.map_int64_int64[88] = 99
    self.assertEqual(msg2, expected_msg)

    # Test when cpp extension cache a map.
    m1 = map_unittest_pb2.TestMap()
    m2 = map_unittest_pb2.TestMap()
    self.assertEqual(m1.map_int32_foreign_message,
                     m1.map_int32_foreign_message)
    m2.map_int32_foreign_message[123].c = 10
    m1.MergeFrom(m2)
    self.assertEqual(10, m2.map_int32_foreign_message[123].c)

    # Test merge maps within different message types.
    m1 = map_unittest_pb2.TestMap()
    m2 = map_unittest_pb2.TestMessageMap()
    m2.map_int32_message[123].optional_int32 = 10
    m1.map_int32_all_types.MergeFrom(m2.map_int32_message)
    self.assertEqual(10, m1.map_int32_all_types[123].optional_int32)

    # Test overwrite message value map
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_foreign_message[222].c = 123
    msg2 = map_unittest_pb2.TestMap()
    msg2.map_int32_foreign_message[222].d = 20
    msg.MergeFromString(msg2.SerializeToString())
    self.assertEqual(msg.map_int32_foreign_message[222].d, 20)
    self.assertNotEqual(msg.map_int32_foreign_message[222].c, 123)

  def testMergeFromBadType(self):
    msg = map_unittest_pb2.TestMap()
    with self.assertRaisesRegexp(
        TypeError,
        r&#39;Parameter to MergeFrom\(\) must be instance of same class: expected &#39;
        r&#39;.*TestMap got int\.&#39;):
      msg.MergeFrom(1)

  def testCopyFromBadType(self):
    msg = map_unittest_pb2.TestMap()
    with self.assertRaisesRegexp(
        TypeError,
        r&#39;Parameter to [A-Za-z]*From\(\) must be instance of same class: &#39;
        r&#39;expected .*TestMap got int\.&#39;):
      msg.CopyFrom(1)

  def testIntegerMapWithLongs(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[long(-123)] = long(-456)
    msg.map_int64_int64[long(-2**33)] = long(-2**34)
    msg.map_uint32_uint32[long(123)] = long(456)
    msg.map_uint64_uint64[long(2**33)] = long(2**34)

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    self.assertEqual(-456, msg2.map_int32_int32[-123])
    self.assertEqual(-2**34, msg2.map_int64_int64[-2**33])
    self.assertEqual(456, msg2.map_uint32_uint32[123])
    self.assertEqual(2**34, msg2.map_uint64_uint64[2**33])

  def testMapAssignmentCausesPresence(self):
    msg = map_unittest_pb2.TestMapSubmessage()
    msg.test_map.map_int32_int32[123] = 456

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMapSubmessage()
    msg2.ParseFromString(serialized)

    self.assertEqual(msg, msg2)

    # Now test that various mutations of the map properly invalidate the
    # cached size of the submessage.
    msg.test_map.map_int32_int32[888] = 999
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

    msg.test_map.map_int32_int32.clear()
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

  def testMapAssignmentCausesPresenceForSubmessages(self):
    msg = map_unittest_pb2.TestMapSubmessage()
    msg.test_map.map_int32_foreign_message[123].c = 5

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMapSubmessage()
    msg2.ParseFromString(serialized)

    self.assertEqual(msg, msg2)

    # Now test that various mutations of the map properly invalidate the
    # cached size of the submessage.
    msg.test_map.map_int32_foreign_message[888].c = 7
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

    msg.test_map.map_int32_foreign_message[888].MergeFrom(
        msg.test_map.map_int32_foreign_message[123])
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

    msg.test_map.map_int32_foreign_message.clear()
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

  def testModifyMapWhileIterating(self):
    msg = map_unittest_pb2.TestMap()

    string_string_iter = iter(msg.map_string_string)
    int32_foreign_iter = iter(msg.map_int32_foreign_message)

    msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
    msg.map_int32_foreign_message[5].c = 5

    with self.assertRaises(RuntimeError):
      for key in string_string_iter:
        pass

    with self.assertRaises(RuntimeError):
      for key in int32_foreign_iter:
        pass

  def testSubmessageMap(self):
    msg = map_unittest_pb2.TestMap()

    submsg = msg.map_int32_foreign_message[111]
    self.assertIs(submsg, msg.map_int32_foreign_message[111])
    self.assertIsInstance(submsg, unittest_pb2.ForeignMessage)

    submsg.c = 5

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    self.assertEqual(5, msg2.map_int32_foreign_message[111].c)

    # Doesn&#39;t allow direct submessage assignment.
    with self.assertRaises(ValueError):
      msg.map_int32_foreign_message[88] = unittest_pb2.ForeignMessage()

  def testMapIteration(self):
    msg = map_unittest_pb2.TestMap()

    for k, v in msg.map_int32_int32.items():
      # Should not be reached.
      self.assertTrue(False)

    msg.map_int32_int32[2] = 4
    msg.map_int32_int32[3] = 6
    msg.map_int32_int32[4] = 8
    self.assertEqual(3, len(msg.map_int32_int32))

    matching_dict = {2: 4, 3: 6, 4: 8}
    self.assertMapIterEquals(msg.map_int32_int32.items(), matching_dict)

  def testPython2Map(self):
    if sys.version_info &lt; (3,):
      msg = map_unittest_pb2.TestMap()
      msg.map_int32_int32[2] = 4
      msg.map_int32_int32[3] = 6
      msg.map_int32_int32[4] = 8
      msg.map_int32_int32[5] = 10
      map_int32 = msg.map_int32_int32
      self.assertEqual(4, len(map_int32))
      msg2 = map_unittest_pb2.TestMap()
      msg2.ParseFromString(msg.SerializeToString())

      def CheckItems(seq, iterator):
        self.assertEqual(next(iterator), seq[0])
        self.assertEqual(list(iterator), seq[1:])

      CheckItems(map_int32.items(), map_int32.iteritems())
      CheckItems(map_int32.keys(), map_int32.iterkeys())
      CheckItems(map_int32.values(), map_int32.itervalues())

      self.assertEqual(6, map_int32.get(3))
      self.assertEqual(None, map_int32.get(999))
      self.assertEqual(6, map_int32.pop(3))
      self.assertEqual(0, map_int32.pop(3))
      self.assertEqual(3, len(map_int32))
      key, value = map_int32.popitem()
      self.assertEqual(2 * key, value)
      self.assertEqual(2, len(map_int32))
      map_int32.clear()
      self.assertEqual(0, len(map_int32))

      with self.assertRaises(KeyError):
        map_int32.popitem()

      self.assertEqual(0, map_int32.setdefault(2))
      self.assertEqual(1, len(map_int32))

      map_int32.update(msg2.map_int32_int32)
      self.assertEqual(4, len(map_int32))

      with self.assertRaises(TypeError):
        map_int32.update(msg2.map_int32_int32,
                         msg2.map_int32_int32)
      with self.assertRaises(TypeError):
        map_int32.update(0)
      with self.assertRaises(TypeError):
        map_int32.update(value=12)

  def testMapItems(self):
    # Map items used to have strange behaviors when use c extension. Because
    # [] may reorder the map and invalidate any exsting iterators.
    # TODO(jieluo): Check if [] reordering the map is a bug or intended
    # behavior.
    msg = map_unittest_pb2.TestMap()
    msg.map_string_string[&#39;local_init_op&#39;] = &#39;&#39;
    msg.map_string_string[&#39;trainable_variables&#39;] = &#39;&#39;
    msg.map_string_string[&#39;variables&#39;] = &#39;&#39;
    msg.map_string_string[&#39;init_op&#39;] = &#39;&#39;
    msg.map_string_string[&#39;summaries&#39;] = &#39;&#39;
    items1 = msg.map_string_string.items()
    items2 = msg.map_string_string.items()
    self.assertEqual(items1, items2)

  def testMapDeterministicSerialization(self):
    golden_data = (b&#39;r\x0c\n\x07init_op\x12\x01d&#39;
                   b&#39;r\n\n\x05item1\x12\x01e&#39;
                   b&#39;r\n\n\x05item2\x12\x01f&#39;
                   b&#39;r\n\n\x05item3\x12\x01g&#39;
                   b&#39;r\x0b\n\x05item4\x12\x02QQ&#39;
                   b&#39;r\x12\n\rlocal_init_op\x12\x01a&#39;
                   b&#39;r\x0e\n\tsummaries\x12\x01e&#39;
                   b&#39;r\x18\n\x13trainable_variables\x12\x01b&#39;
                   b&#39;r\x0e\n\tvariables\x12\x01c&#39;)
    msg = map_unittest_pb2.TestMap()
    msg.map_string_string[&#39;local_init_op&#39;] = &#39;a&#39;
    msg.map_string_string[&#39;trainable_variables&#39;] = &#39;b&#39;
    msg.map_string_string[&#39;variables&#39;] = &#39;c&#39;
    msg.map_string_string[&#39;init_op&#39;] = &#39;d&#39;
    msg.map_string_string[&#39;summaries&#39;] = &#39;e&#39;
    msg.map_string_string[&#39;item1&#39;] = &#39;e&#39;
    msg.map_string_string[&#39;item2&#39;] = &#39;f&#39;
    msg.map_string_string[&#39;item3&#39;] = &#39;g&#39;
    msg.map_string_string[&#39;item4&#39;] = &#39;QQ&#39;

    # If deterministic serialization is not working correctly, this will be
    # &#34;flaky&#34; depending on the exact python dict hash seed.
    #
    # Fortunately, there are enough items in this map that it is extremely
    # unlikely to ever hit the &#34;right&#34; in-order combination, so the test
    # itself should fail reliably.
    self.assertEqual(golden_data, msg.SerializeToString(deterministic=True))

  def testMapIterationClearMessage(self):
    # Iterator needs to work even if message and map are deleted.
    msg = map_unittest_pb2.TestMap()

    msg.map_int32_int32[2] = 4
    msg.map_int32_int32[3] = 6
    msg.map_int32_int32[4] = 8

    it = msg.map_int32_int32.items()
    del msg

    matching_dict = {2: 4, 3: 6, 4: 8}
    self.assertMapIterEquals(it, matching_dict)

  def testMapConstruction(self):
    msg = map_unittest_pb2.TestMap(map_int32_int32={1: 2, 3: 4})
    self.assertEqual(2, msg.map_int32_int32[1])
    self.assertEqual(4, msg.map_int32_int32[3])

    msg = map_unittest_pb2.TestMap(
        map_int32_foreign_message={3: unittest_pb2.ForeignMessage(c=5)})
    self.assertEqual(5, msg.map_int32_foreign_message[3].c)

  def testMapScalarFieldConstruction(self):
    msg1 = map_unittest_pb2.TestMap()
    msg1.map_int32_int32[1] = 42
    msg2 = map_unittest_pb2.TestMap(map_int32_int32=msg1.map_int32_int32)
    self.assertEqual(42, msg2.map_int32_int32[1])

  def testMapMessageFieldConstruction(self):
    msg1 = map_unittest_pb2.TestMap()
    msg1.map_string_foreign_message[&#39;test&#39;].c = 42
    msg2 = map_unittest_pb2.TestMap(
      map_string_foreign_message=msg1.map_string_foreign_message)
    self.assertEqual(42, msg2.map_string_foreign_message[&#39;test&#39;].c)

  def testMapFieldRaisesCorrectError(self):
    # Should raise a TypeError when given a non-iterable.
    with self.assertRaises(TypeError):
      map_unittest_pb2.TestMap(map_string_foreign_message=1)

  def testMapValidAfterFieldCleared(self):
    # Map needs to work even if field is cleared.
    # For the C++ implementation this tests the correctness of
    # MapContainer::Release()
    msg = map_unittest_pb2.TestMap()
    int32_map = msg.map_int32_int32

    int32_map[2] = 4
    int32_map[3] = 6
    int32_map[4] = 8

    msg.ClearField(&#39;map_int32_int32&#39;)
    self.assertEqual(b&#39;&#39;, msg.SerializeToString())
    matching_dict = {2: 4, 3: 6, 4: 8}
    self.assertMapIterEquals(int32_map.items(), matching_dict)

  def testMessageMapValidAfterFieldCleared(self):
    # Map needs to work even if field is cleared.
    # For the C++ implementation this tests the correctness of
    # MapContainer::Release()
    msg = map_unittest_pb2.TestMap()
    int32_foreign_message = msg.map_int32_foreign_message

    int32_foreign_message[2].c = 5

    msg.ClearField(&#39;map_int32_foreign_message&#39;)
    self.assertEqual(b&#39;&#39;, msg.SerializeToString())
    self.assertTrue(2 in int32_foreign_message.keys())

  def testMessageMapItemValidAfterTopMessageCleared(self):
    # Message map item needs to work even if it is cleared.
    # For the C++ implementation this tests the correctness of
    # MapContainer::Release()
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_all_types[2].optional_string = &#39;bar&#39;

    if api_implementation.Type() == &#39;cpp&#39;:
      # Need to keep the map reference because of b/27942626.
      # TODO(jieluo): Remove it.
      unused_map = msg.map_int32_all_types  # pylint: disable=unused-variable
    msg_value = msg.map_int32_all_types[2]
    msg.Clear()

    # Reset to trigger sync between repeated field and map in c++.
    msg.map_int32_all_types[3].optional_string = &#39;foo&#39;
    self.assertEqual(msg_value.optional_string, &#39;bar&#39;)

  def testMapIterInvalidatedByClearField(self):
    # Map iterator is invalidated when field is cleared.
    # But this case does need to not crash the interpreter.
    # For the C++ implementation this tests the correctness of
    # ScalarMapContainer::Release()
    msg = map_unittest_pb2.TestMap()

    it = iter(msg.map_int32_int32)

    msg.ClearField(&#39;map_int32_int32&#39;)
    with self.assertRaises(RuntimeError):
      for _ in it:
        pass

    it = iter(msg.map_int32_foreign_message)
    msg.ClearField(&#39;map_int32_foreign_message&#39;)
    with self.assertRaises(RuntimeError):
      for _ in it:
        pass

  def testMapDelete(self):
    msg = map_unittest_pb2.TestMap()

    self.assertEqual(0, len(msg.map_int32_int32))

    msg.map_int32_int32[4] = 6
    self.assertEqual(1, len(msg.map_int32_int32))

    with self.assertRaises(KeyError):
      del msg.map_int32_int32[88]

    del msg.map_int32_int32[4]
    self.assertEqual(0, len(msg.map_int32_int32))

    with self.assertRaises(KeyError):
      del msg.map_int32_all_types[32]

  def testMapsAreMapping(self):
    msg = map_unittest_pb2.TestMap()
    self.assertIsInstance(msg.map_int32_int32, collections_abc.Mapping)
    self.assertIsInstance(msg.map_int32_int32, collections_abc.MutableMapping)
    self.assertIsInstance(msg.map_int32_foreign_message, collections_abc.Mapping)
    self.assertIsInstance(msg.map_int32_foreign_message,
                          collections_abc.MutableMapping)

  def testMapsCompare(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[-123] = -456
    self.assertEqual(msg.map_int32_int32, msg.map_int32_int32)
    self.assertEqual(msg.map_int32_foreign_message,
                     msg.map_int32_foreign_message)
    self.assertNotEqual(msg.map_int32_int32, 0)

  def testMapFindInitializationErrorsSmokeTest(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
    msg.map_int32_int32[35] = 64
    msg.map_string_foreign_message[&#39;foo&#39;].c = 5
    self.assertEqual(0, len(msg.FindInitializationErrors()))

  @unittest.skipIf(sys.maxunicode == UCS2_MAXUNICODE, &#39;Skip for ucs2&#39;)
  def testStrictUtf8Check(self):
    # Test u&#39;\ud801&#39; is rejected at parser in both python2 and python3.
    serialized = (b&#39;r\x03\xed\xa0\x81&#39;)
    msg = unittest_proto3_arena_pb2.TestAllTypes()
    with self.assertRaises(Exception) as context:
      msg.MergeFromString(serialized)
    if api_implementation.Type() == &#39;python&#39;:
      self.assertIn(&#39;optional_string&#39;, str(context.exception))
    else:
      self.assertIn(&#39;Error parsing message&#39;, str(context.exception))

    # Test optional_string=u&#39;😍&#39; is accepted.
    serialized = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;😍&#39;).SerializeToString()
    msg2 = unittest_proto3_arena_pb2.TestAllTypes()
    msg2.MergeFromString(serialized)
    self.assertEqual(msg2.optional_string, u&#39;😍&#39;)

    msg = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud001&#39;)
    self.assertEqual(msg.optional_string, u&#39;\ud001&#39;)

  @unittest.skipIf(six.PY2, &#39;Surrogates are acceptable in python2&#39;)
  def testSurrogatesInPython3(self):
    # Surrogates like U+D83D is an invalid unicode character, it is
    # supported by Python2 only because in some builds, unicode strings
    # use 2-bytes code units. Since Python 3.3, we don&#39;t have this problem.
    #
    # Surrogates are utf16 code units, in a unicode string they are invalid
    # characters even when they appear in pairs like u&#39;\ud801\udc01&#39;. Protobuf
    # Python3 reject such cases at setters and parsers. Python2 accpect it
    # to keep same features with the language itself. &#39;Unpaired pairs&#39;
    # like u&#39;\ud801&#39; are rejected at parsers when strict utf8 check is enabled
    # in proto3 to keep same behavior with c extension.

    # Surrogates are rejected at setters in Python3.
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=u&#39;\ud801\udc01&#39;)
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=b&#39;\xed\xa0\x81&#39;)
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=u&#39;\ud801&#39;)
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=u&#39;\ud801\ud801&#39;)

  @unittest.skipIf(six.PY3 or sys.maxunicode == UCS2_MAXUNICODE,
                   &#39;Surrogates are rejected at setters in Python3&#39;)
  def testSurrogatesInPython2(self):
    # Test optional_string=u&#39;\ud801\udc01&#39;.
    # surrogate pair is acceptable in python2.
    msg = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801\udc01&#39;)
    # TODO(jieluo): Change pure python to have same behavior with c extension.
    # Some build in python2 consider u&#39;\ud801\udc01&#39; and u&#39;\U00010401&#39; are
    # equal, some are not equal.
    if api_implementation.Type() == &#39;python&#39;:
      self.assertEqual(msg.optional_string, u&#39;\ud801\udc01&#39;)
    else:
      self.assertEqual(msg.optional_string, u&#39;\U00010401&#39;)
    serialized = msg.SerializeToString()
    msg2 = unittest_proto3_arena_pb2.TestAllTypes()
    msg2.MergeFromString(serialized)
    self.assertEqual(msg2.optional_string, u&#39;\U00010401&#39;)

    # Python2 does not reject surrogates at setters.
    msg = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=b&#39;\xed\xa0\x81&#39;)
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801&#39;)
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801\ud801&#39;)


@testing_refleaks.TestCase
class ValidTypeNamesTest(unittest.TestCase):

  def assertImportFromName(self, msg, base_name):
    # Parse &lt;type &#39;module.class_name&#39;&gt; to extra &#39;some.name&#39; as a string.
    tp_name = str(type(msg)).split(&#34;&#39;&#34;)[1]
    valid_names = (&#39;Repeated%sContainer&#39; % base_name,
                   &#39;Repeated%sFieldContainer&#39; % base_name)
    self.assertTrue(any(tp_name.endswith(v) for v in valid_names),
                    &#39;%r does end with any of %r&#39; % (tp_name, valid_names))

    parts = tp_name.split(&#39;.&#39;)
    class_name = parts[-1]
    module_name = &#39;.&#39;.join(parts[:-1])
    __import__(module_name, fromlist=[class_name])

  def testTypeNamesCanBeImported(self):
    # If import doesn&#39;t work, pickling won&#39;t work either.
    pb = unittest_pb2.TestAllTypes()
    self.assertImportFromName(pb.repeated_int32, &#39;Scalar&#39;)
    self.assertImportFromName(pb.repeated_nested_message, &#39;Composite&#39;)

@testing_refleaks.TestCase
class PackedFieldTest(unittest.TestCase):

  def setMessage(self, message):
    message.repeated_int32.append(1)
    message.repeated_int64.append(1)
    message.repeated_uint32.append(1)
    message.repeated_uint64.append(1)
    message.repeated_sint32.append(1)
    message.repeated_sint64.append(1)
    message.repeated_fixed32.append(1)
    message.repeated_fixed64.append(1)
    message.repeated_sfixed32.append(1)
    message.repeated_sfixed64.append(1)
    message.repeated_float.append(1.0)
    message.repeated_double.append(1.0)
    message.repeated_bool.append(True)
    message.repeated_nested_enum.append(1)

  def testPackedFields(self):
    message = packed_field_test_pb2.TestPackedTypes()
    self.setMessage(message)
    golden_data = (b&#39;\x0A\x01\x01&#39;
                   b&#39;\x12\x01\x01&#39;
                   b&#39;\x1A\x01\x01&#39;
                   b&#39;\x22\x01\x01&#39;
                   b&#39;\x2A\x01\x02&#39;
                   b&#39;\x32\x01\x02&#39;
                   b&#39;\x3A\x04\x01\x00\x00\x00&#39;
                   b&#39;\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x4A\x04\x01\x00\x00\x00&#39;
                   b&#39;\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x5A\x04\x00\x00\x80\x3f&#39;
                   b&#39;\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f&#39;
                   b&#39;\x6A\x01\x01&#39;
                   b&#39;\x72\x01\x01&#39;)
    self.assertEqual(golden_data, message.SerializeToString())

  def testUnpackedFields(self):
    message = packed_field_test_pb2.TestUnpackedTypes()
    self.setMessage(message)
    golden_data = (b&#39;\x08\x01&#39;
                   b&#39;\x10\x01&#39;
                   b&#39;\x18\x01&#39;
                   b&#39;\x20\x01&#39;
                   b&#39;\x28\x02&#39;
                   b&#39;\x30\x02&#39;
                   b&#39;\x3D\x01\x00\x00\x00&#39;
                   b&#39;\x41\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x4D\x01\x00\x00\x00&#39;
                   b&#39;\x51\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x5D\x00\x00\x80\x3f&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xf0\x3f&#39;
                   b&#39;\x68\x01&#39;
                   b&#39;\x70\x01&#39;)
    self.assertEqual(golden_data, message.SerializeToString())


@unittest.skipIf(api_implementation.Type() != &#39;cpp&#39; or
                 sys.version_info &lt; (2, 7),
                 &#39;explicit tests of the C++ implementation for PY27 and above&#39;)
@testing_refleaks.TestCase
class OversizeProtosTest(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    # At the moment, reference cycles between DescriptorPool and Message classes
    # are not detected and these objects are never freed.
    # To avoid errors with ReferenceLeakChecker, we create the class only once.
    file_desc = &#34;&#34;&#34;
      name: &#34;f/f.msg2&#34;
      package: &#34;f&#34;
      message_type {
        name: &#34;msg1&#34;
        field {
          name: &#34;payload&#34;
          number: 1
          label: LABEL_OPTIONAL
          type: TYPE_STRING
        }
      }
      message_type {
        name: &#34;msg2&#34;
        field {
          name: &#34;field&#34;
          number: 1
          label: LABEL_OPTIONAL
          type: TYPE_MESSAGE
          type_name: &#34;msg1&#34;
        }
      }
    &#34;&#34;&#34;
    pool = descriptor_pool.DescriptorPool()
    desc = descriptor_pb2.FileDescriptorProto()
    text_format.Parse(file_desc, desc)
    pool.Add(desc)
    cls.proto_cls = message_factory.MessageFactory(pool).GetPrototype(
        pool.FindMessageTypeByName(&#39;f.msg2&#39;))

  def setUp(self):
    self.p = self.proto_cls()
    self.p.field.payload = &#39;c&#39; * (1024 * 1024 * 64 + 1)
    self.p_serialized = self.p.SerializeToString()

  def testAssertOversizeProto(self):
    from google.protobuf.pyext._message import SetAllowOversizeProtos
    SetAllowOversizeProtos(False)
    q = self.proto_cls()
    try:
      q.ParseFromString(self.p_serialized)
    except message.DecodeError as e:
      self.assertEqual(str(e), &#39;Error parsing message&#39;)

  def testSucceedOversizeProto(self):
    from google.protobuf.pyext._message import SetAllowOversizeProtos
    SetAllowOversizeProtos(True)
    q = self.proto_cls()
    q.ParseFromString(self.p_serialized)
    self.assertEqual(self.p.field.payload, q.field.payload)

if __name__ == &#39;__main__&#39;:
  unittest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="google.protobuf.internal.message_test.IsNegInf"><code class="name flex">
<span>def <span class="ident">IsNegInf</span></span>(<span>val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsNegInf(val):
  return isinf(val) and (val &lt; 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.IsPosInf"><code class="name flex">
<span>def <span class="ident">IsPosInf</span></span>(<span>val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsPosInf(val):
  return isinf(val) and (val &gt; 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">cmp = lambda x, y: (x &gt; y) - (x &lt; y)  # Python 3</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.isinf"><code class="name flex">
<span>def <span class="ident">isinf</span></span>(<span>val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isinf(val):
  # Infinity times zero equals NaN.
  return not isnan(val) and isnan(val * 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.isnan"><code class="name flex">
<span>def <span class="ident">isnan</span></span>(<span>val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isnan(val):
  # NaN is never equal to itself.
  return val != val</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.protobuf.internal.message_test.MessageTest"><code class="flex name class">
<span>class <span class="ident">MessageTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageTest(unittest.TestCase):

  def testBadUtf8String(self, message_module):
    if api_implementation.Type() != &#39;python&#39;:
      self.skipTest(&#34;Skipping testBadUtf8String, currently only the python &#34;
                    &#34;api implementation raises UnicodeDecodeError when a &#34;
                    &#34;string field contains bad utf-8.&#34;)
    bad_utf8_data = test_util.GoldenFileData(&#39;bad_utf8_string&#39;)
    with self.assertRaises(UnicodeDecodeError) as context:
      message_module.TestAllTypes.FromString(bad_utf8_data)
    self.assertIn(&#39;TestAllTypes.optional_string&#39;, str(context.exception))

  def testGoldenMessage(self, message_module):
    # Proto3 doesn&#39;t have the &#34;default_foo&#34; members or foreign enums,
    # and doesn&#39;t preserve unknown fields, so for proto3 we use a golden
    # message that doesn&#39;t have these fields set.
    if message_module is unittest_pb2:
      golden_data = test_util.GoldenFileData(
          &#39;golden_message_oneof_implemented&#39;)
    else:
      golden_data = test_util.GoldenFileData(&#39;golden_message_proto3&#39;)

    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    if message_module is unittest_pb2:
      test_util.ExpectAllFieldsSet(self, golden_message)
    self.assertEqual(golden_data, golden_message.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testGoldenPackedMessage(self, message_module):
    golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
    golden_message = message_module.TestPackedTypes()
    parsed_bytes = golden_message.ParseFromString(golden_data)
    all_set = message_module.TestPackedTypes()
    test_util.SetAllPackedFields(all_set)
    self.assertEqual(parsed_bytes, len(golden_data))
    self.assertEqual(all_set, golden_message)
    self.assertEqual(golden_data, all_set.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testParseErrors(self, message_module):
    msg = message_module.TestAllTypes()
    self.assertRaises(TypeError, msg.FromString, 0)
    self.assertRaises(Exception, msg.FromString, &#39;0&#39;)
    # TODO(jieluo): Fix cpp extension to raise error instead of warning.
    # b/27494216
    end_tag = encoder.TagBytes(1, 4)
    if api_implementation.Type() == &#39;python&#39;:
      with self.assertRaises(message.DecodeError) as context:
        msg.FromString(end_tag)
      self.assertEqual(&#39;Unexpected end-group tag.&#39;, str(context.exception))

    # Field number 0 is illegal.
    self.assertRaises(message.DecodeError, msg.FromString, b&#39;\3\4&#39;)

  def testDeterminismParameters(self, message_module):
    # This message is always deterministically serialized, even if determinism
    # is disabled, so we can use it to verify that all the determinism
    # parameters work correctly.
    golden_data = (b&#39;\xe2\x02\nOne string&#39;
                   b&#39;\xe2\x02\nTwo string&#39;
                   b&#39;\xe2\x02\nRed string&#39;
                   b&#39;\xe2\x02\x0bBlue string&#39;)
    golden_message = message_module.TestAllTypes()
    golden_message.repeated_string.extend([
        &#39;One string&#39;,
        &#39;Two string&#39;,
        &#39;Red string&#39;,
        &#39;Blue string&#39;,
    ])
    self.assertEqual(golden_data,
                     golden_message.SerializeToString(deterministic=None))
    self.assertEqual(golden_data,
                     golden_message.SerializeToString(deterministic=False))
    self.assertEqual(golden_data,
                     golden_message.SerializeToString(deterministic=True))

    class BadArgError(Exception):
      pass

    class BadArg(object):

      def __nonzero__(self):
        raise BadArgError()

      def __bool__(self):
        raise BadArgError()

    with self.assertRaises(BadArgError):
      golden_message.SerializeToString(deterministic=BadArg())

  def testPickleSupport(self, message_module):
    golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    pickled_message = pickle.dumps(golden_message)

    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)

  def testPickleNestedMessage(self, message_module):
    golden_message = message_module.TestPickleNestedMessage.NestedMessage(bb=1)
    pickled_message = pickle.dumps(golden_message)
    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)

  def testPickleNestedNestedMessage(self, message_module):
    cls = message_module.TestPickleNestedMessage.NestedMessage
    golden_message = cls.NestedNestedMessage(cc=1)
    pickled_message = pickle.dumps(golden_message)
    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)

  def testPositiveInfinity(self, message_module):
    if message_module is unittest_pb2:
      golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                     b&#39;\xCD\x02\x00\x00\x80\x7F&#39;
                     b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
    else:
      golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                     b&#39;\xCA\x02\x04\x00\x00\x80\x7F&#39;
                     b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)

    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsPosInf(golden_message.optional_float))
    self.assertTrue(IsPosInf(golden_message.optional_double))
    self.assertTrue(IsPosInf(golden_message.repeated_float[0]))
    self.assertTrue(IsPosInf(golden_message.repeated_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNegativeInfinity(self, message_module):
    if message_module is unittest_pb2:
      golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                     b&#39;\xCD\x02\x00\x00\x80\xFF&#39;
                     b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
    else:
      golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                     b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                     b&#39;\xCA\x02\x04\x00\x00\x80\xFF&#39;
                     b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)

    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsNegInf(golden_message.optional_float))
    self.assertTrue(IsNegInf(golden_message.optional_double))
    self.assertTrue(IsNegInf(golden_message.repeated_float[0]))
    self.assertTrue(IsNegInf(golden_message.repeated_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNotANumber(self, message_module):
    golden_data = (b&#39;\x5D\x00\x00\xC0\x7F&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;
                   b&#39;\xCD\x02\x00\x00\xC0\x7F&#39;
                   b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
    golden_message = message_module.TestAllTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(isnan(golden_message.optional_float))
    self.assertTrue(isnan(golden_message.optional_double))
    self.assertTrue(isnan(golden_message.repeated_float[0]))
    self.assertTrue(isnan(golden_message.repeated_double[0]))

    # The protocol buffer may serialize to any one of multiple different
    # representations of a NaN.  Rather than verify a specific representation,
    # verify the serialized string can be converted into a correctly
    # behaving protocol buffer.
    serialized = golden_message.SerializeToString()
    message = message_module.TestAllTypes()
    message.ParseFromString(serialized)
    self.assertTrue(isnan(message.optional_float))
    self.assertTrue(isnan(message.optional_double))
    self.assertTrue(isnan(message.repeated_float[0]))
    self.assertTrue(isnan(message.repeated_double[0]))

  def testPositiveInfinityPacked(self, message_module):
    golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\x7F&#39;
                   b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
    golden_message = message_module.TestPackedTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsPosInf(golden_message.packed_float[0]))
    self.assertTrue(IsPosInf(golden_message.packed_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNegativeInfinityPacked(self, message_module):
    golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\xFF&#39;
                   b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
    golden_message = message_module.TestPackedTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(IsNegInf(golden_message.packed_float[0]))
    self.assertTrue(IsNegInf(golden_message.packed_double[0]))
    self.assertEqual(golden_data, golden_message.SerializeToString())

  def testNotANumberPacked(self, message_module):
    golden_data = (b&#39;\xA2\x06\x04\x00\x00\xC0\x7F&#39;
                   b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
    golden_message = message_module.TestPackedTypes()
    golden_message.ParseFromString(golden_data)
    self.assertTrue(isnan(golden_message.packed_float[0]))
    self.assertTrue(isnan(golden_message.packed_double[0]))

    serialized = golden_message.SerializeToString()
    message = message_module.TestPackedTypes()
    message.ParseFromString(serialized)
    self.assertTrue(isnan(message.packed_float[0]))
    self.assertTrue(isnan(message.packed_double[0]))

  def testExtremeFloatValues(self, message_module):
    message = message_module.TestAllTypes()

    # Most positive exponent, no significand bits set.
    kMostPosExponentNoSigBits = math.pow(2, 127)
    message.optional_float = kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostPosExponentNoSigBits)

    # Most positive exponent, one significand bit set.
    kMostPosExponentOneSigBit = 1.5 * math.pow(2, 127)
    message.optional_float = kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostPosExponentOneSigBit)

    # Repeat last two cases with values of same magnitude, but negative.
    message.optional_float = -kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostPosExponentNoSigBits)

    message.optional_float = -kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostPosExponentOneSigBit)

    # Most negative exponent, no significand bits set.
    kMostNegExponentNoSigBits = math.pow(2, -127)
    message.optional_float = kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostNegExponentNoSigBits)

    # Most negative exponent, one significand bit set.
    kMostNegExponentOneSigBit = 1.5 * math.pow(2, -127)
    message.optional_float = kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == kMostNegExponentOneSigBit)

    # Repeat last two cases with values of the same magnitude, but negative.
    message.optional_float = -kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostNegExponentNoSigBits)

    message.optional_float = -kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_float == -kMostNegExponentOneSigBit)

    # Max 4 bytes float value
    max_float = float.fromhex(&#39;0x1.fffffep+127&#39;)
    message.optional_float = max_float
    self.assertAlmostEqual(message.optional_float, max_float)
    serialized_data = message.SerializeToString()
    message.ParseFromString(serialized_data)
    self.assertAlmostEqual(message.optional_float, max_float)

    # Test set double to float field.
    message.optional_float = 3.4028235e+39
    self.assertEqual(message.optional_float, float(&#39;inf&#39;))
    serialized_data = message.SerializeToString()
    message.ParseFromString(serialized_data)
    self.assertEqual(message.optional_float, float(&#39;inf&#39;))

    message.optional_float = -3.4028235e+39
    self.assertEqual(message.optional_float, float(&#39;-inf&#39;))

    message.optional_float = 1.4028235e-39
    self.assertAlmostEqual(message.optional_float, 1.4028235e-39)

  def testExtremeDoubleValues(self, message_module):
    message = message_module.TestAllTypes()

    # Most positive exponent, no significand bits set.
    kMostPosExponentNoSigBits = math.pow(2, 1023)
    message.optional_double = kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostPosExponentNoSigBits)

    # Most positive exponent, one significand bit set.
    kMostPosExponentOneSigBit = 1.5 * math.pow(2, 1023)
    message.optional_double = kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostPosExponentOneSigBit)

    # Repeat last two cases with values of same magnitude, but negative.
    message.optional_double = -kMostPosExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostPosExponentNoSigBits)

    message.optional_double = -kMostPosExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostPosExponentOneSigBit)

    # Most negative exponent, no significand bits set.
    kMostNegExponentNoSigBits = math.pow(2, -1023)
    message.optional_double = kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostNegExponentNoSigBits)

    # Most negative exponent, one significand bit set.
    kMostNegExponentOneSigBit = 1.5 * math.pow(2, -1023)
    message.optional_double = kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == kMostNegExponentOneSigBit)

    # Repeat last two cases with values of the same magnitude, but negative.
    message.optional_double = -kMostNegExponentNoSigBits
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostNegExponentNoSigBits)

    message.optional_double = -kMostNegExponentOneSigBit
    message.ParseFromString(message.SerializeToString())
    self.assertTrue(message.optional_double == -kMostNegExponentOneSigBit)

  def testFloatPrinting(self, message_module):
    message = message_module.TestAllTypes()
    message.optional_float = 2.0
    self.assertEqual(str(message), &#39;optional_float: 2.0\n&#39;)

  def testHighPrecisionFloatPrinting(self, message_module):
    message = message_module.TestAllTypes()
    message.optional_double = 0.12345678912345678
    if sys.version_info &gt;= (3,):
      self.assertEqual(str(message), &#39;optional_double: 0.12345678912345678\n&#39;)
    else:
      self.assertEqual(str(message), &#39;optional_double: 0.123456789123\n&#39;)

  def testUnknownFieldPrinting(self, message_module):
    populated = message_module.TestAllTypes()
    test_util.SetAllNonLazyFields(populated)
    empty = message_module.TestEmptyMessage()
    empty.ParseFromString(populated.SerializeToString())
    self.assertEqual(str(empty), &#39;&#39;)

  def testAppendRepeatedCompositeField(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_nested_message.append(
        message_module.TestAllTypes.NestedMessage(bb=1))
    nested = message_module.TestAllTypes.NestedMessage(bb=2)
    msg.repeated_nested_message.append(nested)
    try:
      msg.repeated_nested_message.append(1)
    except TypeError:
      pass
    self.assertEqual(2, len(msg.repeated_nested_message))
    self.assertEqual([1, 2],
                     [m.bb for m in msg.repeated_nested_message])

  def testInsertRepeatedCompositeField(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_nested_message.insert(
        -1, message_module.TestAllTypes.NestedMessage(bb=1))
    sub_msg = msg.repeated_nested_message[0]
    msg.repeated_nested_message.insert(
        0, message_module.TestAllTypes.NestedMessage(bb=2))
    msg.repeated_nested_message.insert(
        99, message_module.TestAllTypes.NestedMessage(bb=3))
    msg.repeated_nested_message.insert(
        -2, message_module.TestAllTypes.NestedMessage(bb=-1))
    msg.repeated_nested_message.insert(
        -1000, message_module.TestAllTypes.NestedMessage(bb=-1000))
    try:
      msg.repeated_nested_message.insert(1, 999)
    except TypeError:
      pass
    self.assertEqual(5, len(msg.repeated_nested_message))
    self.assertEqual([-1000, 2, -1, 1, 3],
                     [m.bb for m in msg.repeated_nested_message])
    self.assertEqual(str(msg),
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: -1000\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: 2\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: -1\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: 1\n&#39;
                     &#39;}\n&#39;
                     &#39;repeated_nested_message {\n&#39;
                     &#39;  bb: 3\n&#39;
                     &#39;}\n&#39;)
    self.assertEqual(sub_msg.bb, 1)

  def testMergeFromRepeatedField(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_int32.append(1)
    msg.repeated_int32.append(3)
    msg.repeated_nested_message.add(bb=1)
    msg.repeated_nested_message.add(bb=2)
    other_msg = message_module.TestAllTypes()
    other_msg.repeated_nested_message.add(bb=3)
    other_msg.repeated_nested_message.add(bb=4)
    other_msg.repeated_int32.append(5)
    other_msg.repeated_int32.append(7)

    msg.repeated_int32.MergeFrom(other_msg.repeated_int32)
    self.assertEqual(4, len(msg.repeated_int32))

    msg.repeated_nested_message.MergeFrom(other_msg.repeated_nested_message)
    self.assertEqual([1, 2, 3, 4],
                     [m.bb for m in msg.repeated_nested_message])

  def testAddWrongRepeatedNestedField(self, message_module):
    msg = message_module.TestAllTypes()
    try:
      msg.repeated_nested_message.add(&#39;wrong&#39;)
    except TypeError:
      pass
    try:
      msg.repeated_nested_message.add(value_field=&#39;wrong&#39;)
    except ValueError:
      pass
    self.assertEqual(len(msg.repeated_nested_message), 0)

  def testRepeatedContains(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_int32.extend([1, 2, 3])
    self.assertIn(2, msg.repeated_int32)
    self.assertNotIn(0, msg.repeated_int32)

    msg.repeated_nested_message.add(bb=1)
    sub_msg1 = msg.repeated_nested_message[0]
    sub_msg2 = message_module.TestAllTypes.NestedMessage(bb=2)
    sub_msg3 = message_module.TestAllTypes.NestedMessage(bb=3)
    msg.repeated_nested_message.append(sub_msg2)
    msg.repeated_nested_message.insert(0, sub_msg3)
    self.assertIn(sub_msg1, msg.repeated_nested_message)
    self.assertIn(sub_msg2, msg.repeated_nested_message)
    self.assertIn(sub_msg3, msg.repeated_nested_message)

  def testRepeatedScalarIterable(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_int32.extend([1, 2, 3])
    add = 0
    for item in msg.repeated_int32:
      add += item
    self.assertEqual(add, 6)

  def testRepeatedNestedFieldIteration(self, message_module):
    msg = message_module.TestAllTypes()
    msg.repeated_nested_message.add(bb=1)
    msg.repeated_nested_message.add(bb=2)
    msg.repeated_nested_message.add(bb=3)
    msg.repeated_nested_message.add(bb=4)

    self.assertEqual([1, 2, 3, 4],
                     [m.bb for m in msg.repeated_nested_message])
    self.assertEqual([4, 3, 2, 1],
                     [m.bb for m in reversed(msg.repeated_nested_message)])
    self.assertEqual([4, 3, 2, 1],
                     [m.bb for m in msg.repeated_nested_message[::-1]])

  def testSortingRepeatedScalarFieldsDefaultComparator(self, message_module):
    &#34;&#34;&#34;Check some different types with the default comparator.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    # TODO(mattp): would testing more scalar types strengthen test?
    message.repeated_int32.append(1)
    message.repeated_int32.append(3)
    message.repeated_int32.append(2)
    message.repeated_int32.sort()
    self.assertEqual(message.repeated_int32[0], 1)
    self.assertEqual(message.repeated_int32[1], 2)
    self.assertEqual(message.repeated_int32[2], 3)
    self.assertEqual(str(message.repeated_int32), str([1, 2, 3]))

    message.repeated_float.append(1.1)
    message.repeated_float.append(1.3)
    message.repeated_float.append(1.2)
    message.repeated_float.sort()
    self.assertAlmostEqual(message.repeated_float[0], 1.1)
    self.assertAlmostEqual(message.repeated_float[1], 1.2)
    self.assertAlmostEqual(message.repeated_float[2], 1.3)

    message.repeated_string.append(&#39;a&#39;)
    message.repeated_string.append(&#39;c&#39;)
    message.repeated_string.append(&#39;b&#39;)
    message.repeated_string.sort()
    self.assertEqual(message.repeated_string[0], &#39;a&#39;)
    self.assertEqual(message.repeated_string[1], &#39;b&#39;)
    self.assertEqual(message.repeated_string[2], &#39;c&#39;)
    self.assertEqual(str(message.repeated_string), str([u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;]))

    message.repeated_bytes.append(b&#39;a&#39;)
    message.repeated_bytes.append(b&#39;c&#39;)
    message.repeated_bytes.append(b&#39;b&#39;)
    message.repeated_bytes.sort()
    self.assertEqual(message.repeated_bytes[0], b&#39;a&#39;)
    self.assertEqual(message.repeated_bytes[1], b&#39;b&#39;)
    self.assertEqual(message.repeated_bytes[2], b&#39;c&#39;)
    self.assertEqual(str(message.repeated_bytes), str([b&#39;a&#39;, b&#39;b&#39;, b&#39;c&#39;]))

  def testSortingRepeatedScalarFieldsCustomComparator(self, message_module):
    &#34;&#34;&#34;Check some different types with custom comparator.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_int32.append(-3)
    message.repeated_int32.append(-2)
    message.repeated_int32.append(-1)
    message.repeated_int32.sort(key=abs)
    self.assertEqual(message.repeated_int32[0], -1)
    self.assertEqual(message.repeated_int32[1], -2)
    self.assertEqual(message.repeated_int32[2], -3)

    message.repeated_string.append(&#39;aaa&#39;)
    message.repeated_string.append(&#39;bb&#39;)
    message.repeated_string.append(&#39;c&#39;)
    message.repeated_string.sort(key=len)
    self.assertEqual(message.repeated_string[0], &#39;c&#39;)
    self.assertEqual(message.repeated_string[1], &#39;bb&#39;)
    self.assertEqual(message.repeated_string[2], &#39;aaa&#39;)

  def testSortingRepeatedCompositeFieldsCustomComparator(self, message_module):
    &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_nested_message.add().bb = 1
    message.repeated_nested_message.add().bb = 3
    message.repeated_nested_message.add().bb = 2
    message.repeated_nested_message.add().bb = 6
    message.repeated_nested_message.add().bb = 5
    message.repeated_nested_message.add().bb = 4
    message.repeated_nested_message.sort(key=operator.attrgetter(&#39;bb&#39;))
    self.assertEqual(message.repeated_nested_message[0].bb, 1)
    self.assertEqual(message.repeated_nested_message[1].bb, 2)
    self.assertEqual(message.repeated_nested_message[2].bb, 3)
    self.assertEqual(message.repeated_nested_message[3].bb, 4)
    self.assertEqual(message.repeated_nested_message[4].bb, 5)
    self.assertEqual(message.repeated_nested_message[5].bb, 6)
    self.assertEqual(str(message.repeated_nested_message),
                     &#39;[bb: 1\n, bb: 2\n, bb: 3\n, bb: 4\n, bb: 5\n, bb: 6\n]&#39;)

  def testSortingRepeatedCompositeFieldsStable(self, message_module):
    &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_nested_message.add().bb = 21
    message.repeated_nested_message.add().bb = 20
    message.repeated_nested_message.add().bb = 13
    message.repeated_nested_message.add().bb = 33
    message.repeated_nested_message.add().bb = 11
    message.repeated_nested_message.add().bb = 24
    message.repeated_nested_message.add().bb = 10
    message.repeated_nested_message.sort(key=lambda z: z.bb // 10)
    self.assertEqual(
        [13, 11, 10, 21, 20, 24, 33],
        [n.bb for n in message.repeated_nested_message])

    # Make sure that for the C++ implementation, the underlying fields
    # are actually reordered.
    pb = message.SerializeToString()
    message.Clear()
    message.MergeFromString(pb)
    self.assertEqual(
        [13, 11, 10, 21, 20, 24, 33],
        [n.bb for n in message.repeated_nested_message])

  def testRepeatedCompositeFieldSortArguments(self, message_module):
    &#34;&#34;&#34;Check sorting a repeated composite field using list.sort() arguments.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    get_bb = operator.attrgetter(&#39;bb&#39;)
    cmp_bb = lambda a, b: cmp(a.bb, b.bb)
    message.repeated_nested_message.add().bb = 1
    message.repeated_nested_message.add().bb = 3
    message.repeated_nested_message.add().bb = 2
    message.repeated_nested_message.add().bb = 6
    message.repeated_nested_message.add().bb = 5
    message.repeated_nested_message.add().bb = 4
    message.repeated_nested_message.sort(key=get_bb)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [1, 2, 3, 4, 5, 6])
    message.repeated_nested_message.sort(key=get_bb, reverse=True)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [6, 5, 4, 3, 2, 1])
    if sys.version_info &gt;= (3,): return  # No cmp sorting in PY3.
    message.repeated_nested_message.sort(sort_function=cmp_bb)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [1, 2, 3, 4, 5, 6])
    message.repeated_nested_message.sort(cmp=cmp_bb, reverse=True)
    self.assertEqual([k.bb for k in message.repeated_nested_message],
                     [6, 5, 4, 3, 2, 1])

  def testRepeatedScalarFieldSortArguments(self, message_module):
    &#34;&#34;&#34;Check sorting a scalar field using list.sort() arguments.&#34;&#34;&#34;
    message = message_module.TestAllTypes()

    message.repeated_int32.append(-3)
    message.repeated_int32.append(-2)
    message.repeated_int32.append(-1)
    message.repeated_int32.sort(key=abs)
    self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
    message.repeated_int32.sort(key=abs, reverse=True)
    self.assertEqual(list(message.repeated_int32), [-3, -2, -1])
    if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
      abs_cmp = lambda a, b: cmp(abs(a), abs(b))
      message.repeated_int32.sort(sort_function=abs_cmp)
      self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
      message.repeated_int32.sort(cmp=abs_cmp, reverse=True)
      self.assertEqual(list(message.repeated_int32), [-3, -2, -1])

    message.repeated_string.append(&#39;aaa&#39;)
    message.repeated_string.append(&#39;bb&#39;)
    message.repeated_string.append(&#39;c&#39;)
    message.repeated_string.sort(key=len)
    self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
    message.repeated_string.sort(key=len, reverse=True)
    self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])
    if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
      len_cmp = lambda a, b: cmp(len(a), len(b))
      message.repeated_string.sort(sort_function=len_cmp)
      self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
      message.repeated_string.sort(cmp=len_cmp, reverse=True)
      self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])

  def testRepeatedFieldsComparable(self, message_module):
    m1 = message_module.TestAllTypes()
    m2 = message_module.TestAllTypes()
    m1.repeated_int32.append(0)
    m1.repeated_int32.append(1)
    m1.repeated_int32.append(2)
    m2.repeated_int32.append(0)
    m2.repeated_int32.append(1)
    m2.repeated_int32.append(2)
    m1.repeated_nested_message.add().bb = 1
    m1.repeated_nested_message.add().bb = 2
    m1.repeated_nested_message.add().bb = 3
    m2.repeated_nested_message.add().bb = 1
    m2.repeated_nested_message.add().bb = 2
    m2.repeated_nested_message.add().bb = 3

    if sys.version_info &gt;= (3,): return  # No cmp() in PY3.

    # These comparisons should not raise errors.
    _ = m1 &lt; m2
    _ = m1.repeated_nested_message &lt; m2.repeated_nested_message

    # Make sure cmp always works. If it wasn&#39;t defined, these would be
    # id() comparisons and would all fail.
    self.assertEqual(cmp(m1, m2), 0)
    self.assertEqual(cmp(m1.repeated_int32, m2.repeated_int32), 0)
    self.assertEqual(cmp(m1.repeated_int32, [0, 1, 2]), 0)
    self.assertEqual(cmp(m1.repeated_nested_message,
                         m2.repeated_nested_message), 0)
    with self.assertRaises(TypeError):
      # Can&#39;t compare repeated composite containers to lists.
      cmp(m1.repeated_nested_message, m2.repeated_nested_message[:])

    # TODO(anuraag): Implement extensiondict comparison in C++ and then add test

  def testRepeatedFieldsAreSequences(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIsInstance(m.repeated_int32, collections_abc.MutableSequence)
    self.assertIsInstance(m.repeated_nested_message,
                          collections_abc.MutableSequence)

  def testRepeatedFieldsNotHashable(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(TypeError):
      hash(m.repeated_int32)
    with self.assertRaises(TypeError):
      hash(m.repeated_nested_message)

  def testRepeatedFieldInsideNestedMessage(self, message_module):
    m = message_module.NestedTestAllTypes()
    m.payload.repeated_int32.extend([])
    self.assertTrue(m.HasField(&#39;payload&#39;))

  def testMergeFrom(self, message_module):
    m1 = message_module.TestAllTypes()
    m2 = message_module.TestAllTypes()
    # Cpp extension will lazily create a sub message which is immutable.
    nested = m1.optional_nested_message
    self.assertEqual(0, nested.bb)
    m2.optional_nested_message.bb = 1
    # Make sure cmessage pointing to a mutable message after merge instead of
    # the lazily created message.
    m1.MergeFrom(m2)
    self.assertEqual(1, nested.bb)

    # Test more nested sub message.
    msg1 = message_module.NestedTestAllTypes()
    msg2 = message_module.NestedTestAllTypes()
    nested = msg1.child.payload.optional_nested_message
    self.assertEqual(0, nested.bb)
    msg2.child.payload.optional_nested_message.bb = 1
    msg1.MergeFrom(msg2)
    self.assertEqual(1, nested.bb)

    # Test repeated field.
    self.assertEqual(msg1.payload.repeated_nested_message,
                     msg1.payload.repeated_nested_message)
    nested = msg2.payload.repeated_nested_message.add()
    nested.bb = 1
    msg1.MergeFrom(msg2)
    self.assertEqual(1, len(msg1.payload.repeated_nested_message))
    self.assertEqual(1, nested.bb)

  def testMergeFromString(self, message_module):
    m1 = message_module.TestAllTypes()
    m2 = message_module.TestAllTypes()
    # Cpp extension will lazily create a sub message which is immutable.
    self.assertEqual(0, m1.optional_nested_message.bb)
    m2.optional_nested_message.bb = 1
    # Make sure cmessage pointing to a mutable message after merge instead of
    # the lazily created message.
    m1.MergeFromString(m2.SerializeToString())
    self.assertEqual(1, m1.optional_nested_message.bb)

  @unittest.skipIf(six.PY2, &#39;memoryview objects are not supported on py2&#39;)
  def testMergeFromStringUsingMemoryViewWorksInPy3(self, message_module):
    m2 = message_module.TestAllTypes()
    m2.optional_string = &#39;scalar string&#39;
    m2.repeated_string.append(&#39;repeated string&#39;)
    m2.optional_bytes = b&#39;scalar bytes&#39;
    m2.repeated_bytes.append(b&#39;repeated bytes&#39;)

    serialized = m2.SerializeToString()
    memview = memoryview(serialized)
    m1 = message_module.TestAllTypes.FromString(memview)

    self.assertEqual(m1.optional_bytes, b&#39;scalar bytes&#39;)
    self.assertEqual(m1.repeated_bytes, [b&#39;repeated bytes&#39;])
    self.assertEqual(m1.optional_string, &#39;scalar string&#39;)
    self.assertEqual(m1.repeated_string, [&#39;repeated string&#39;])
    # Make sure that the memoryview was correctly converted to bytes, and
    # that a sub-sliced memoryview is not being used.
    self.assertIsInstance(m1.optional_bytes, bytes)
    self.assertIsInstance(m1.repeated_bytes[0], bytes)
    self.assertIsInstance(m1.optional_string, six.text_type)
    self.assertIsInstance(m1.repeated_string[0], six.text_type)

  @unittest.skipIf(six.PY3, &#39;memoryview is supported by py3&#39;)
  def testMergeFromStringUsingMemoryViewIsPy2Error(self, message_module):
    memview = memoryview(b&#39;&#39;)
    with self.assertRaises(TypeError):
      message_module.TestAllTypes.FromString(memview)

  def testMergeFromEmpty(self, message_module):
    m1 = message_module.TestAllTypes()
    # Cpp extension will lazily create a sub message which is immutable.
    self.assertEqual(0, m1.optional_nested_message.bb)
    self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))
    # Make sure the sub message is still immutable after merge from empty.
    m1.MergeFromString(b&#39;&#39;)  # field state should not change
    self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))

  def ensureNestedMessageExists(self, msg, attribute):
    &#34;&#34;&#34;Make sure that a nested message object exists.

    As soon as a nested message attribute is accessed, it will be present in the
    _fields dict, without being marked as actually being set.
    &#34;&#34;&#34;
    getattr(msg, attribute)
    self.assertFalse(msg.HasField(attribute))

  def testOneofGetCaseNonexistingField(self, message_module):
    m = message_module.TestAllTypes()
    self.assertRaises(ValueError, m.WhichOneof, &#39;no_such_oneof_field&#39;)
    self.assertRaises(Exception, m.WhichOneof, 0)

  def testOneofDefaultValues(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))

    # Oneof is set even when setting it to a default value.
    m.oneof_uint32 = 0
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
    self.assertFalse(m.HasField(&#39;oneof_string&#39;))

    m.oneof_string = &#34;&#34;
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))

  def testOneofSemantics(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

    m.oneof_uint32 = 11
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))

    m.oneof_string = u&#39;foo&#39;
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))

    # Read nested message accessor without accessing submessage.
    m.oneof_nested_message
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))
    self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

    # Read accessor of nested message without accessing submessage.
    m.oneof_nested_message.bb
    self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_string&#39;))
    self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

    m.oneof_nested_message.bb = 11
    self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_string&#39;))
    self.assertTrue(m.HasField(&#39;oneof_nested_message&#39;))

    m.oneof_bytes = b&#39;bb&#39;
    self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))
    self.assertTrue(m.HasField(&#39;oneof_bytes&#39;))

  def testOneofCompositeFieldReadAccess(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11

    self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    self.assertEqual(11, m.oneof_uint32)

  def testOneofWhichOneof(self, message_module):
    m = message_module.TestAllTypes()
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))

    m.oneof_uint32 = 11
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
    if message_module is unittest_pb2:
      self.assertTrue(m.HasField(&#39;oneof_field&#39;))

    m.oneof_bytes = b&#39;bb&#39;
    self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))

    m.ClearField(&#39;oneof_bytes&#39;)
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))

  def testOneofClearField(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m.ClearField(&#39;oneof_field&#39;)
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofClearSetField(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m.ClearField(&#39;oneof_uint32&#39;)
    if message_module is unittest_pb2:
      self.assertFalse(m.HasField(&#39;oneof_field&#39;))
    self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
    self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofClearUnsetField(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
    m.ClearField(&#39;oneof_nested_message&#39;)
    self.assertEqual(11, m.oneof_uint32)
    if message_module is unittest_pb2:
      self.assertTrue(m.HasField(&#39;oneof_field&#39;))
    self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
    self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofDeserialize(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m2 = message_module.TestAllTypes()
    m2.ParseFromString(m.SerializeToString())
    self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))

  def testOneofCopyFrom(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m2 = message_module.TestAllTypes()
    m2.CopyFrom(m)
    self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))

  def testOneofNestedMergeFrom(self, message_module):
    m = message_module.NestedTestAllTypes()
    m.payload.oneof_uint32 = 11
    m2 = message_module.NestedTestAllTypes()
    m2.payload.oneof_bytes = b&#39;bb&#39;
    m2.child.payload.oneof_bytes = b&#39;bb&#39;
    m2.MergeFrom(m)
    self.assertEqual(&#39;oneof_uint32&#39;, m2.payload.WhichOneof(&#39;oneof_field&#39;))
    self.assertEqual(&#39;oneof_bytes&#39;, m2.child.payload.WhichOneof(&#39;oneof_field&#39;))

  def testOneofMessageMergeFrom(self, message_module):
    m = message_module.NestedTestAllTypes()
    m.payload.oneof_nested_message.bb = 11
    m.child.payload.oneof_nested_message.bb = 12
    m2 = message_module.NestedTestAllTypes()
    m2.payload.oneof_uint32 = 13
    m2.MergeFrom(m)
    self.assertEqual(&#39;oneof_nested_message&#39;,
                     m2.payload.WhichOneof(&#39;oneof_field&#39;))
    self.assertEqual(&#39;oneof_nested_message&#39;,
                     m2.child.payload.WhichOneof(&#39;oneof_field&#39;))

  def testOneofNestedMessageInit(self, message_module):
    m = message_module.TestAllTypes(
        oneof_nested_message=message_module.TestAllTypes.NestedMessage())
    self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  def testOneofClear(self, message_module):
    m = message_module.TestAllTypes()
    m.oneof_uint32 = 11
    m.Clear()
    self.assertIsNone(m.WhichOneof(&#39;oneof_field&#39;))
    m.oneof_bytes = b&#39;bb&#39;
    self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  def testAssignByteStringToUnicodeField(self, message_module):
    &#34;&#34;&#34;Assigning a byte string to a string field should result
    in the value being converted to a Unicode string.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    m.optional_string = str(&#39;&#39;)
    self.assertIsInstance(m.optional_string, six.text_type)

  def testLongValuedSlice(self, message_module):
    &#34;&#34;&#34;It should be possible to use long-valued indicies in slices

    This didn&#39;t used to work in the v2 C++ implementation.
    &#34;&#34;&#34;
    m = message_module.TestAllTypes()

    # Repeated scalar
    m.repeated_int32.append(1)
    sl = m.repeated_int32[long(0):long(len(m.repeated_int32))]
    self.assertEqual(len(m.repeated_int32), len(sl))

    # Repeated composite
    m.repeated_nested_message.add().bb = 3
    sl = m.repeated_nested_message[long(0):long(len(m.repeated_nested_message))]
    self.assertEqual(len(m.repeated_nested_message), len(sl))

  def testExtendShouldNotSwallowExceptions(self, message_module):
    &#34;&#34;&#34;This didn&#39;t use to work in the v2 C++ implementation.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    with self.assertRaises(NameError) as _:
      m.repeated_int32.extend(a for i in range(10))  # pylint: disable=undefined-variable
    with self.assertRaises(NameError) as _:
      m.repeated_nested_enum.extend(
          a for i in range(10))  # pylint: disable=undefined-variable

  FALSY_VALUES = [None, False, 0, 0.0, b&#39;&#39;, u&#39;&#39;, bytearray(), [], {}, set()]

  def testExtendInt32WithNothing(self, message_module):
    &#34;&#34;&#34;Test no-ops extending repeated int32 fields.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_int32)

    # TODO(ptucker): Deprecate this behavior. b/18413862
    for falsy_value in MessageTest.FALSY_VALUES:
      m.repeated_int32.extend(falsy_value)
      self.assertSequenceEqual([], m.repeated_int32)

    m.repeated_int32.extend([])
    self.assertSequenceEqual([], m.repeated_int32)

  def testExtendFloatWithNothing(self, message_module):
    &#34;&#34;&#34;Test no-ops extending repeated float fields.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_float)

    # TODO(ptucker): Deprecate this behavior. b/18413862
    for falsy_value in MessageTest.FALSY_VALUES:
      m.repeated_float.extend(falsy_value)
      self.assertSequenceEqual([], m.repeated_float)

    m.repeated_float.extend([])
    self.assertSequenceEqual([], m.repeated_float)

  def testExtendStringWithNothing(self, message_module):
    &#34;&#34;&#34;Test no-ops extending repeated string fields.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)

    # TODO(ptucker): Deprecate this behavior. b/18413862
    for falsy_value in MessageTest.FALSY_VALUES:
      m.repeated_string.extend(falsy_value)
      self.assertSequenceEqual([], m.repeated_string)

    m.repeated_string.extend([])
    self.assertSequenceEqual([], m.repeated_string)

  def testExtendInt32WithPythonList(self, message_module):
    &#34;&#34;&#34;Test extending repeated int32 fields with python lists.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_int32)
    m.repeated_int32.extend([0])
    self.assertSequenceEqual([0], m.repeated_int32)
    m.repeated_int32.extend([1, 2])
    self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
    m.repeated_int32.extend([3, 4])
    self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)

  def testExtendFloatWithPythonList(self, message_module):
    &#34;&#34;&#34;Test extending repeated float fields with python lists.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_float)
    m.repeated_float.extend([0.0])
    self.assertSequenceEqual([0.0], m.repeated_float)
    m.repeated_float.extend([1.0, 2.0])
    self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
    m.repeated_float.extend([3.0, 4.0])
    self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)

  def testExtendStringWithPythonList(self, message_module):
    &#34;&#34;&#34;Test extending repeated string fields with python lists.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend([&#39;&#39;])
    self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
    m.repeated_string.extend([&#39;11&#39;, &#39;22&#39;])
    self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;], m.repeated_string)
    m.repeated_string.extend([&#39;33&#39;, &#39;44&#39;])
    self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;, &#39;33&#39;, &#39;44&#39;], m.repeated_string)

  def testExtendStringWithString(self, message_module):
    &#34;&#34;&#34;Test extending repeated string fields with characters from a string.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend(&#39;abc&#39;)
    self.assertSequenceEqual([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], m.repeated_string)

  class TestIterable(object):
    &#34;&#34;&#34;This iterable object mimics the behavior of numpy.array.

    __nonzero__ fails for length &gt; 1, and returns bool(item[0]) for length == 1.

    &#34;&#34;&#34;

    def __init__(self, values=None):
      self._list = values or []

    def __nonzero__(self):
      size = len(self._list)
      if size == 0:
        return False
      if size == 1:
        return bool(self._list[0])
      raise ValueError(&#39;Truth value is ambiguous.&#39;)

    def __len__(self):
      return len(self._list)

    def __iter__(self):
      return self._list.__iter__()

  def testExtendInt32WithIterable(self, message_module):
    &#34;&#34;&#34;Test extending repeated int32 fields with iterable.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([]))
    self.assertSequenceEqual([], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([0]))
    self.assertSequenceEqual([0], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([1, 2]))
    self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
    m.repeated_int32.extend(MessageTest.TestIterable([3, 4]))
    self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)

  def testExtendFloatWithIterable(self, message_module):
    &#34;&#34;&#34;Test extending repeated float fields with iterable.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([]))
    self.assertSequenceEqual([], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([0.0]))
    self.assertSequenceEqual([0.0], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([1.0, 2.0]))
    self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
    m.repeated_float.extend(MessageTest.TestIterable([3.0, 4.0]))
    self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)

  def testExtendStringWithIterable(self, message_module):
    &#34;&#34;&#34;Test extending repeated string fields with iterable.&#34;&#34;&#34;
    m = message_module.TestAllTypes()
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([]))
    self.assertSequenceEqual([], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([&#39;&#39;]))
    self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([&#39;1&#39;, &#39;2&#39;]))
    self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;], m.repeated_string)
    m.repeated_string.extend(MessageTest.TestIterable([&#39;3&#39;, &#39;4&#39;]))
    self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;], m.repeated_string)

  def testPickleRepeatedScalarContainer(self, message_module):
    # TODO(tibell): The pure-Python implementation support pickling of
    #   scalar containers in *some* cases. For now the cpp2 version
    #   throws an exception to avoid a segfault. Investigate if we
    #   want to support pickling of these fields.
    #
    # For more information see: https://b2.corp.google.com/u/0/issues/18677897
    if (api_implementation.Type() != &#39;cpp&#39; or
        api_implementation.Version() == 2):
      return
    m = message_module.TestAllTypes()
    with self.assertRaises(pickle.PickleError) as _:
      pickle.dumps(m.repeated_int32, pickle.HIGHEST_PROTOCOL)

  def testSortEmptyRepeatedCompositeContainer(self, message_module):
    &#34;&#34;&#34;Exercise a scenario that has led to segfaults in the past.
    &#34;&#34;&#34;
    m = message_module.TestAllTypes()
    m.repeated_nested_message.sort()

  def testHasFieldOnRepeatedField(self, message_module):
    &#34;&#34;&#34;Using HasField on a repeated field should raise an exception.
    &#34;&#34;&#34;
    m = message_module.TestAllTypes()
    with self.assertRaises(ValueError) as _:
      m.HasField(&#39;repeated_int32&#39;)

  def testRepeatedScalarFieldPop(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(IndexError) as _:
      m.repeated_int32.pop()
    m.repeated_int32.extend(range(5))
    self.assertEqual(4, m.repeated_int32.pop())
    self.assertEqual(0, m.repeated_int32.pop(0))
    self.assertEqual(2, m.repeated_int32.pop(1))
    self.assertEqual([1, 3], m.repeated_int32)

  def testRepeatedCompositeFieldPop(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(IndexError) as _:
      m.repeated_nested_message.pop()
    with self.assertRaises(TypeError) as _:
      m.repeated_nested_message.pop(&#39;0&#39;)
    for i in range(5):
      n = m.repeated_nested_message.add()
      n.bb = i
    self.assertEqual(4, m.repeated_nested_message.pop().bb)
    self.assertEqual(0, m.repeated_nested_message.pop(0).bb)
    self.assertEqual(2, m.repeated_nested_message.pop(1).bb)
    self.assertEqual([1, 3], [n.bb for n in m.repeated_nested_message])

  def testRepeatedCompareWithSelf(self, message_module):
    m = message_module.TestAllTypes()
    for i in range(5):
      m.repeated_int32.insert(i, i)
      n = m.repeated_nested_message.add()
      n.bb = i
    self.assertSequenceEqual(m.repeated_int32, m.repeated_int32)
    self.assertEqual(m.repeated_nested_message, m.repeated_nested_message)

  def testReleasedNestedMessages(self, message_module):
    &#34;&#34;&#34;A case that lead to a segfault when a message detached from its parent
    container has itself a child container.
    &#34;&#34;&#34;
    m = message_module.NestedTestAllTypes()
    m = m.repeated_child.add()
    m = m.child
    m = m.repeated_child.add()
    self.assertEqual(m.payload.optional_int32, 0)

  def testSetRepeatedComposite(self, message_module):
    m = message_module.TestAllTypes()
    with self.assertRaises(AttributeError):
      m.repeated_int32 = []
    m.repeated_int32.append(1)
    with self.assertRaises(AttributeError):
      m.repeated_int32 = []

  def testReturningType(self, message_module):
    m = message_module.TestAllTypes()
    self.assertEqual(float, type(m.optional_float))
    self.assertEqual(float, type(m.optional_double))
    self.assertEqual(bool, type(m.optional_bool))
    m.optional_float = 1
    m.optional_double = 1
    m.optional_bool = 1
    m.repeated_float.append(1)
    m.repeated_double.append(1)
    m.repeated_bool.append(1)
    m.ParseFromString(m.SerializeToString())
    self.assertEqual(float, type(m.optional_float))
    self.assertEqual(float, type(m.optional_double))
    self.assertEqual(&#39;1.0&#39;, str(m.optional_double))
    self.assertEqual(bool, type(m.optional_bool))
    self.assertEqual(float, type(m.repeated_float[0]))
    self.assertEqual(float, type(m.repeated_double[0]))
    self.assertEqual(bool, type(m.repeated_bool[0]))
    self.assertEqual(True, m.repeated_bool[0])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="google.protobuf.internal.message_test.MessageTest.FALSY_VALUES"><code class="name">var <span class="ident">FALSY_VALUES</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.TestIterable"><code class="name">var <span class="ident">TestIterable</span></code></dt>
<dd>
<section class="desc"><p>This iterable object mimics the behavior of numpy.array.</p>
<p><strong>nonzero</strong> fails for length &gt; 1, and returns bool(item[0]) for length == 1.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestIterable(object):
  &#34;&#34;&#34;This iterable object mimics the behavior of numpy.array.

  __nonzero__ fails for length &gt; 1, and returns bool(item[0]) for length == 1.

  &#34;&#34;&#34;

  def __init__(self, values=None):
    self._list = values or []

  def __nonzero__(self):
    size = len(self._list)
    if size == 0:
      return False
    if size == 1:
      return bool(self._list[0])
    raise ValueError(&#39;Truth value is ambiguous.&#39;)

  def __len__(self):
    return len(self._list)

  def __iter__(self):
    return self._list.__iter__()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.MessageTest.ensureNestedMessageExists"><code class="name flex">
<span>def <span class="ident">ensureNestedMessageExists</span></span>(<span>self, msg, attribute)</span>
</code></dt>
<dd>
<section class="desc"><p>Make sure that a nested message object exists.</p>
<p>As soon as a nested message attribute is accessed, it will be present in the
_fields dict, without being marked as actually being set.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensureNestedMessageExists(self, msg, attribute):
  &#34;&#34;&#34;Make sure that a nested message object exists.

  As soon as a nested message attribute is accessed, it will be present in the
  _fields dict, without being marked as actually being set.
  &#34;&#34;&#34;
  getattr(msg, attribute)
  self.assertFalse(msg.HasField(attribute))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testAddWrongRepeatedNestedField_proto2"><code class="name flex">
<span>def <span class="ident">testAddWrongRepeatedNestedField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAddWrongRepeatedNestedField(self, message_module):
  msg = message_module.TestAllTypes()
  try:
    msg.repeated_nested_message.add(&#39;wrong&#39;)
  except TypeError:
    pass
  try:
    msg.repeated_nested_message.add(value_field=&#39;wrong&#39;)
  except ValueError:
    pass
  self.assertEqual(len(msg.repeated_nested_message), 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testAddWrongRepeatedNestedField_proto3"><code class="name flex">
<span>def <span class="ident">testAddWrongRepeatedNestedField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAddWrongRepeatedNestedField(self, message_module):
  msg = message_module.TestAllTypes()
  try:
    msg.repeated_nested_message.add(&#39;wrong&#39;)
  except TypeError:
    pass
  try:
    msg.repeated_nested_message.add(value_field=&#39;wrong&#39;)
  except ValueError:
    pass
  self.assertEqual(len(msg.repeated_nested_message), 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testAppendRepeatedCompositeField_proto2"><code class="name flex">
<span>def <span class="ident">testAppendRepeatedCompositeField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAppendRepeatedCompositeField(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_nested_message.append(
      message_module.TestAllTypes.NestedMessage(bb=1))
  nested = message_module.TestAllTypes.NestedMessage(bb=2)
  msg.repeated_nested_message.append(nested)
  try:
    msg.repeated_nested_message.append(1)
  except TypeError:
    pass
  self.assertEqual(2, len(msg.repeated_nested_message))
  self.assertEqual([1, 2],
                   [m.bb for m in msg.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testAppendRepeatedCompositeField_proto3"><code class="name flex">
<span>def <span class="ident">testAppendRepeatedCompositeField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAppendRepeatedCompositeField(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_nested_message.append(
      message_module.TestAllTypes.NestedMessage(bb=1))
  nested = message_module.TestAllTypes.NestedMessage(bb=2)
  msg.repeated_nested_message.append(nested)
  try:
    msg.repeated_nested_message.append(1)
  except TypeError:
    pass
  self.assertEqual(2, len(msg.repeated_nested_message))
  self.assertEqual([1, 2],
                   [m.bb for m in msg.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testAssignByteStringToUnicodeField_proto2"><code class="name flex">
<span>def <span class="ident">testAssignByteStringToUnicodeField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigning a byte string to a string field should result
in the value being converted to a Unicode string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssignByteStringToUnicodeField(self, message_module):
  &#34;&#34;&#34;Assigning a byte string to a string field should result
  in the value being converted to a Unicode string.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  m.optional_string = str(&#39;&#39;)
  self.assertIsInstance(m.optional_string, six.text_type)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testAssignByteStringToUnicodeField_proto3"><code class="name flex">
<span>def <span class="ident">testAssignByteStringToUnicodeField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigning a byte string to a string field should result
in the value being converted to a Unicode string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssignByteStringToUnicodeField(self, message_module):
  &#34;&#34;&#34;Assigning a byte string to a string field should result
  in the value being converted to a Unicode string.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  m.optional_string = str(&#39;&#39;)
  self.assertIsInstance(m.optional_string, six.text_type)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testBadUtf8String_proto2"><code class="name flex">
<span>def <span class="ident">testBadUtf8String_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testBadUtf8String(self, message_module):
  if api_implementation.Type() != &#39;python&#39;:
    self.skipTest(&#34;Skipping testBadUtf8String, currently only the python &#34;
                  &#34;api implementation raises UnicodeDecodeError when a &#34;
                  &#34;string field contains bad utf-8.&#34;)
  bad_utf8_data = test_util.GoldenFileData(&#39;bad_utf8_string&#39;)
  with self.assertRaises(UnicodeDecodeError) as context:
    message_module.TestAllTypes.FromString(bad_utf8_data)
  self.assertIn(&#39;TestAllTypes.optional_string&#39;, str(context.exception))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testBadUtf8String_proto3"><code class="name flex">
<span>def <span class="ident">testBadUtf8String_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testBadUtf8String(self, message_module):
  if api_implementation.Type() != &#39;python&#39;:
    self.skipTest(&#34;Skipping testBadUtf8String, currently only the python &#34;
                  &#34;api implementation raises UnicodeDecodeError when a &#34;
                  &#34;string field contains bad utf-8.&#34;)
  bad_utf8_data = test_util.GoldenFileData(&#39;bad_utf8_string&#39;)
  with self.assertRaises(UnicodeDecodeError) as context:
    message_module.TestAllTypes.FromString(bad_utf8_data)
  self.assertIn(&#39;TestAllTypes.optional_string&#39;, str(context.exception))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testDeterminismParameters_proto2"><code class="name flex">
<span>def <span class="ident">testDeterminismParameters_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testDeterminismParameters(self, message_module):
  # This message is always deterministically serialized, even if determinism
  # is disabled, so we can use it to verify that all the determinism
  # parameters work correctly.
  golden_data = (b&#39;\xe2\x02\nOne string&#39;
                 b&#39;\xe2\x02\nTwo string&#39;
                 b&#39;\xe2\x02\nRed string&#39;
                 b&#39;\xe2\x02\x0bBlue string&#39;)
  golden_message = message_module.TestAllTypes()
  golden_message.repeated_string.extend([
      &#39;One string&#39;,
      &#39;Two string&#39;,
      &#39;Red string&#39;,
      &#39;Blue string&#39;,
  ])
  self.assertEqual(golden_data,
                   golden_message.SerializeToString(deterministic=None))
  self.assertEqual(golden_data,
                   golden_message.SerializeToString(deterministic=False))
  self.assertEqual(golden_data,
                   golden_message.SerializeToString(deterministic=True))

  class BadArgError(Exception):
    pass

  class BadArg(object):

    def __nonzero__(self):
      raise BadArgError()

    def __bool__(self):
      raise BadArgError()

  with self.assertRaises(BadArgError):
    golden_message.SerializeToString(deterministic=BadArg())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testDeterminismParameters_proto3"><code class="name flex">
<span>def <span class="ident">testDeterminismParameters_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testDeterminismParameters(self, message_module):
  # This message is always deterministically serialized, even if determinism
  # is disabled, so we can use it to verify that all the determinism
  # parameters work correctly.
  golden_data = (b&#39;\xe2\x02\nOne string&#39;
                 b&#39;\xe2\x02\nTwo string&#39;
                 b&#39;\xe2\x02\nRed string&#39;
                 b&#39;\xe2\x02\x0bBlue string&#39;)
  golden_message = message_module.TestAllTypes()
  golden_message.repeated_string.extend([
      &#39;One string&#39;,
      &#39;Two string&#39;,
      &#39;Red string&#39;,
      &#39;Blue string&#39;,
  ])
  self.assertEqual(golden_data,
                   golden_message.SerializeToString(deterministic=None))
  self.assertEqual(golden_data,
                   golden_message.SerializeToString(deterministic=False))
  self.assertEqual(golden_data,
                   golden_message.SerializeToString(deterministic=True))

  class BadArgError(Exception):
    pass

  class BadArg(object):

    def __nonzero__(self):
      raise BadArgError()

    def __bool__(self):
      raise BadArgError()

  with self.assertRaises(BadArgError):
    golden_message.SerializeToString(deterministic=BadArg())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithIterable_proto2"><code class="name flex">
<span>def <span class="ident">testExtendFloatWithIterable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated float fields with iterable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendFloatWithIterable(self, message_module):
  &#34;&#34;&#34;Test extending repeated float fields with iterable.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([]))
  self.assertSequenceEqual([], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([0.0]))
  self.assertSequenceEqual([0.0], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([1.0, 2.0]))
  self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([3.0, 4.0]))
  self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithIterable_proto3"><code class="name flex">
<span>def <span class="ident">testExtendFloatWithIterable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated float fields with iterable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendFloatWithIterable(self, message_module):
  &#34;&#34;&#34;Test extending repeated float fields with iterable.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([]))
  self.assertSequenceEqual([], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([0.0]))
  self.assertSequenceEqual([0.0], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([1.0, 2.0]))
  self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
  m.repeated_float.extend(MessageTest.TestIterable([3.0, 4.0]))
  self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithNothing_proto2"><code class="name flex">
<span>def <span class="ident">testExtendFloatWithNothing_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test no-ops extending repeated float fields.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendFloatWithNothing(self, message_module):
  &#34;&#34;&#34;Test no-ops extending repeated float fields.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_float)

  # TODO(ptucker): Deprecate this behavior. b/18413862
  for falsy_value in MessageTest.FALSY_VALUES:
    m.repeated_float.extend(falsy_value)
    self.assertSequenceEqual([], m.repeated_float)

  m.repeated_float.extend([])
  self.assertSequenceEqual([], m.repeated_float)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithNothing_proto3"><code class="name flex">
<span>def <span class="ident">testExtendFloatWithNothing_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test no-ops extending repeated float fields.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendFloatWithNothing(self, message_module):
  &#34;&#34;&#34;Test no-ops extending repeated float fields.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_float)

  # TODO(ptucker): Deprecate this behavior. b/18413862
  for falsy_value in MessageTest.FALSY_VALUES:
    m.repeated_float.extend(falsy_value)
    self.assertSequenceEqual([], m.repeated_float)

  m.repeated_float.extend([])
  self.assertSequenceEqual([], m.repeated_float)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithPythonList_proto2"><code class="name flex">
<span>def <span class="ident">testExtendFloatWithPythonList_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated float fields with python lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendFloatWithPythonList(self, message_module):
  &#34;&#34;&#34;Test extending repeated float fields with python lists.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_float)
  m.repeated_float.extend([0.0])
  self.assertSequenceEqual([0.0], m.repeated_float)
  m.repeated_float.extend([1.0, 2.0])
  self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
  m.repeated_float.extend([3.0, 4.0])
  self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithPythonList_proto3"><code class="name flex">
<span>def <span class="ident">testExtendFloatWithPythonList_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated float fields with python lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendFloatWithPythonList(self, message_module):
  &#34;&#34;&#34;Test extending repeated float fields with python lists.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_float)
  m.repeated_float.extend([0.0])
  self.assertSequenceEqual([0.0], m.repeated_float)
  m.repeated_float.extend([1.0, 2.0])
  self.assertSequenceEqual([0.0, 1.0, 2.0], m.repeated_float)
  m.repeated_float.extend([3.0, 4.0])
  self.assertSequenceEqual([0.0, 1.0, 2.0, 3.0, 4.0], m.repeated_float)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithIterable_proto2"><code class="name flex">
<span>def <span class="ident">testExtendInt32WithIterable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated int32 fields with iterable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendInt32WithIterable(self, message_module):
  &#34;&#34;&#34;Test extending repeated int32 fields with iterable.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([]))
  self.assertSequenceEqual([], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([0]))
  self.assertSequenceEqual([0], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([1, 2]))
  self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([3, 4]))
  self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithIterable_proto3"><code class="name flex">
<span>def <span class="ident">testExtendInt32WithIterable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated int32 fields with iterable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendInt32WithIterable(self, message_module):
  &#34;&#34;&#34;Test extending repeated int32 fields with iterable.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([]))
  self.assertSequenceEqual([], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([0]))
  self.assertSequenceEqual([0], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([1, 2]))
  self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
  m.repeated_int32.extend(MessageTest.TestIterable([3, 4]))
  self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithNothing_proto2"><code class="name flex">
<span>def <span class="ident">testExtendInt32WithNothing_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test no-ops extending repeated int32 fields.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendInt32WithNothing(self, message_module):
  &#34;&#34;&#34;Test no-ops extending repeated int32 fields.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_int32)

  # TODO(ptucker): Deprecate this behavior. b/18413862
  for falsy_value in MessageTest.FALSY_VALUES:
    m.repeated_int32.extend(falsy_value)
    self.assertSequenceEqual([], m.repeated_int32)

  m.repeated_int32.extend([])
  self.assertSequenceEqual([], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithNothing_proto3"><code class="name flex">
<span>def <span class="ident">testExtendInt32WithNothing_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test no-ops extending repeated int32 fields.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendInt32WithNothing(self, message_module):
  &#34;&#34;&#34;Test no-ops extending repeated int32 fields.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_int32)

  # TODO(ptucker): Deprecate this behavior. b/18413862
  for falsy_value in MessageTest.FALSY_VALUES:
    m.repeated_int32.extend(falsy_value)
    self.assertSequenceEqual([], m.repeated_int32)

  m.repeated_int32.extend([])
  self.assertSequenceEqual([], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithPythonList_proto2"><code class="name flex">
<span>def <span class="ident">testExtendInt32WithPythonList_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated int32 fields with python lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendInt32WithPythonList(self, message_module):
  &#34;&#34;&#34;Test extending repeated int32 fields with python lists.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_int32)
  m.repeated_int32.extend([0])
  self.assertSequenceEqual([0], m.repeated_int32)
  m.repeated_int32.extend([1, 2])
  self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
  m.repeated_int32.extend([3, 4])
  self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithPythonList_proto3"><code class="name flex">
<span>def <span class="ident">testExtendInt32WithPythonList_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated int32 fields with python lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendInt32WithPythonList(self, message_module):
  &#34;&#34;&#34;Test extending repeated int32 fields with python lists.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_int32)
  m.repeated_int32.extend([0])
  self.assertSequenceEqual([0], m.repeated_int32)
  m.repeated_int32.extend([1, 2])
  self.assertSequenceEqual([0, 1, 2], m.repeated_int32)
  m.repeated_int32.extend([3, 4])
  self.assertSequenceEqual([0, 1, 2, 3, 4], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendShouldNotSwallowExceptions_proto2"><code class="name flex">
<span>def <span class="ident">testExtendShouldNotSwallowExceptions_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>This didn't use to work in the v2 C++ implementation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendShouldNotSwallowExceptions(self, message_module):
  &#34;&#34;&#34;This didn&#39;t use to work in the v2 C++ implementation.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  with self.assertRaises(NameError) as _:
    m.repeated_int32.extend(a for i in range(10))  # pylint: disable=undefined-variable
  with self.assertRaises(NameError) as _:
    m.repeated_nested_enum.extend(
        a for i in range(10))  # pylint: disable=undefined-variable</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendShouldNotSwallowExceptions_proto3"><code class="name flex">
<span>def <span class="ident">testExtendShouldNotSwallowExceptions_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>This didn't use to work in the v2 C++ implementation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendShouldNotSwallowExceptions(self, message_module):
  &#34;&#34;&#34;This didn&#39;t use to work in the v2 C++ implementation.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  with self.assertRaises(NameError) as _:
    m.repeated_int32.extend(a for i in range(10))  # pylint: disable=undefined-variable
  with self.assertRaises(NameError) as _:
    m.repeated_nested_enum.extend(
        a for i in range(10))  # pylint: disable=undefined-variable</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithIterable_proto2"><code class="name flex">
<span>def <span class="ident">testExtendStringWithIterable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated string fields with iterable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithIterable(self, message_module):
  &#34;&#34;&#34;Test extending repeated string fields with iterable.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([]))
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([&#39;&#39;]))
  self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([&#39;1&#39;, &#39;2&#39;]))
  self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([&#39;3&#39;, &#39;4&#39;]))
  self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithIterable_proto3"><code class="name flex">
<span>def <span class="ident">testExtendStringWithIterable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated string fields with iterable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithIterable(self, message_module):
  &#34;&#34;&#34;Test extending repeated string fields with iterable.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([]))
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([&#39;&#39;]))
  self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([&#39;1&#39;, &#39;2&#39;]))
  self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;], m.repeated_string)
  m.repeated_string.extend(MessageTest.TestIterable([&#39;3&#39;, &#39;4&#39;]))
  self.assertSequenceEqual([&#39;&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithNothing_proto2"><code class="name flex">
<span>def <span class="ident">testExtendStringWithNothing_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test no-ops extending repeated string fields.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithNothing(self, message_module):
  &#34;&#34;&#34;Test no-ops extending repeated string fields.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)

  # TODO(ptucker): Deprecate this behavior. b/18413862
  for falsy_value in MessageTest.FALSY_VALUES:
    m.repeated_string.extend(falsy_value)
    self.assertSequenceEqual([], m.repeated_string)

  m.repeated_string.extend([])
  self.assertSequenceEqual([], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithNothing_proto3"><code class="name flex">
<span>def <span class="ident">testExtendStringWithNothing_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test no-ops extending repeated string fields.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithNothing(self, message_module):
  &#34;&#34;&#34;Test no-ops extending repeated string fields.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)

  # TODO(ptucker): Deprecate this behavior. b/18413862
  for falsy_value in MessageTest.FALSY_VALUES:
    m.repeated_string.extend(falsy_value)
    self.assertSequenceEqual([], m.repeated_string)

  m.repeated_string.extend([])
  self.assertSequenceEqual([], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithPythonList_proto2"><code class="name flex">
<span>def <span class="ident">testExtendStringWithPythonList_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated string fields with python lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithPythonList(self, message_module):
  &#34;&#34;&#34;Test extending repeated string fields with python lists.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend([&#39;&#39;])
  self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
  m.repeated_string.extend([&#39;11&#39;, &#39;22&#39;])
  self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;], m.repeated_string)
  m.repeated_string.extend([&#39;33&#39;, &#39;44&#39;])
  self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;, &#39;33&#39;, &#39;44&#39;], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithPythonList_proto3"><code class="name flex">
<span>def <span class="ident">testExtendStringWithPythonList_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated string fields with python lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithPythonList(self, message_module):
  &#34;&#34;&#34;Test extending repeated string fields with python lists.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend([&#39;&#39;])
  self.assertSequenceEqual([&#39;&#39;], m.repeated_string)
  m.repeated_string.extend([&#39;11&#39;, &#39;22&#39;])
  self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;], m.repeated_string)
  m.repeated_string.extend([&#39;33&#39;, &#39;44&#39;])
  self.assertSequenceEqual([&#39;&#39;, &#39;11&#39;, &#39;22&#39;, &#39;33&#39;, &#39;44&#39;], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithString_proto2"><code class="name flex">
<span>def <span class="ident">testExtendStringWithString_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated string fields with characters from a string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithString(self, message_module):
  &#34;&#34;&#34;Test extending repeated string fields with characters from a string.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend(&#39;abc&#39;)
  self.assertSequenceEqual([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtendStringWithString_proto3"><code class="name flex">
<span>def <span class="ident">testExtendStringWithString_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Test extending repeated string fields with characters from a string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtendStringWithString(self, message_module):
  &#34;&#34;&#34;Test extending repeated string fields with characters from a string.&#34;&#34;&#34;
  m = message_module.TestAllTypes()
  self.assertSequenceEqual([], m.repeated_string)
  m.repeated_string.extend(&#39;abc&#39;)
  self.assertSequenceEqual([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], m.repeated_string)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtremeDoubleValues_proto2"><code class="name flex">
<span>def <span class="ident">testExtremeDoubleValues_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtremeDoubleValues(self, message_module):
  message = message_module.TestAllTypes()

  # Most positive exponent, no significand bits set.
  kMostPosExponentNoSigBits = math.pow(2, 1023)
  message.optional_double = kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostPosExponentNoSigBits)

  # Most positive exponent, one significand bit set.
  kMostPosExponentOneSigBit = 1.5 * math.pow(2, 1023)
  message.optional_double = kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostPosExponentOneSigBit)

  # Repeat last two cases with values of same magnitude, but negative.
  message.optional_double = -kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostPosExponentNoSigBits)

  message.optional_double = -kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostPosExponentOneSigBit)

  # Most negative exponent, no significand bits set.
  kMostNegExponentNoSigBits = math.pow(2, -1023)
  message.optional_double = kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostNegExponentNoSigBits)

  # Most negative exponent, one significand bit set.
  kMostNegExponentOneSigBit = 1.5 * math.pow(2, -1023)
  message.optional_double = kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostNegExponentOneSigBit)

  # Repeat last two cases with values of the same magnitude, but negative.
  message.optional_double = -kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostNegExponentNoSigBits)

  message.optional_double = -kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostNegExponentOneSigBit)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtremeDoubleValues_proto3"><code class="name flex">
<span>def <span class="ident">testExtremeDoubleValues_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtremeDoubleValues(self, message_module):
  message = message_module.TestAllTypes()

  # Most positive exponent, no significand bits set.
  kMostPosExponentNoSigBits = math.pow(2, 1023)
  message.optional_double = kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostPosExponentNoSigBits)

  # Most positive exponent, one significand bit set.
  kMostPosExponentOneSigBit = 1.5 * math.pow(2, 1023)
  message.optional_double = kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostPosExponentOneSigBit)

  # Repeat last two cases with values of same magnitude, but negative.
  message.optional_double = -kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostPosExponentNoSigBits)

  message.optional_double = -kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostPosExponentOneSigBit)

  # Most negative exponent, no significand bits set.
  kMostNegExponentNoSigBits = math.pow(2, -1023)
  message.optional_double = kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostNegExponentNoSigBits)

  # Most negative exponent, one significand bit set.
  kMostNegExponentOneSigBit = 1.5 * math.pow(2, -1023)
  message.optional_double = kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == kMostNegExponentOneSigBit)

  # Repeat last two cases with values of the same magnitude, but negative.
  message.optional_double = -kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostNegExponentNoSigBits)

  message.optional_double = -kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_double == -kMostNegExponentOneSigBit)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtremeFloatValues_proto2"><code class="name flex">
<span>def <span class="ident">testExtremeFloatValues_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtremeFloatValues(self, message_module):
  message = message_module.TestAllTypes()

  # Most positive exponent, no significand bits set.
  kMostPosExponentNoSigBits = math.pow(2, 127)
  message.optional_float = kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostPosExponentNoSigBits)

  # Most positive exponent, one significand bit set.
  kMostPosExponentOneSigBit = 1.5 * math.pow(2, 127)
  message.optional_float = kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostPosExponentOneSigBit)

  # Repeat last two cases with values of same magnitude, but negative.
  message.optional_float = -kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostPosExponentNoSigBits)

  message.optional_float = -kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostPosExponentOneSigBit)

  # Most negative exponent, no significand bits set.
  kMostNegExponentNoSigBits = math.pow(2, -127)
  message.optional_float = kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostNegExponentNoSigBits)

  # Most negative exponent, one significand bit set.
  kMostNegExponentOneSigBit = 1.5 * math.pow(2, -127)
  message.optional_float = kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostNegExponentOneSigBit)

  # Repeat last two cases with values of the same magnitude, but negative.
  message.optional_float = -kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostNegExponentNoSigBits)

  message.optional_float = -kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostNegExponentOneSigBit)

  # Max 4 bytes float value
  max_float = float.fromhex(&#39;0x1.fffffep+127&#39;)
  message.optional_float = max_float
  self.assertAlmostEqual(message.optional_float, max_float)
  serialized_data = message.SerializeToString()
  message.ParseFromString(serialized_data)
  self.assertAlmostEqual(message.optional_float, max_float)

  # Test set double to float field.
  message.optional_float = 3.4028235e+39
  self.assertEqual(message.optional_float, float(&#39;inf&#39;))
  serialized_data = message.SerializeToString()
  message.ParseFromString(serialized_data)
  self.assertEqual(message.optional_float, float(&#39;inf&#39;))

  message.optional_float = -3.4028235e+39
  self.assertEqual(message.optional_float, float(&#39;-inf&#39;))

  message.optional_float = 1.4028235e-39
  self.assertAlmostEqual(message.optional_float, 1.4028235e-39)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testExtremeFloatValues_proto3"><code class="name flex">
<span>def <span class="ident">testExtremeFloatValues_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtremeFloatValues(self, message_module):
  message = message_module.TestAllTypes()

  # Most positive exponent, no significand bits set.
  kMostPosExponentNoSigBits = math.pow(2, 127)
  message.optional_float = kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostPosExponentNoSigBits)

  # Most positive exponent, one significand bit set.
  kMostPosExponentOneSigBit = 1.5 * math.pow(2, 127)
  message.optional_float = kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostPosExponentOneSigBit)

  # Repeat last two cases with values of same magnitude, but negative.
  message.optional_float = -kMostPosExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostPosExponentNoSigBits)

  message.optional_float = -kMostPosExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostPosExponentOneSigBit)

  # Most negative exponent, no significand bits set.
  kMostNegExponentNoSigBits = math.pow(2, -127)
  message.optional_float = kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostNegExponentNoSigBits)

  # Most negative exponent, one significand bit set.
  kMostNegExponentOneSigBit = 1.5 * math.pow(2, -127)
  message.optional_float = kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == kMostNegExponentOneSigBit)

  # Repeat last two cases with values of the same magnitude, but negative.
  message.optional_float = -kMostNegExponentNoSigBits
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostNegExponentNoSigBits)

  message.optional_float = -kMostNegExponentOneSigBit
  message.ParseFromString(message.SerializeToString())
  self.assertTrue(message.optional_float == -kMostNegExponentOneSigBit)

  # Max 4 bytes float value
  max_float = float.fromhex(&#39;0x1.fffffep+127&#39;)
  message.optional_float = max_float
  self.assertAlmostEqual(message.optional_float, max_float)
  serialized_data = message.SerializeToString()
  message.ParseFromString(serialized_data)
  self.assertAlmostEqual(message.optional_float, max_float)

  # Test set double to float field.
  message.optional_float = 3.4028235e+39
  self.assertEqual(message.optional_float, float(&#39;inf&#39;))
  serialized_data = message.SerializeToString()
  message.ParseFromString(serialized_data)
  self.assertEqual(message.optional_float, float(&#39;inf&#39;))

  message.optional_float = -3.4028235e+39
  self.assertEqual(message.optional_float, float(&#39;-inf&#39;))

  message.optional_float = 1.4028235e-39
  self.assertAlmostEqual(message.optional_float, 1.4028235e-39)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testFloatPrinting_proto2"><code class="name flex">
<span>def <span class="ident">testFloatPrinting_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFloatPrinting(self, message_module):
  message = message_module.TestAllTypes()
  message.optional_float = 2.0
  self.assertEqual(str(message), &#39;optional_float: 2.0\n&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testFloatPrinting_proto3"><code class="name flex">
<span>def <span class="ident">testFloatPrinting_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFloatPrinting(self, message_module):
  message = message_module.TestAllTypes()
  message.optional_float = 2.0
  self.assertEqual(str(message), &#39;optional_float: 2.0\n&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testGoldenMessage_proto2"><code class="name flex">
<span>def <span class="ident">testGoldenMessage_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testGoldenMessage(self, message_module):
  # Proto3 doesn&#39;t have the &#34;default_foo&#34; members or foreign enums,
  # and doesn&#39;t preserve unknown fields, so for proto3 we use a golden
  # message that doesn&#39;t have these fields set.
  if message_module is unittest_pb2:
    golden_data = test_util.GoldenFileData(
        &#39;golden_message_oneof_implemented&#39;)
  else:
    golden_data = test_util.GoldenFileData(&#39;golden_message_proto3&#39;)

  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  if message_module is unittest_pb2:
    test_util.ExpectAllFieldsSet(self, golden_message)
  self.assertEqual(golden_data, golden_message.SerializeToString())
  golden_copy = copy.deepcopy(golden_message)
  self.assertEqual(golden_data, golden_copy.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testGoldenMessage_proto3"><code class="name flex">
<span>def <span class="ident">testGoldenMessage_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testGoldenMessage(self, message_module):
  # Proto3 doesn&#39;t have the &#34;default_foo&#34; members or foreign enums,
  # and doesn&#39;t preserve unknown fields, so for proto3 we use a golden
  # message that doesn&#39;t have these fields set.
  if message_module is unittest_pb2:
    golden_data = test_util.GoldenFileData(
        &#39;golden_message_oneof_implemented&#39;)
  else:
    golden_data = test_util.GoldenFileData(&#39;golden_message_proto3&#39;)

  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  if message_module is unittest_pb2:
    test_util.ExpectAllFieldsSet(self, golden_message)
  self.assertEqual(golden_data, golden_message.SerializeToString())
  golden_copy = copy.deepcopy(golden_message)
  self.assertEqual(golden_data, golden_copy.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testGoldenPackedMessage_proto2"><code class="name flex">
<span>def <span class="ident">testGoldenPackedMessage_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testGoldenPackedMessage(self, message_module):
  golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
  golden_message = message_module.TestPackedTypes()
  parsed_bytes = golden_message.ParseFromString(golden_data)
  all_set = message_module.TestPackedTypes()
  test_util.SetAllPackedFields(all_set)
  self.assertEqual(parsed_bytes, len(golden_data))
  self.assertEqual(all_set, golden_message)
  self.assertEqual(golden_data, all_set.SerializeToString())
  golden_copy = copy.deepcopy(golden_message)
  self.assertEqual(golden_data, golden_copy.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testGoldenPackedMessage_proto3"><code class="name flex">
<span>def <span class="ident">testGoldenPackedMessage_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testGoldenPackedMessage(self, message_module):
  golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
  golden_message = message_module.TestPackedTypes()
  parsed_bytes = golden_message.ParseFromString(golden_data)
  all_set = message_module.TestPackedTypes()
  test_util.SetAllPackedFields(all_set)
  self.assertEqual(parsed_bytes, len(golden_data))
  self.assertEqual(all_set, golden_message)
  self.assertEqual(golden_data, all_set.SerializeToString())
  golden_copy = copy.deepcopy(golden_message)
  self.assertEqual(golden_data, golden_copy.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testHasFieldOnRepeatedField_proto2"><code class="name flex">
<span>def <span class="ident">testHasFieldOnRepeatedField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Using HasField on a repeated field should raise an exception.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testHasFieldOnRepeatedField(self, message_module):
  &#34;&#34;&#34;Using HasField on a repeated field should raise an exception.
  &#34;&#34;&#34;
  m = message_module.TestAllTypes()
  with self.assertRaises(ValueError) as _:
    m.HasField(&#39;repeated_int32&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testHasFieldOnRepeatedField_proto3"><code class="name flex">
<span>def <span class="ident">testHasFieldOnRepeatedField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Using HasField on a repeated field should raise an exception.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testHasFieldOnRepeatedField(self, message_module):
  &#34;&#34;&#34;Using HasField on a repeated field should raise an exception.
  &#34;&#34;&#34;
  m = message_module.TestAllTypes()
  with self.assertRaises(ValueError) as _:
    m.HasField(&#39;repeated_int32&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testHighPrecisionFloatPrinting_proto2"><code class="name flex">
<span>def <span class="ident">testHighPrecisionFloatPrinting_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testHighPrecisionFloatPrinting(self, message_module):
  message = message_module.TestAllTypes()
  message.optional_double = 0.12345678912345678
  if sys.version_info &gt;= (3,):
    self.assertEqual(str(message), &#39;optional_double: 0.12345678912345678\n&#39;)
  else:
    self.assertEqual(str(message), &#39;optional_double: 0.123456789123\n&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testHighPrecisionFloatPrinting_proto3"><code class="name flex">
<span>def <span class="ident">testHighPrecisionFloatPrinting_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testHighPrecisionFloatPrinting(self, message_module):
  message = message_module.TestAllTypes()
  message.optional_double = 0.12345678912345678
  if sys.version_info &gt;= (3,):
    self.assertEqual(str(message), &#39;optional_double: 0.12345678912345678\n&#39;)
  else:
    self.assertEqual(str(message), &#39;optional_double: 0.123456789123\n&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testInsertRepeatedCompositeField_proto2"><code class="name flex">
<span>def <span class="ident">testInsertRepeatedCompositeField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInsertRepeatedCompositeField(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_nested_message.insert(
      -1, message_module.TestAllTypes.NestedMessage(bb=1))
  sub_msg = msg.repeated_nested_message[0]
  msg.repeated_nested_message.insert(
      0, message_module.TestAllTypes.NestedMessage(bb=2))
  msg.repeated_nested_message.insert(
      99, message_module.TestAllTypes.NestedMessage(bb=3))
  msg.repeated_nested_message.insert(
      -2, message_module.TestAllTypes.NestedMessage(bb=-1))
  msg.repeated_nested_message.insert(
      -1000, message_module.TestAllTypes.NestedMessage(bb=-1000))
  try:
    msg.repeated_nested_message.insert(1, 999)
  except TypeError:
    pass
  self.assertEqual(5, len(msg.repeated_nested_message))
  self.assertEqual([-1000, 2, -1, 1, 3],
                   [m.bb for m in msg.repeated_nested_message])
  self.assertEqual(str(msg),
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: -1000\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: 2\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: -1\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: 1\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: 3\n&#39;
                   &#39;}\n&#39;)
  self.assertEqual(sub_msg.bb, 1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testInsertRepeatedCompositeField_proto3"><code class="name flex">
<span>def <span class="ident">testInsertRepeatedCompositeField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInsertRepeatedCompositeField(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_nested_message.insert(
      -1, message_module.TestAllTypes.NestedMessage(bb=1))
  sub_msg = msg.repeated_nested_message[0]
  msg.repeated_nested_message.insert(
      0, message_module.TestAllTypes.NestedMessage(bb=2))
  msg.repeated_nested_message.insert(
      99, message_module.TestAllTypes.NestedMessage(bb=3))
  msg.repeated_nested_message.insert(
      -2, message_module.TestAllTypes.NestedMessage(bb=-1))
  msg.repeated_nested_message.insert(
      -1000, message_module.TestAllTypes.NestedMessage(bb=-1000))
  try:
    msg.repeated_nested_message.insert(1, 999)
  except TypeError:
    pass
  self.assertEqual(5, len(msg.repeated_nested_message))
  self.assertEqual([-1000, 2, -1, 1, 3],
                   [m.bb for m in msg.repeated_nested_message])
  self.assertEqual(str(msg),
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: -1000\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: 2\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: -1\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: 1\n&#39;
                   &#39;}\n&#39;
                   &#39;repeated_nested_message {\n&#39;
                   &#39;  bb: 3\n&#39;
                   &#39;}\n&#39;)
  self.assertEqual(sub_msg.bb, 1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testLongValuedSlice_proto2"><code class="name flex">
<span>def <span class="ident">testLongValuedSlice_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>It should be possible to use long-valued indicies in slices</p>
<p>This didn't used to work in the v2 C++ implementation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testLongValuedSlice(self, message_module):
  &#34;&#34;&#34;It should be possible to use long-valued indicies in slices

  This didn&#39;t used to work in the v2 C++ implementation.
  &#34;&#34;&#34;
  m = message_module.TestAllTypes()

  # Repeated scalar
  m.repeated_int32.append(1)
  sl = m.repeated_int32[long(0):long(len(m.repeated_int32))]
  self.assertEqual(len(m.repeated_int32), len(sl))

  # Repeated composite
  m.repeated_nested_message.add().bb = 3
  sl = m.repeated_nested_message[long(0):long(len(m.repeated_nested_message))]
  self.assertEqual(len(m.repeated_nested_message), len(sl))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testLongValuedSlice_proto3"><code class="name flex">
<span>def <span class="ident">testLongValuedSlice_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>It should be possible to use long-valued indicies in slices</p>
<p>This didn't used to work in the v2 C++ implementation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testLongValuedSlice(self, message_module):
  &#34;&#34;&#34;It should be possible to use long-valued indicies in slices

  This didn&#39;t used to work in the v2 C++ implementation.
  &#34;&#34;&#34;
  m = message_module.TestAllTypes()

  # Repeated scalar
  m.repeated_int32.append(1)
  sl = m.repeated_int32[long(0):long(len(m.repeated_int32))]
  self.assertEqual(len(m.repeated_int32), len(sl))

  # Repeated composite
  m.repeated_nested_message.add().bb = 3
  sl = m.repeated_nested_message[long(0):long(len(m.repeated_nested_message))]
  self.assertEqual(len(m.repeated_nested_message), len(sl))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromEmpty_proto2"><code class="name flex">
<span>def <span class="ident">testMergeFromEmpty_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromEmpty(self, message_module):
  m1 = message_module.TestAllTypes()
  # Cpp extension will lazily create a sub message which is immutable.
  self.assertEqual(0, m1.optional_nested_message.bb)
  self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))
  # Make sure the sub message is still immutable after merge from empty.
  m1.MergeFromString(b&#39;&#39;)  # field state should not change
  self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromEmpty_proto3"><code class="name flex">
<span>def <span class="ident">testMergeFromEmpty_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromEmpty(self, message_module):
  m1 = message_module.TestAllTypes()
  # Cpp extension will lazily create a sub message which is immutable.
  self.assertEqual(0, m1.optional_nested_message.bb)
  self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))
  # Make sure the sub message is still immutable after merge from empty.
  m1.MergeFromString(b&#39;&#39;)  # field state should not change
  self.assertFalse(m1.HasField(&#39;optional_nested_message&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromRepeatedField_proto2"><code class="name flex">
<span>def <span class="ident">testMergeFromRepeatedField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromRepeatedField(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_int32.append(1)
  msg.repeated_int32.append(3)
  msg.repeated_nested_message.add(bb=1)
  msg.repeated_nested_message.add(bb=2)
  other_msg = message_module.TestAllTypes()
  other_msg.repeated_nested_message.add(bb=3)
  other_msg.repeated_nested_message.add(bb=4)
  other_msg.repeated_int32.append(5)
  other_msg.repeated_int32.append(7)

  msg.repeated_int32.MergeFrom(other_msg.repeated_int32)
  self.assertEqual(4, len(msg.repeated_int32))

  msg.repeated_nested_message.MergeFrom(other_msg.repeated_nested_message)
  self.assertEqual([1, 2, 3, 4],
                   [m.bb for m in msg.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromRepeatedField_proto3"><code class="name flex">
<span>def <span class="ident">testMergeFromRepeatedField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromRepeatedField(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_int32.append(1)
  msg.repeated_int32.append(3)
  msg.repeated_nested_message.add(bb=1)
  msg.repeated_nested_message.add(bb=2)
  other_msg = message_module.TestAllTypes()
  other_msg.repeated_nested_message.add(bb=3)
  other_msg.repeated_nested_message.add(bb=4)
  other_msg.repeated_int32.append(5)
  other_msg.repeated_int32.append(7)

  msg.repeated_int32.MergeFrom(other_msg.repeated_int32)
  self.assertEqual(4, len(msg.repeated_int32))

  msg.repeated_nested_message.MergeFrom(other_msg.repeated_nested_message)
  self.assertEqual([1, 2, 3, 4],
                   [m.bb for m in msg.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewIsPy2Error_proto2"><code class="name flex">
<span>def <span class="ident">testMergeFromStringUsingMemoryViewIsPy2Error_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(six.PY3, &#39;memoryview is supported by py3&#39;)
def testMergeFromStringUsingMemoryViewIsPy2Error(self, message_module):
  memview = memoryview(b&#39;&#39;)
  with self.assertRaises(TypeError):
    message_module.TestAllTypes.FromString(memview)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewIsPy2Error_proto3"><code class="name flex">
<span>def <span class="ident">testMergeFromStringUsingMemoryViewIsPy2Error_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(six.PY3, &#39;memoryview is supported by py3&#39;)
def testMergeFromStringUsingMemoryViewIsPy2Error(self, message_module):
  memview = memoryview(b&#39;&#39;)
  with self.assertRaises(TypeError):
    message_module.TestAllTypes.FromString(memview)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewWorksInPy3_proto2"><code class="name flex">
<span>def <span class="ident">testMergeFromStringUsingMemoryViewWorksInPy3_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(six.PY2, &#39;memoryview objects are not supported on py2&#39;)
def testMergeFromStringUsingMemoryViewWorksInPy3(self, message_module):
  m2 = message_module.TestAllTypes()
  m2.optional_string = &#39;scalar string&#39;
  m2.repeated_string.append(&#39;repeated string&#39;)
  m2.optional_bytes = b&#39;scalar bytes&#39;
  m2.repeated_bytes.append(b&#39;repeated bytes&#39;)

  serialized = m2.SerializeToString()
  memview = memoryview(serialized)
  m1 = message_module.TestAllTypes.FromString(memview)

  self.assertEqual(m1.optional_bytes, b&#39;scalar bytes&#39;)
  self.assertEqual(m1.repeated_bytes, [b&#39;repeated bytes&#39;])
  self.assertEqual(m1.optional_string, &#39;scalar string&#39;)
  self.assertEqual(m1.repeated_string, [&#39;repeated string&#39;])
  # Make sure that the memoryview was correctly converted to bytes, and
  # that a sub-sliced memoryview is not being used.
  self.assertIsInstance(m1.optional_bytes, bytes)
  self.assertIsInstance(m1.repeated_bytes[0], bytes)
  self.assertIsInstance(m1.optional_string, six.text_type)
  self.assertIsInstance(m1.repeated_string[0], six.text_type)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewWorksInPy3_proto3"><code class="name flex">
<span>def <span class="ident">testMergeFromStringUsingMemoryViewWorksInPy3_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(six.PY2, &#39;memoryview objects are not supported on py2&#39;)
def testMergeFromStringUsingMemoryViewWorksInPy3(self, message_module):
  m2 = message_module.TestAllTypes()
  m2.optional_string = &#39;scalar string&#39;
  m2.repeated_string.append(&#39;repeated string&#39;)
  m2.optional_bytes = b&#39;scalar bytes&#39;
  m2.repeated_bytes.append(b&#39;repeated bytes&#39;)

  serialized = m2.SerializeToString()
  memview = memoryview(serialized)
  m1 = message_module.TestAllTypes.FromString(memview)

  self.assertEqual(m1.optional_bytes, b&#39;scalar bytes&#39;)
  self.assertEqual(m1.repeated_bytes, [b&#39;repeated bytes&#39;])
  self.assertEqual(m1.optional_string, &#39;scalar string&#39;)
  self.assertEqual(m1.repeated_string, [&#39;repeated string&#39;])
  # Make sure that the memoryview was correctly converted to bytes, and
  # that a sub-sliced memoryview is not being used.
  self.assertIsInstance(m1.optional_bytes, bytes)
  self.assertIsInstance(m1.repeated_bytes[0], bytes)
  self.assertIsInstance(m1.optional_string, six.text_type)
  self.assertIsInstance(m1.repeated_string[0], six.text_type)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromString_proto2"><code class="name flex">
<span>def <span class="ident">testMergeFromString_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromString(self, message_module):
  m1 = message_module.TestAllTypes()
  m2 = message_module.TestAllTypes()
  # Cpp extension will lazily create a sub message which is immutable.
  self.assertEqual(0, m1.optional_nested_message.bb)
  m2.optional_nested_message.bb = 1
  # Make sure cmessage pointing to a mutable message after merge instead of
  # the lazily created message.
  m1.MergeFromString(m2.SerializeToString())
  self.assertEqual(1, m1.optional_nested_message.bb)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFromString_proto3"><code class="name flex">
<span>def <span class="ident">testMergeFromString_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromString(self, message_module):
  m1 = message_module.TestAllTypes()
  m2 = message_module.TestAllTypes()
  # Cpp extension will lazily create a sub message which is immutable.
  self.assertEqual(0, m1.optional_nested_message.bb)
  m2.optional_nested_message.bb = 1
  # Make sure cmessage pointing to a mutable message after merge instead of
  # the lazily created message.
  m1.MergeFromString(m2.SerializeToString())
  self.assertEqual(1, m1.optional_nested_message.bb)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFrom_proto2"><code class="name flex">
<span>def <span class="ident">testMergeFrom_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFrom(self, message_module):
  m1 = message_module.TestAllTypes()
  m2 = message_module.TestAllTypes()
  # Cpp extension will lazily create a sub message which is immutable.
  nested = m1.optional_nested_message
  self.assertEqual(0, nested.bb)
  m2.optional_nested_message.bb = 1
  # Make sure cmessage pointing to a mutable message after merge instead of
  # the lazily created message.
  m1.MergeFrom(m2)
  self.assertEqual(1, nested.bb)

  # Test more nested sub message.
  msg1 = message_module.NestedTestAllTypes()
  msg2 = message_module.NestedTestAllTypes()
  nested = msg1.child.payload.optional_nested_message
  self.assertEqual(0, nested.bb)
  msg2.child.payload.optional_nested_message.bb = 1
  msg1.MergeFrom(msg2)
  self.assertEqual(1, nested.bb)

  # Test repeated field.
  self.assertEqual(msg1.payload.repeated_nested_message,
                   msg1.payload.repeated_nested_message)
  nested = msg2.payload.repeated_nested_message.add()
  nested.bb = 1
  msg1.MergeFrom(msg2)
  self.assertEqual(1, len(msg1.payload.repeated_nested_message))
  self.assertEqual(1, nested.bb)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testMergeFrom_proto3"><code class="name flex">
<span>def <span class="ident">testMergeFrom_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFrom(self, message_module):
  m1 = message_module.TestAllTypes()
  m2 = message_module.TestAllTypes()
  # Cpp extension will lazily create a sub message which is immutable.
  nested = m1.optional_nested_message
  self.assertEqual(0, nested.bb)
  m2.optional_nested_message.bb = 1
  # Make sure cmessage pointing to a mutable message after merge instead of
  # the lazily created message.
  m1.MergeFrom(m2)
  self.assertEqual(1, nested.bb)

  # Test more nested sub message.
  msg1 = message_module.NestedTestAllTypes()
  msg2 = message_module.NestedTestAllTypes()
  nested = msg1.child.payload.optional_nested_message
  self.assertEqual(0, nested.bb)
  msg2.child.payload.optional_nested_message.bb = 1
  msg1.MergeFrom(msg2)
  self.assertEqual(1, nested.bb)

  # Test repeated field.
  self.assertEqual(msg1.payload.repeated_nested_message,
                   msg1.payload.repeated_nested_message)
  nested = msg2.payload.repeated_nested_message.add()
  nested.bb = 1
  msg1.MergeFrom(msg2)
  self.assertEqual(1, len(msg1.payload.repeated_nested_message))
  self.assertEqual(1, nested.bb)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNegativeInfinityPacked_proto2"><code class="name flex">
<span>def <span class="ident">testNegativeInfinityPacked_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNegativeInfinityPacked(self, message_module):
  golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\xFF&#39;
                 b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
  golden_message = message_module.TestPackedTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsNegInf(golden_message.packed_float[0]))
  self.assertTrue(IsNegInf(golden_message.packed_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNegativeInfinityPacked_proto3"><code class="name flex">
<span>def <span class="ident">testNegativeInfinityPacked_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNegativeInfinityPacked(self, message_module):
  golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\xFF&#39;
                 b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
  golden_message = message_module.TestPackedTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsNegInf(golden_message.packed_float[0]))
  self.assertTrue(IsNegInf(golden_message.packed_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNegativeInfinity_proto2"><code class="name flex">
<span>def <span class="ident">testNegativeInfinity_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNegativeInfinity(self, message_module):
  if message_module is unittest_pb2:
    golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                   b&#39;\xCD\x02\x00\x00\x80\xFF&#39;
                   b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
  else:
    golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                   b&#39;\xCA\x02\x04\x00\x00\x80\xFF&#39;
                   b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)

  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsNegInf(golden_message.optional_float))
  self.assertTrue(IsNegInf(golden_message.optional_double))
  self.assertTrue(IsNegInf(golden_message.repeated_float[0]))
  self.assertTrue(IsNegInf(golden_message.repeated_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNegativeInfinity_proto3"><code class="name flex">
<span>def <span class="ident">testNegativeInfinity_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNegativeInfinity(self, message_module):
  if message_module is unittest_pb2:
    golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                   b&#39;\xCD\x02\x00\x00\x80\xFF&#39;
                   b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)
  else:
    golden_data = (b&#39;\x5D\x00\x00\x80\xFF&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;
                   b&#39;\xCA\x02\x04\x00\x00\x80\xFF&#39;
                   b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\xFF&#39;)

  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsNegInf(golden_message.optional_float))
  self.assertTrue(IsNegInf(golden_message.optional_double))
  self.assertTrue(IsNegInf(golden_message.repeated_float[0]))
  self.assertTrue(IsNegInf(golden_message.repeated_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNotANumberPacked_proto2"><code class="name flex">
<span>def <span class="ident">testNotANumberPacked_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNotANumberPacked(self, message_module):
  golden_data = (b&#39;\xA2\x06\x04\x00\x00\xC0\x7F&#39;
                 b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
  golden_message = message_module.TestPackedTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(isnan(golden_message.packed_float[0]))
  self.assertTrue(isnan(golden_message.packed_double[0]))

  serialized = golden_message.SerializeToString()
  message = message_module.TestPackedTypes()
  message.ParseFromString(serialized)
  self.assertTrue(isnan(message.packed_float[0]))
  self.assertTrue(isnan(message.packed_double[0]))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNotANumberPacked_proto3"><code class="name flex">
<span>def <span class="ident">testNotANumberPacked_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNotANumberPacked(self, message_module):
  golden_data = (b&#39;\xA2\x06\x04\x00\x00\xC0\x7F&#39;
                 b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
  golden_message = message_module.TestPackedTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(isnan(golden_message.packed_float[0]))
  self.assertTrue(isnan(golden_message.packed_double[0]))

  serialized = golden_message.SerializeToString()
  message = message_module.TestPackedTypes()
  message.ParseFromString(serialized)
  self.assertTrue(isnan(message.packed_float[0]))
  self.assertTrue(isnan(message.packed_double[0]))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNotANumber_proto2"><code class="name flex">
<span>def <span class="ident">testNotANumber_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNotANumber(self, message_module):
  golden_data = (b&#39;\x5D\x00\x00\xC0\x7F&#39;
                 b&#39;\x61\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;
                 b&#39;\xCD\x02\x00\x00\xC0\x7F&#39;
                 b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(isnan(golden_message.optional_float))
  self.assertTrue(isnan(golden_message.optional_double))
  self.assertTrue(isnan(golden_message.repeated_float[0]))
  self.assertTrue(isnan(golden_message.repeated_double[0]))

  # The protocol buffer may serialize to any one of multiple different
  # representations of a NaN.  Rather than verify a specific representation,
  # verify the serialized string can be converted into a correctly
  # behaving protocol buffer.
  serialized = golden_message.SerializeToString()
  message = message_module.TestAllTypes()
  message.ParseFromString(serialized)
  self.assertTrue(isnan(message.optional_float))
  self.assertTrue(isnan(message.optional_double))
  self.assertTrue(isnan(message.repeated_float[0]))
  self.assertTrue(isnan(message.repeated_double[0]))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testNotANumber_proto3"><code class="name flex">
<span>def <span class="ident">testNotANumber_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNotANumber(self, message_module):
  golden_data = (b&#39;\x5D\x00\x00\xC0\x7F&#39;
                 b&#39;\x61\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;
                 b&#39;\xCD\x02\x00\x00\xC0\x7F&#39;
                 b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF8\x7F&#39;)
  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(isnan(golden_message.optional_float))
  self.assertTrue(isnan(golden_message.optional_double))
  self.assertTrue(isnan(golden_message.repeated_float[0]))
  self.assertTrue(isnan(golden_message.repeated_double[0]))

  # The protocol buffer may serialize to any one of multiple different
  # representations of a NaN.  Rather than verify a specific representation,
  # verify the serialized string can be converted into a correctly
  # behaving protocol buffer.
  serialized = golden_message.SerializeToString()
  message = message_module.TestAllTypes()
  message.ParseFromString(serialized)
  self.assertTrue(isnan(message.optional_float))
  self.assertTrue(isnan(message.optional_double))
  self.assertTrue(isnan(message.repeated_float[0]))
  self.assertTrue(isnan(message.repeated_double[0]))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClearField_proto2"><code class="name flex">
<span>def <span class="ident">testOneofClearField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClearField(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m.ClearField(&#39;oneof_field&#39;)
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClearField_proto3"><code class="name flex">
<span>def <span class="ident">testOneofClearField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClearField(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m.ClearField(&#39;oneof_field&#39;)
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClearSetField_proto2"><code class="name flex">
<span>def <span class="ident">testOneofClearSetField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClearSetField(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m.ClearField(&#39;oneof_uint32&#39;)
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClearSetField_proto3"><code class="name flex">
<span>def <span class="ident">testOneofClearSetField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClearSetField(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m.ClearField(&#39;oneof_uint32&#39;)
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClearUnsetField_proto2"><code class="name flex">
<span>def <span class="ident">testOneofClearUnsetField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClearUnsetField(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
  m.ClearField(&#39;oneof_nested_message&#39;)
  self.assertEqual(11, m.oneof_uint32)
  if message_module is unittest_pb2:
    self.assertTrue(m.HasField(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClearUnsetField_proto3"><code class="name flex">
<span>def <span class="ident">testOneofClearUnsetField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClearUnsetField(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
  m.ClearField(&#39;oneof_nested_message&#39;)
  self.assertEqual(11, m.oneof_uint32)
  if message_module is unittest_pb2:
    self.assertTrue(m.HasField(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClear_proto2"><code class="name flex">
<span>def <span class="ident">testOneofClear_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClear(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m.Clear()
  self.assertIsNone(m.WhichOneof(&#39;oneof_field&#39;))
  m.oneof_bytes = b&#39;bb&#39;
  self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofClear_proto3"><code class="name flex">
<span>def <span class="ident">testOneofClear_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofClear(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m.Clear()
  self.assertIsNone(m.WhichOneof(&#39;oneof_field&#39;))
  m.oneof_bytes = b&#39;bb&#39;
  self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofCompositeFieldReadAccess_proto2"><code class="name flex">
<span>def <span class="ident">testOneofCompositeFieldReadAccess_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofCompositeFieldReadAccess(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11

  self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertEqual(11, m.oneof_uint32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofCompositeFieldReadAccess_proto3"><code class="name flex">
<span>def <span class="ident">testOneofCompositeFieldReadAccess_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofCompositeFieldReadAccess(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11

  self.ensureNestedMessageExists(m, &#39;oneof_nested_message&#39;)
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertEqual(11, m.oneof_uint32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofCopyFrom_proto2"><code class="name flex">
<span>def <span class="ident">testOneofCopyFrom_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofCopyFrom(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m2 = message_module.TestAllTypes()
  m2.CopyFrom(m)
  self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofCopyFrom_proto3"><code class="name flex">
<span>def <span class="ident">testOneofCopyFrom_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofCopyFrom(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m2 = message_module.TestAllTypes()
  m2.CopyFrom(m)
  self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofDefaultValues_proto2"><code class="name flex">
<span>def <span class="ident">testOneofDefaultValues_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofDefaultValues(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))

  # Oneof is set even when setting it to a default value.
  m.oneof_uint32 = 0
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
  self.assertFalse(m.HasField(&#39;oneof_string&#39;))

  m.oneof_string = &#34;&#34;
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofDefaultValues_proto3"><code class="name flex">
<span>def <span class="ident">testOneofDefaultValues_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofDefaultValues(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))

  # Oneof is set even when setting it to a default value.
  m.oneof_uint32 = 0
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))
  self.assertFalse(m.HasField(&#39;oneof_string&#39;))

  m.oneof_string = &#34;&#34;
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofDeserialize_proto2"><code class="name flex">
<span>def <span class="ident">testOneofDeserialize_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofDeserialize(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m2 = message_module.TestAllTypes()
  m2.ParseFromString(m.SerializeToString())
  self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofDeserialize_proto3"><code class="name flex">
<span>def <span class="ident">testOneofDeserialize_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofDeserialize(self, message_module):
  m = message_module.TestAllTypes()
  m.oneof_uint32 = 11
  m2 = message_module.TestAllTypes()
  m2.ParseFromString(m.SerializeToString())
  self.assertEqual(&#39;oneof_uint32&#39;, m2.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofGetCaseNonexistingField_proto2"><code class="name flex">
<span>def <span class="ident">testOneofGetCaseNonexistingField_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofGetCaseNonexistingField(self, message_module):
  m = message_module.TestAllTypes()
  self.assertRaises(ValueError, m.WhichOneof, &#39;no_such_oneof_field&#39;)
  self.assertRaises(Exception, m.WhichOneof, 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofGetCaseNonexistingField_proto3"><code class="name flex">
<span>def <span class="ident">testOneofGetCaseNonexistingField_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofGetCaseNonexistingField(self, message_module):
  m = message_module.TestAllTypes()
  self.assertRaises(ValueError, m.WhichOneof, &#39;no_such_oneof_field&#39;)
  self.assertRaises(Exception, m.WhichOneof, 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofMessageMergeFrom_proto2"><code class="name flex">
<span>def <span class="ident">testOneofMessageMergeFrom_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofMessageMergeFrom(self, message_module):
  m = message_module.NestedTestAllTypes()
  m.payload.oneof_nested_message.bb = 11
  m.child.payload.oneof_nested_message.bb = 12
  m2 = message_module.NestedTestAllTypes()
  m2.payload.oneof_uint32 = 13
  m2.MergeFrom(m)
  self.assertEqual(&#39;oneof_nested_message&#39;,
                   m2.payload.WhichOneof(&#39;oneof_field&#39;))
  self.assertEqual(&#39;oneof_nested_message&#39;,
                   m2.child.payload.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofMessageMergeFrom_proto3"><code class="name flex">
<span>def <span class="ident">testOneofMessageMergeFrom_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofMessageMergeFrom(self, message_module):
  m = message_module.NestedTestAllTypes()
  m.payload.oneof_nested_message.bb = 11
  m.child.payload.oneof_nested_message.bb = 12
  m2 = message_module.NestedTestAllTypes()
  m2.payload.oneof_uint32 = 13
  m2.MergeFrom(m)
  self.assertEqual(&#39;oneof_nested_message&#39;,
                   m2.payload.WhichOneof(&#39;oneof_field&#39;))
  self.assertEqual(&#39;oneof_nested_message&#39;,
                   m2.child.payload.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofNestedMergeFrom_proto2"><code class="name flex">
<span>def <span class="ident">testOneofNestedMergeFrom_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofNestedMergeFrom(self, message_module):
  m = message_module.NestedTestAllTypes()
  m.payload.oneof_uint32 = 11
  m2 = message_module.NestedTestAllTypes()
  m2.payload.oneof_bytes = b&#39;bb&#39;
  m2.child.payload.oneof_bytes = b&#39;bb&#39;
  m2.MergeFrom(m)
  self.assertEqual(&#39;oneof_uint32&#39;, m2.payload.WhichOneof(&#39;oneof_field&#39;))
  self.assertEqual(&#39;oneof_bytes&#39;, m2.child.payload.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofNestedMergeFrom_proto3"><code class="name flex">
<span>def <span class="ident">testOneofNestedMergeFrom_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofNestedMergeFrom(self, message_module):
  m = message_module.NestedTestAllTypes()
  m.payload.oneof_uint32 = 11
  m2 = message_module.NestedTestAllTypes()
  m2.payload.oneof_bytes = b&#39;bb&#39;
  m2.child.payload.oneof_bytes = b&#39;bb&#39;
  m2.MergeFrom(m)
  self.assertEqual(&#39;oneof_uint32&#39;, m2.payload.WhichOneof(&#39;oneof_field&#39;))
  self.assertEqual(&#39;oneof_bytes&#39;, m2.child.payload.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofNestedMessageInit_proto2"><code class="name flex">
<span>def <span class="ident">testOneofNestedMessageInit_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofNestedMessageInit(self, message_module):
  m = message_module.TestAllTypes(
      oneof_nested_message=message_module.TestAllTypes.NestedMessage())
  self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofNestedMessageInit_proto3"><code class="name flex">
<span>def <span class="ident">testOneofNestedMessageInit_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofNestedMessageInit(self, message_module):
  m = message_module.TestAllTypes(
      oneof_nested_message=message_module.TestAllTypes.NestedMessage())
  self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofSemantics_proto2"><code class="name flex">
<span>def <span class="ident">testOneofSemantics_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofSemantics(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

  m.oneof_uint32 = 11
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))

  m.oneof_string = u&#39;foo&#39;
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))

  # Read nested message accessor without accessing submessage.
  m.oneof_nested_message
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))
  self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

  # Read accessor of nested message without accessing submessage.
  m.oneof_nested_message.bb
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))
  self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

  m.oneof_nested_message.bb = 11
  self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_string&#39;))
  self.assertTrue(m.HasField(&#39;oneof_nested_message&#39;))

  m.oneof_bytes = b&#39;bb&#39;
  self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))
  self.assertTrue(m.HasField(&#39;oneof_bytes&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofSemantics_proto3"><code class="name flex">
<span>def <span class="ident">testOneofSemantics_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofSemantics(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))

  m.oneof_uint32 = 11
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_uint32&#39;))

  m.oneof_string = u&#39;foo&#39;
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_uint32&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))

  # Read nested message accessor without accessing submessage.
  m.oneof_nested_message
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))
  self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

  # Read accessor of nested message without accessing submessage.
  m.oneof_nested_message.bb
  self.assertEqual(&#39;oneof_string&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertTrue(m.HasField(&#39;oneof_string&#39;))
  self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))

  m.oneof_nested_message.bb = 11
  self.assertEqual(&#39;oneof_nested_message&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_string&#39;))
  self.assertTrue(m.HasField(&#39;oneof_nested_message&#39;))

  m.oneof_bytes = b&#39;bb&#39;
  self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  self.assertFalse(m.HasField(&#39;oneof_nested_message&#39;))
  self.assertTrue(m.HasField(&#39;oneof_bytes&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofWhichOneof_proto2"><code class="name flex">
<span>def <span class="ident">testOneofWhichOneof_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofWhichOneof(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))

  m.oneof_uint32 = 11
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  if message_module is unittest_pb2:
    self.assertTrue(m.HasField(&#39;oneof_field&#39;))

  m.oneof_bytes = b&#39;bb&#39;
  self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  m.ClearField(&#39;oneof_bytes&#39;)
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testOneofWhichOneof_proto3"><code class="name flex">
<span>def <span class="ident">testOneofWhichOneof_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofWhichOneof(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))

  m.oneof_uint32 = 11
  self.assertEqual(&#39;oneof_uint32&#39;, m.WhichOneof(&#39;oneof_field&#39;))
  if message_module is unittest_pb2:
    self.assertTrue(m.HasField(&#39;oneof_field&#39;))

  m.oneof_bytes = b&#39;bb&#39;
  self.assertEqual(&#39;oneof_bytes&#39;, m.WhichOneof(&#39;oneof_field&#39;))

  m.ClearField(&#39;oneof_bytes&#39;)
  self.assertIs(None, m.WhichOneof(&#39;oneof_field&#39;))
  if message_module is unittest_pb2:
    self.assertFalse(m.HasField(&#39;oneof_field&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testParseErrors_proto2"><code class="name flex">
<span>def <span class="ident">testParseErrors_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseErrors(self, message_module):
  msg = message_module.TestAllTypes()
  self.assertRaises(TypeError, msg.FromString, 0)
  self.assertRaises(Exception, msg.FromString, &#39;0&#39;)
  # TODO(jieluo): Fix cpp extension to raise error instead of warning.
  # b/27494216
  end_tag = encoder.TagBytes(1, 4)
  if api_implementation.Type() == &#39;python&#39;:
    with self.assertRaises(message.DecodeError) as context:
      msg.FromString(end_tag)
    self.assertEqual(&#39;Unexpected end-group tag.&#39;, str(context.exception))

  # Field number 0 is illegal.
  self.assertRaises(message.DecodeError, msg.FromString, b&#39;\3\4&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testParseErrors_proto3"><code class="name flex">
<span>def <span class="ident">testParseErrors_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseErrors(self, message_module):
  msg = message_module.TestAllTypes()
  self.assertRaises(TypeError, msg.FromString, 0)
  self.assertRaises(Exception, msg.FromString, &#39;0&#39;)
  # TODO(jieluo): Fix cpp extension to raise error instead of warning.
  # b/27494216
  end_tag = encoder.TagBytes(1, 4)
  if api_implementation.Type() == &#39;python&#39;:
    with self.assertRaises(message.DecodeError) as context:
      msg.FromString(end_tag)
    self.assertEqual(&#39;Unexpected end-group tag.&#39;, str(context.exception))

  # Field number 0 is illegal.
  self.assertRaises(message.DecodeError, msg.FromString, b&#39;\3\4&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleNestedMessage_proto2"><code class="name flex">
<span>def <span class="ident">testPickleNestedMessage_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleNestedMessage(self, message_module):
  golden_message = message_module.TestPickleNestedMessage.NestedMessage(bb=1)
  pickled_message = pickle.dumps(golden_message)
  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleNestedMessage_proto3"><code class="name flex">
<span>def <span class="ident">testPickleNestedMessage_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleNestedMessage(self, message_module):
  golden_message = message_module.TestPickleNestedMessage.NestedMessage(bb=1)
  pickled_message = pickle.dumps(golden_message)
  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleNestedNestedMessage_proto2"><code class="name flex">
<span>def <span class="ident">testPickleNestedNestedMessage_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleNestedNestedMessage(self, message_module):
  cls = message_module.TestPickleNestedMessage.NestedMessage
  golden_message = cls.NestedNestedMessage(cc=1)
  pickled_message = pickle.dumps(golden_message)
  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleNestedNestedMessage_proto3"><code class="name flex">
<span>def <span class="ident">testPickleNestedNestedMessage_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleNestedNestedMessage(self, message_module):
  cls = message_module.TestPickleNestedMessage.NestedMessage
  golden_message = cls.NestedNestedMessage(cc=1)
  pickled_message = pickle.dumps(golden_message)
  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleRepeatedScalarContainer_proto2"><code class="name flex">
<span>def <span class="ident">testPickleRepeatedScalarContainer_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleRepeatedScalarContainer(self, message_module):
  # TODO(tibell): The pure-Python implementation support pickling of
  #   scalar containers in *some* cases. For now the cpp2 version
  #   throws an exception to avoid a segfault. Investigate if we
  #   want to support pickling of these fields.
  #
  # For more information see: https://b2.corp.google.com/u/0/issues/18677897
  if (api_implementation.Type() != &#39;cpp&#39; or
      api_implementation.Version() == 2):
    return
  m = message_module.TestAllTypes()
  with self.assertRaises(pickle.PickleError) as _:
    pickle.dumps(m.repeated_int32, pickle.HIGHEST_PROTOCOL)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleRepeatedScalarContainer_proto3"><code class="name flex">
<span>def <span class="ident">testPickleRepeatedScalarContainer_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleRepeatedScalarContainer(self, message_module):
  # TODO(tibell): The pure-Python implementation support pickling of
  #   scalar containers in *some* cases. For now the cpp2 version
  #   throws an exception to avoid a segfault. Investigate if we
  #   want to support pickling of these fields.
  #
  # For more information see: https://b2.corp.google.com/u/0/issues/18677897
  if (api_implementation.Type() != &#39;cpp&#39; or
      api_implementation.Version() == 2):
    return
  m = message_module.TestAllTypes()
  with self.assertRaises(pickle.PickleError) as _:
    pickle.dumps(m.repeated_int32, pickle.HIGHEST_PROTOCOL)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleSupport_proto2"><code class="name flex">
<span>def <span class="ident">testPickleSupport_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleSupport(self, message_module):
  golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  pickled_message = pickle.dumps(golden_message)

  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPickleSupport_proto3"><code class="name flex">
<span>def <span class="ident">testPickleSupport_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleSupport(self, message_module):
  golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  pickled_message = pickle.dumps(golden_message)

  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPositiveInfinityPacked_proto2"><code class="name flex">
<span>def <span class="ident">testPositiveInfinityPacked_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPositiveInfinityPacked(self, message_module):
  golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\x7F&#39;
                 b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
  golden_message = message_module.TestPackedTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsPosInf(golden_message.packed_float[0]))
  self.assertTrue(IsPosInf(golden_message.packed_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPositiveInfinityPacked_proto3"><code class="name flex">
<span>def <span class="ident">testPositiveInfinityPacked_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPositiveInfinityPacked(self, message_module):
  golden_data = (b&#39;\xA2\x06\x04\x00\x00\x80\x7F&#39;
                 b&#39;\xAA\x06\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
  golden_message = message_module.TestPackedTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsPosInf(golden_message.packed_float[0]))
  self.assertTrue(IsPosInf(golden_message.packed_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPositiveInfinity_proto2"><code class="name flex">
<span>def <span class="ident">testPositiveInfinity_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPositiveInfinity(self, message_module):
  if message_module is unittest_pb2:
    golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                   b&#39;\xCD\x02\x00\x00\x80\x7F&#39;
                   b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
  else:
    golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                   b&#39;\xCA\x02\x04\x00\x00\x80\x7F&#39;
                   b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)

  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsPosInf(golden_message.optional_float))
  self.assertTrue(IsPosInf(golden_message.optional_double))
  self.assertTrue(IsPosInf(golden_message.repeated_float[0]))
  self.assertTrue(IsPosInf(golden_message.repeated_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testPositiveInfinity_proto3"><code class="name flex">
<span>def <span class="ident">testPositiveInfinity_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPositiveInfinity(self, message_module):
  if message_module is unittest_pb2:
    golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                   b&#39;\xCD\x02\x00\x00\x80\x7F&#39;
                   b&#39;\xD1\x02\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)
  else:
    golden_data = (b&#39;\x5D\x00\x00\x80\x7F&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;
                   b&#39;\xCA\x02\x04\x00\x00\x80\x7F&#39;
                   b&#39;\xD2\x02\x08\x00\x00\x00\x00\x00\x00\xF0\x7F&#39;)

  golden_message = message_module.TestAllTypes()
  golden_message.ParseFromString(golden_data)
  self.assertTrue(IsPosInf(golden_message.optional_float))
  self.assertTrue(IsPosInf(golden_message.optional_double))
  self.assertTrue(IsPosInf(golden_message.repeated_float[0]))
  self.assertTrue(IsPosInf(golden_message.repeated_double[0]))
  self.assertEqual(golden_data, golden_message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testReleasedNestedMessages_proto2"><code class="name flex">
<span>def <span class="ident">testReleasedNestedMessages_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>A case that lead to a segfault when a message detached from its parent
container has itself a child container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testReleasedNestedMessages(self, message_module):
  &#34;&#34;&#34;A case that lead to a segfault when a message detached from its parent
  container has itself a child container.
  &#34;&#34;&#34;
  m = message_module.NestedTestAllTypes()
  m = m.repeated_child.add()
  m = m.child
  m = m.repeated_child.add()
  self.assertEqual(m.payload.optional_int32, 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testReleasedNestedMessages_proto3"><code class="name flex">
<span>def <span class="ident">testReleasedNestedMessages_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>A case that lead to a segfault when a message detached from its parent
container has itself a child container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testReleasedNestedMessages(self, message_module):
  &#34;&#34;&#34;A case that lead to a segfault when a message detached from its parent
  container has itself a child container.
  &#34;&#34;&#34;
  m = message_module.NestedTestAllTypes()
  m = m.repeated_child.add()
  m = m.child
  m = m.repeated_child.add()
  self.assertEqual(m.payload.optional_int32, 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedCompareWithSelf_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedCompareWithSelf_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedCompareWithSelf(self, message_module):
  m = message_module.TestAllTypes()
  for i in range(5):
    m.repeated_int32.insert(i, i)
    n = m.repeated_nested_message.add()
    n.bb = i
  self.assertSequenceEqual(m.repeated_int32, m.repeated_int32)
  self.assertEqual(m.repeated_nested_message, m.repeated_nested_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedCompareWithSelf_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedCompareWithSelf_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedCompareWithSelf(self, message_module):
  m = message_module.TestAllTypes()
  for i in range(5):
    m.repeated_int32.insert(i, i)
    n = m.repeated_nested_message.add()
    n.bb = i
  self.assertSequenceEqual(m.repeated_int32, m.repeated_int32)
  self.assertEqual(m.repeated_nested_message, m.repeated_nested_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldPop_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedCompositeFieldPop_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedCompositeFieldPop(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(IndexError) as _:
    m.repeated_nested_message.pop()
  with self.assertRaises(TypeError) as _:
    m.repeated_nested_message.pop(&#39;0&#39;)
  for i in range(5):
    n = m.repeated_nested_message.add()
    n.bb = i
  self.assertEqual(4, m.repeated_nested_message.pop().bb)
  self.assertEqual(0, m.repeated_nested_message.pop(0).bb)
  self.assertEqual(2, m.repeated_nested_message.pop(1).bb)
  self.assertEqual([1, 3], [n.bb for n in m.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldPop_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedCompositeFieldPop_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedCompositeFieldPop(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(IndexError) as _:
    m.repeated_nested_message.pop()
  with self.assertRaises(TypeError) as _:
    m.repeated_nested_message.pop(&#39;0&#39;)
  for i in range(5):
    n = m.repeated_nested_message.add()
    n.bb = i
  self.assertEqual(4, m.repeated_nested_message.pop().bb)
  self.assertEqual(0, m.repeated_nested_message.pop(0).bb)
  self.assertEqual(2, m.repeated_nested_message.pop(1).bb)
  self.assertEqual([1, 3], [n.bb for n in m.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldSortArguments_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedCompositeFieldSortArguments_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check sorting a repeated composite field using list.sort() arguments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedCompositeFieldSortArguments(self, message_module):
  &#34;&#34;&#34;Check sorting a repeated composite field using list.sort() arguments.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  get_bb = operator.attrgetter(&#39;bb&#39;)
  cmp_bb = lambda a, b: cmp(a.bb, b.bb)
  message.repeated_nested_message.add().bb = 1
  message.repeated_nested_message.add().bb = 3
  message.repeated_nested_message.add().bb = 2
  message.repeated_nested_message.add().bb = 6
  message.repeated_nested_message.add().bb = 5
  message.repeated_nested_message.add().bb = 4
  message.repeated_nested_message.sort(key=get_bb)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [1, 2, 3, 4, 5, 6])
  message.repeated_nested_message.sort(key=get_bb, reverse=True)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [6, 5, 4, 3, 2, 1])
  if sys.version_info &gt;= (3,): return  # No cmp sorting in PY3.
  message.repeated_nested_message.sort(sort_function=cmp_bb)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [1, 2, 3, 4, 5, 6])
  message.repeated_nested_message.sort(cmp=cmp_bb, reverse=True)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [6, 5, 4, 3, 2, 1])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldSortArguments_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedCompositeFieldSortArguments_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check sorting a repeated composite field using list.sort() arguments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedCompositeFieldSortArguments(self, message_module):
  &#34;&#34;&#34;Check sorting a repeated composite field using list.sort() arguments.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  get_bb = operator.attrgetter(&#39;bb&#39;)
  cmp_bb = lambda a, b: cmp(a.bb, b.bb)
  message.repeated_nested_message.add().bb = 1
  message.repeated_nested_message.add().bb = 3
  message.repeated_nested_message.add().bb = 2
  message.repeated_nested_message.add().bb = 6
  message.repeated_nested_message.add().bb = 5
  message.repeated_nested_message.add().bb = 4
  message.repeated_nested_message.sort(key=get_bb)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [1, 2, 3, 4, 5, 6])
  message.repeated_nested_message.sort(key=get_bb, reverse=True)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [6, 5, 4, 3, 2, 1])
  if sys.version_info &gt;= (3,): return  # No cmp sorting in PY3.
  message.repeated_nested_message.sort(sort_function=cmp_bb)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [1, 2, 3, 4, 5, 6])
  message.repeated_nested_message.sort(cmp=cmp_bb, reverse=True)
  self.assertEqual([k.bb for k in message.repeated_nested_message],
                   [6, 5, 4, 3, 2, 1])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedContains_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedContains_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedContains(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_int32.extend([1, 2, 3])
  self.assertIn(2, msg.repeated_int32)
  self.assertNotIn(0, msg.repeated_int32)

  msg.repeated_nested_message.add(bb=1)
  sub_msg1 = msg.repeated_nested_message[0]
  sub_msg2 = message_module.TestAllTypes.NestedMessage(bb=2)
  sub_msg3 = message_module.TestAllTypes.NestedMessage(bb=3)
  msg.repeated_nested_message.append(sub_msg2)
  msg.repeated_nested_message.insert(0, sub_msg3)
  self.assertIn(sub_msg1, msg.repeated_nested_message)
  self.assertIn(sub_msg2, msg.repeated_nested_message)
  self.assertIn(sub_msg3, msg.repeated_nested_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedContains_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedContains_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedContains(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_int32.extend([1, 2, 3])
  self.assertIn(2, msg.repeated_int32)
  self.assertNotIn(0, msg.repeated_int32)

  msg.repeated_nested_message.add(bb=1)
  sub_msg1 = msg.repeated_nested_message[0]
  sub_msg2 = message_module.TestAllTypes.NestedMessage(bb=2)
  sub_msg3 = message_module.TestAllTypes.NestedMessage(bb=3)
  msg.repeated_nested_message.append(sub_msg2)
  msg.repeated_nested_message.insert(0, sub_msg3)
  self.assertIn(sub_msg1, msg.repeated_nested_message)
  self.assertIn(sub_msg2, msg.repeated_nested_message)
  self.assertIn(sub_msg3, msg.repeated_nested_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldInsideNestedMessage_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldInsideNestedMessage_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldInsideNestedMessage(self, message_module):
  m = message_module.NestedTestAllTypes()
  m.payload.repeated_int32.extend([])
  self.assertTrue(m.HasField(&#39;payload&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldInsideNestedMessage_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldInsideNestedMessage_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldInsideNestedMessage(self, message_module):
  m = message_module.NestedTestAllTypes()
  m.payload.repeated_int32.extend([])
  self.assertTrue(m.HasField(&#39;payload&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsAreSequences_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldsAreSequences_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldsAreSequences(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIsInstance(m.repeated_int32, collections_abc.MutableSequence)
  self.assertIsInstance(m.repeated_nested_message,
                        collections_abc.MutableSequence)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsAreSequences_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldsAreSequences_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldsAreSequences(self, message_module):
  m = message_module.TestAllTypes()
  self.assertIsInstance(m.repeated_int32, collections_abc.MutableSequence)
  self.assertIsInstance(m.repeated_nested_message,
                        collections_abc.MutableSequence)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsComparable_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldsComparable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldsComparable(self, message_module):
  m1 = message_module.TestAllTypes()
  m2 = message_module.TestAllTypes()
  m1.repeated_int32.append(0)
  m1.repeated_int32.append(1)
  m1.repeated_int32.append(2)
  m2.repeated_int32.append(0)
  m2.repeated_int32.append(1)
  m2.repeated_int32.append(2)
  m1.repeated_nested_message.add().bb = 1
  m1.repeated_nested_message.add().bb = 2
  m1.repeated_nested_message.add().bb = 3
  m2.repeated_nested_message.add().bb = 1
  m2.repeated_nested_message.add().bb = 2
  m2.repeated_nested_message.add().bb = 3

  if sys.version_info &gt;= (3,): return  # No cmp() in PY3.

  # These comparisons should not raise errors.
  _ = m1 &lt; m2
  _ = m1.repeated_nested_message &lt; m2.repeated_nested_message

  # Make sure cmp always works. If it wasn&#39;t defined, these would be
  # id() comparisons and would all fail.
  self.assertEqual(cmp(m1, m2), 0)
  self.assertEqual(cmp(m1.repeated_int32, m2.repeated_int32), 0)
  self.assertEqual(cmp(m1.repeated_int32, [0, 1, 2]), 0)
  self.assertEqual(cmp(m1.repeated_nested_message,
                       m2.repeated_nested_message), 0)
  with self.assertRaises(TypeError):
    # Can&#39;t compare repeated composite containers to lists.
    cmp(m1.repeated_nested_message, m2.repeated_nested_message[:])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsComparable_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldsComparable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldsComparable(self, message_module):
  m1 = message_module.TestAllTypes()
  m2 = message_module.TestAllTypes()
  m1.repeated_int32.append(0)
  m1.repeated_int32.append(1)
  m1.repeated_int32.append(2)
  m2.repeated_int32.append(0)
  m2.repeated_int32.append(1)
  m2.repeated_int32.append(2)
  m1.repeated_nested_message.add().bb = 1
  m1.repeated_nested_message.add().bb = 2
  m1.repeated_nested_message.add().bb = 3
  m2.repeated_nested_message.add().bb = 1
  m2.repeated_nested_message.add().bb = 2
  m2.repeated_nested_message.add().bb = 3

  if sys.version_info &gt;= (3,): return  # No cmp() in PY3.

  # These comparisons should not raise errors.
  _ = m1 &lt; m2
  _ = m1.repeated_nested_message &lt; m2.repeated_nested_message

  # Make sure cmp always works. If it wasn&#39;t defined, these would be
  # id() comparisons and would all fail.
  self.assertEqual(cmp(m1, m2), 0)
  self.assertEqual(cmp(m1.repeated_int32, m2.repeated_int32), 0)
  self.assertEqual(cmp(m1.repeated_int32, [0, 1, 2]), 0)
  self.assertEqual(cmp(m1.repeated_nested_message,
                       m2.repeated_nested_message), 0)
  with self.assertRaises(TypeError):
    # Can&#39;t compare repeated composite containers to lists.
    cmp(m1.repeated_nested_message, m2.repeated_nested_message[:])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsNotHashable_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldsNotHashable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldsNotHashable(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(TypeError):
    hash(m.repeated_int32)
  with self.assertRaises(TypeError):
    hash(m.repeated_nested_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsNotHashable_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedFieldsNotHashable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedFieldsNotHashable(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(TypeError):
    hash(m.repeated_int32)
  with self.assertRaises(TypeError):
    hash(m.repeated_nested_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedNestedFieldIteration_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedNestedFieldIteration_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedNestedFieldIteration(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_nested_message.add(bb=1)
  msg.repeated_nested_message.add(bb=2)
  msg.repeated_nested_message.add(bb=3)
  msg.repeated_nested_message.add(bb=4)

  self.assertEqual([1, 2, 3, 4],
                   [m.bb for m in msg.repeated_nested_message])
  self.assertEqual([4, 3, 2, 1],
                   [m.bb for m in reversed(msg.repeated_nested_message)])
  self.assertEqual([4, 3, 2, 1],
                   [m.bb for m in msg.repeated_nested_message[::-1]])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedNestedFieldIteration_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedNestedFieldIteration_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedNestedFieldIteration(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_nested_message.add(bb=1)
  msg.repeated_nested_message.add(bb=2)
  msg.repeated_nested_message.add(bb=3)
  msg.repeated_nested_message.add(bb=4)

  self.assertEqual([1, 2, 3, 4],
                   [m.bb for m in msg.repeated_nested_message])
  self.assertEqual([4, 3, 2, 1],
                   [m.bb for m in reversed(msg.repeated_nested_message)])
  self.assertEqual([4, 3, 2, 1],
                   [m.bb for m in msg.repeated_nested_message[::-1]])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldPop_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedScalarFieldPop_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedScalarFieldPop(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(IndexError) as _:
    m.repeated_int32.pop()
  m.repeated_int32.extend(range(5))
  self.assertEqual(4, m.repeated_int32.pop())
  self.assertEqual(0, m.repeated_int32.pop(0))
  self.assertEqual(2, m.repeated_int32.pop(1))
  self.assertEqual([1, 3], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldPop_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedScalarFieldPop_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedScalarFieldPop(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(IndexError) as _:
    m.repeated_int32.pop()
  m.repeated_int32.extend(range(5))
  self.assertEqual(4, m.repeated_int32.pop())
  self.assertEqual(0, m.repeated_int32.pop(0))
  self.assertEqual(2, m.repeated_int32.pop(1))
  self.assertEqual([1, 3], m.repeated_int32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldSortArguments_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedScalarFieldSortArguments_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check sorting a scalar field using list.sort() arguments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedScalarFieldSortArguments(self, message_module):
  &#34;&#34;&#34;Check sorting a scalar field using list.sort() arguments.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_int32.append(-3)
  message.repeated_int32.append(-2)
  message.repeated_int32.append(-1)
  message.repeated_int32.sort(key=abs)
  self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
  message.repeated_int32.sort(key=abs, reverse=True)
  self.assertEqual(list(message.repeated_int32), [-3, -2, -1])
  if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
    abs_cmp = lambda a, b: cmp(abs(a), abs(b))
    message.repeated_int32.sort(sort_function=abs_cmp)
    self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
    message.repeated_int32.sort(cmp=abs_cmp, reverse=True)
    self.assertEqual(list(message.repeated_int32), [-3, -2, -1])

  message.repeated_string.append(&#39;aaa&#39;)
  message.repeated_string.append(&#39;bb&#39;)
  message.repeated_string.append(&#39;c&#39;)
  message.repeated_string.sort(key=len)
  self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
  message.repeated_string.sort(key=len, reverse=True)
  self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])
  if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
    len_cmp = lambda a, b: cmp(len(a), len(b))
    message.repeated_string.sort(sort_function=len_cmp)
    self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
    message.repeated_string.sort(cmp=len_cmp, reverse=True)
    self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldSortArguments_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedScalarFieldSortArguments_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check sorting a scalar field using list.sort() arguments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedScalarFieldSortArguments(self, message_module):
  &#34;&#34;&#34;Check sorting a scalar field using list.sort() arguments.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_int32.append(-3)
  message.repeated_int32.append(-2)
  message.repeated_int32.append(-1)
  message.repeated_int32.sort(key=abs)
  self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
  message.repeated_int32.sort(key=abs, reverse=True)
  self.assertEqual(list(message.repeated_int32), [-3, -2, -1])
  if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
    abs_cmp = lambda a, b: cmp(abs(a), abs(b))
    message.repeated_int32.sort(sort_function=abs_cmp)
    self.assertEqual(list(message.repeated_int32), [-1, -2, -3])
    message.repeated_int32.sort(cmp=abs_cmp, reverse=True)
    self.assertEqual(list(message.repeated_int32), [-3, -2, -1])

  message.repeated_string.append(&#39;aaa&#39;)
  message.repeated_string.append(&#39;bb&#39;)
  message.repeated_string.append(&#39;c&#39;)
  message.repeated_string.sort(key=len)
  self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
  message.repeated_string.sort(key=len, reverse=True)
  self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])
  if sys.version_info &lt; (3,):  # No cmp sorting in PY3.
    len_cmp = lambda a, b: cmp(len(a), len(b))
    message.repeated_string.sort(sort_function=len_cmp)
    self.assertEqual(list(message.repeated_string), [&#39;c&#39;, &#39;bb&#39;, &#39;aaa&#39;])
    message.repeated_string.sort(cmp=len_cmp, reverse=True)
    self.assertEqual(list(message.repeated_string), [&#39;aaa&#39;, &#39;bb&#39;, &#39;c&#39;])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarIterable_proto2"><code class="name flex">
<span>def <span class="ident">testRepeatedScalarIterable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedScalarIterable(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_int32.extend([1, 2, 3])
  add = 0
  for item in msg.repeated_int32:
    add += item
  self.assertEqual(add, 6)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarIterable_proto3"><code class="name flex">
<span>def <span class="ident">testRepeatedScalarIterable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testRepeatedScalarIterable(self, message_module):
  msg = message_module.TestAllTypes()
  msg.repeated_int32.extend([1, 2, 3])
  add = 0
  for item in msg.repeated_int32:
    add += item
  self.assertEqual(add, 6)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testReturningType_proto2"><code class="name flex">
<span>def <span class="ident">testReturningType_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testReturningType(self, message_module):
  m = message_module.TestAllTypes()
  self.assertEqual(float, type(m.optional_float))
  self.assertEqual(float, type(m.optional_double))
  self.assertEqual(bool, type(m.optional_bool))
  m.optional_float = 1
  m.optional_double = 1
  m.optional_bool = 1
  m.repeated_float.append(1)
  m.repeated_double.append(1)
  m.repeated_bool.append(1)
  m.ParseFromString(m.SerializeToString())
  self.assertEqual(float, type(m.optional_float))
  self.assertEqual(float, type(m.optional_double))
  self.assertEqual(&#39;1.0&#39;, str(m.optional_double))
  self.assertEqual(bool, type(m.optional_bool))
  self.assertEqual(float, type(m.repeated_float[0]))
  self.assertEqual(float, type(m.repeated_double[0]))
  self.assertEqual(bool, type(m.repeated_bool[0]))
  self.assertEqual(True, m.repeated_bool[0])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testReturningType_proto3"><code class="name flex">
<span>def <span class="ident">testReturningType_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testReturningType(self, message_module):
  m = message_module.TestAllTypes()
  self.assertEqual(float, type(m.optional_float))
  self.assertEqual(float, type(m.optional_double))
  self.assertEqual(bool, type(m.optional_bool))
  m.optional_float = 1
  m.optional_double = 1
  m.optional_bool = 1
  m.repeated_float.append(1)
  m.repeated_double.append(1)
  m.repeated_bool.append(1)
  m.ParseFromString(m.SerializeToString())
  self.assertEqual(float, type(m.optional_float))
  self.assertEqual(float, type(m.optional_double))
  self.assertEqual(&#39;1.0&#39;, str(m.optional_double))
  self.assertEqual(bool, type(m.optional_bool))
  self.assertEqual(float, type(m.repeated_float[0]))
  self.assertEqual(float, type(m.repeated_double[0]))
  self.assertEqual(bool, type(m.repeated_bool[0]))
  self.assertEqual(True, m.repeated_bool[0])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSetRepeatedComposite_proto2"><code class="name flex">
<span>def <span class="ident">testSetRepeatedComposite_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSetRepeatedComposite(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(AttributeError):
    m.repeated_int32 = []
  m.repeated_int32.append(1)
  with self.assertRaises(AttributeError):
    m.repeated_int32 = []</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSetRepeatedComposite_proto3"><code class="name flex">
<span>def <span class="ident">testSetRepeatedComposite_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSetRepeatedComposite(self, message_module):
  m = message_module.TestAllTypes()
  with self.assertRaises(AttributeError):
    m.repeated_int32 = []
  m.repeated_int32.append(1)
  with self.assertRaises(AttributeError):
    m.repeated_int32 = []</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortEmptyRepeatedCompositeContainer_proto2"><code class="name flex">
<span>def <span class="ident">testSortEmptyRepeatedCompositeContainer_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Exercise a scenario that has led to segfaults in the past.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortEmptyRepeatedCompositeContainer(self, message_module):
  &#34;&#34;&#34;Exercise a scenario that has led to segfaults in the past.
  &#34;&#34;&#34;
  m = message_module.TestAllTypes()
  m.repeated_nested_message.sort()</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortEmptyRepeatedCompositeContainer_proto3"><code class="name flex">
<span>def <span class="ident">testSortEmptyRepeatedCompositeContainer_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Exercise a scenario that has led to segfaults in the past.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortEmptyRepeatedCompositeContainer(self, message_module):
  &#34;&#34;&#34;Exercise a scenario that has led to segfaults in the past.
  &#34;&#34;&#34;
  m = message_module.TestAllTypes()
  m.repeated_nested_message.sort()</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsCustomComparator_proto2"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedCompositeFieldsCustomComparator_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check passing a custom comparator to sort a repeated composite field.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedCompositeFieldsCustomComparator(self, message_module):
  &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_nested_message.add().bb = 1
  message.repeated_nested_message.add().bb = 3
  message.repeated_nested_message.add().bb = 2
  message.repeated_nested_message.add().bb = 6
  message.repeated_nested_message.add().bb = 5
  message.repeated_nested_message.add().bb = 4
  message.repeated_nested_message.sort(key=operator.attrgetter(&#39;bb&#39;))
  self.assertEqual(message.repeated_nested_message[0].bb, 1)
  self.assertEqual(message.repeated_nested_message[1].bb, 2)
  self.assertEqual(message.repeated_nested_message[2].bb, 3)
  self.assertEqual(message.repeated_nested_message[3].bb, 4)
  self.assertEqual(message.repeated_nested_message[4].bb, 5)
  self.assertEqual(message.repeated_nested_message[5].bb, 6)
  self.assertEqual(str(message.repeated_nested_message),
                   &#39;[bb: 1\n, bb: 2\n, bb: 3\n, bb: 4\n, bb: 5\n, bb: 6\n]&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsCustomComparator_proto3"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedCompositeFieldsCustomComparator_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check passing a custom comparator to sort a repeated composite field.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedCompositeFieldsCustomComparator(self, message_module):
  &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_nested_message.add().bb = 1
  message.repeated_nested_message.add().bb = 3
  message.repeated_nested_message.add().bb = 2
  message.repeated_nested_message.add().bb = 6
  message.repeated_nested_message.add().bb = 5
  message.repeated_nested_message.add().bb = 4
  message.repeated_nested_message.sort(key=operator.attrgetter(&#39;bb&#39;))
  self.assertEqual(message.repeated_nested_message[0].bb, 1)
  self.assertEqual(message.repeated_nested_message[1].bb, 2)
  self.assertEqual(message.repeated_nested_message[2].bb, 3)
  self.assertEqual(message.repeated_nested_message[3].bb, 4)
  self.assertEqual(message.repeated_nested_message[4].bb, 5)
  self.assertEqual(message.repeated_nested_message[5].bb, 6)
  self.assertEqual(str(message.repeated_nested_message),
                   &#39;[bb: 1\n, bb: 2\n, bb: 3\n, bb: 4\n, bb: 5\n, bb: 6\n]&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsStable_proto2"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedCompositeFieldsStable_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check passing a custom comparator to sort a repeated composite field.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedCompositeFieldsStable(self, message_module):
  &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_nested_message.add().bb = 21
  message.repeated_nested_message.add().bb = 20
  message.repeated_nested_message.add().bb = 13
  message.repeated_nested_message.add().bb = 33
  message.repeated_nested_message.add().bb = 11
  message.repeated_nested_message.add().bb = 24
  message.repeated_nested_message.add().bb = 10
  message.repeated_nested_message.sort(key=lambda z: z.bb // 10)
  self.assertEqual(
      [13, 11, 10, 21, 20, 24, 33],
      [n.bb for n in message.repeated_nested_message])

  # Make sure that for the C++ implementation, the underlying fields
  # are actually reordered.
  pb = message.SerializeToString()
  message.Clear()
  message.MergeFromString(pb)
  self.assertEqual(
      [13, 11, 10, 21, 20, 24, 33],
      [n.bb for n in message.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsStable_proto3"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedCompositeFieldsStable_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check passing a custom comparator to sort a repeated composite field.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedCompositeFieldsStable(self, message_module):
  &#34;&#34;&#34;Check passing a custom comparator to sort a repeated composite field.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_nested_message.add().bb = 21
  message.repeated_nested_message.add().bb = 20
  message.repeated_nested_message.add().bb = 13
  message.repeated_nested_message.add().bb = 33
  message.repeated_nested_message.add().bb = 11
  message.repeated_nested_message.add().bb = 24
  message.repeated_nested_message.add().bb = 10
  message.repeated_nested_message.sort(key=lambda z: z.bb // 10)
  self.assertEqual(
      [13, 11, 10, 21, 20, 24, 33],
      [n.bb for n in message.repeated_nested_message])

  # Make sure that for the C++ implementation, the underlying fields
  # are actually reordered.
  pb = message.SerializeToString()
  message.Clear()
  message.MergeFromString(pb)
  self.assertEqual(
      [13, 11, 10, 21, 20, 24, 33],
      [n.bb for n in message.repeated_nested_message])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsCustomComparator_proto2"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedScalarFieldsCustomComparator_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check some different types with custom comparator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedScalarFieldsCustomComparator(self, message_module):
  &#34;&#34;&#34;Check some different types with custom comparator.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_int32.append(-3)
  message.repeated_int32.append(-2)
  message.repeated_int32.append(-1)
  message.repeated_int32.sort(key=abs)
  self.assertEqual(message.repeated_int32[0], -1)
  self.assertEqual(message.repeated_int32[1], -2)
  self.assertEqual(message.repeated_int32[2], -3)

  message.repeated_string.append(&#39;aaa&#39;)
  message.repeated_string.append(&#39;bb&#39;)
  message.repeated_string.append(&#39;c&#39;)
  message.repeated_string.sort(key=len)
  self.assertEqual(message.repeated_string[0], &#39;c&#39;)
  self.assertEqual(message.repeated_string[1], &#39;bb&#39;)
  self.assertEqual(message.repeated_string[2], &#39;aaa&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsCustomComparator_proto3"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedScalarFieldsCustomComparator_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check some different types with custom comparator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedScalarFieldsCustomComparator(self, message_module):
  &#34;&#34;&#34;Check some different types with custom comparator.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  message.repeated_int32.append(-3)
  message.repeated_int32.append(-2)
  message.repeated_int32.append(-1)
  message.repeated_int32.sort(key=abs)
  self.assertEqual(message.repeated_int32[0], -1)
  self.assertEqual(message.repeated_int32[1], -2)
  self.assertEqual(message.repeated_int32[2], -3)

  message.repeated_string.append(&#39;aaa&#39;)
  message.repeated_string.append(&#39;bb&#39;)
  message.repeated_string.append(&#39;c&#39;)
  message.repeated_string.sort(key=len)
  self.assertEqual(message.repeated_string[0], &#39;c&#39;)
  self.assertEqual(message.repeated_string[1], &#39;bb&#39;)
  self.assertEqual(message.repeated_string[2], &#39;aaa&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsDefaultComparator_proto2"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedScalarFieldsDefaultComparator_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check some different types with the default comparator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedScalarFieldsDefaultComparator(self, message_module):
  &#34;&#34;&#34;Check some different types with the default comparator.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  # TODO(mattp): would testing more scalar types strengthen test?
  message.repeated_int32.append(1)
  message.repeated_int32.append(3)
  message.repeated_int32.append(2)
  message.repeated_int32.sort()
  self.assertEqual(message.repeated_int32[0], 1)
  self.assertEqual(message.repeated_int32[1], 2)
  self.assertEqual(message.repeated_int32[2], 3)
  self.assertEqual(str(message.repeated_int32), str([1, 2, 3]))

  message.repeated_float.append(1.1)
  message.repeated_float.append(1.3)
  message.repeated_float.append(1.2)
  message.repeated_float.sort()
  self.assertAlmostEqual(message.repeated_float[0], 1.1)
  self.assertAlmostEqual(message.repeated_float[1], 1.2)
  self.assertAlmostEqual(message.repeated_float[2], 1.3)

  message.repeated_string.append(&#39;a&#39;)
  message.repeated_string.append(&#39;c&#39;)
  message.repeated_string.append(&#39;b&#39;)
  message.repeated_string.sort()
  self.assertEqual(message.repeated_string[0], &#39;a&#39;)
  self.assertEqual(message.repeated_string[1], &#39;b&#39;)
  self.assertEqual(message.repeated_string[2], &#39;c&#39;)
  self.assertEqual(str(message.repeated_string), str([u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;]))

  message.repeated_bytes.append(b&#39;a&#39;)
  message.repeated_bytes.append(b&#39;c&#39;)
  message.repeated_bytes.append(b&#39;b&#39;)
  message.repeated_bytes.sort()
  self.assertEqual(message.repeated_bytes[0], b&#39;a&#39;)
  self.assertEqual(message.repeated_bytes[1], b&#39;b&#39;)
  self.assertEqual(message.repeated_bytes[2], b&#39;c&#39;)
  self.assertEqual(str(message.repeated_bytes), str([b&#39;a&#39;, b&#39;b&#39;, b&#39;c&#39;]))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsDefaultComparator_proto3"><code class="name flex">
<span>def <span class="ident">testSortingRepeatedScalarFieldsDefaultComparator_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"><p>Check some different types with the default comparator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortingRepeatedScalarFieldsDefaultComparator(self, message_module):
  &#34;&#34;&#34;Check some different types with the default comparator.&#34;&#34;&#34;
  message = message_module.TestAllTypes()

  # TODO(mattp): would testing more scalar types strengthen test?
  message.repeated_int32.append(1)
  message.repeated_int32.append(3)
  message.repeated_int32.append(2)
  message.repeated_int32.sort()
  self.assertEqual(message.repeated_int32[0], 1)
  self.assertEqual(message.repeated_int32[1], 2)
  self.assertEqual(message.repeated_int32[2], 3)
  self.assertEqual(str(message.repeated_int32), str([1, 2, 3]))

  message.repeated_float.append(1.1)
  message.repeated_float.append(1.3)
  message.repeated_float.append(1.2)
  message.repeated_float.sort()
  self.assertAlmostEqual(message.repeated_float[0], 1.1)
  self.assertAlmostEqual(message.repeated_float[1], 1.2)
  self.assertAlmostEqual(message.repeated_float[2], 1.3)

  message.repeated_string.append(&#39;a&#39;)
  message.repeated_string.append(&#39;c&#39;)
  message.repeated_string.append(&#39;b&#39;)
  message.repeated_string.sort()
  self.assertEqual(message.repeated_string[0], &#39;a&#39;)
  self.assertEqual(message.repeated_string[1], &#39;b&#39;)
  self.assertEqual(message.repeated_string[2], &#39;c&#39;)
  self.assertEqual(str(message.repeated_string), str([u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;]))

  message.repeated_bytes.append(b&#39;a&#39;)
  message.repeated_bytes.append(b&#39;c&#39;)
  message.repeated_bytes.append(b&#39;b&#39;)
  message.repeated_bytes.sort()
  self.assertEqual(message.repeated_bytes[0], b&#39;a&#39;)
  self.assertEqual(message.repeated_bytes[1], b&#39;b&#39;)
  self.assertEqual(message.repeated_bytes[2], b&#39;c&#39;)
  self.assertEqual(str(message.repeated_bytes), str([b&#39;a&#39;, b&#39;b&#39;, b&#39;c&#39;]))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testUnknownFieldPrinting_proto2"><code class="name flex">
<span>def <span class="ident">testUnknownFieldPrinting_proto2</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testUnknownFieldPrinting(self, message_module):
  populated = message_module.TestAllTypes()
  test_util.SetAllNonLazyFields(populated)
  empty = message_module.TestEmptyMessage()
  empty.ParseFromString(populated.SerializeToString())
  self.assertEqual(str(empty), &#39;&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.MessageTest.testUnknownFieldPrinting_proto3"><code class="name flex">
<span>def <span class="ident">testUnknownFieldPrinting_proto3</span></span>(<span>self, message_module)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testUnknownFieldPrinting(self, message_module):
  populated = message_module.TestAllTypes()
  test_util.SetAllNonLazyFields(populated)
  empty = message_module.TestEmptyMessage()
  empty.ParseFromString(populated.SerializeToString())
  self.assertEqual(str(empty), &#39;&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.message_test.OversizeProtosTest"><code class="flex name class">
<span>class <span class="ident">OversizeProtosTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OversizeProtosTest(unittest.TestCase):

  @classmethod
  def setUpClass(cls):
    # At the moment, reference cycles between DescriptorPool and Message classes
    # are not detected and these objects are never freed.
    # To avoid errors with ReferenceLeakChecker, we create the class only once.
    file_desc = &#34;&#34;&#34;
      name: &#34;f/f.msg2&#34;
      package: &#34;f&#34;
      message_type {
        name: &#34;msg1&#34;
        field {
          name: &#34;payload&#34;
          number: 1
          label: LABEL_OPTIONAL
          type: TYPE_STRING
        }
      }
      message_type {
        name: &#34;msg2&#34;
        field {
          name: &#34;field&#34;
          number: 1
          label: LABEL_OPTIONAL
          type: TYPE_MESSAGE
          type_name: &#34;msg1&#34;
        }
      }
    &#34;&#34;&#34;
    pool = descriptor_pool.DescriptorPool()
    desc = descriptor_pb2.FileDescriptorProto()
    text_format.Parse(file_desc, desc)
    pool.Add(desc)
    cls.proto_cls = message_factory.MessageFactory(pool).GetPrototype(
        pool.FindMessageTypeByName(&#39;f.msg2&#39;))

  def setUp(self):
    self.p = self.proto_cls()
    self.p.field.payload = &#39;c&#39; * (1024 * 1024 * 64 + 1)
    self.p_serialized = self.p.SerializeToString()

  def testAssertOversizeProto(self):
    from google.protobuf.pyext._message import SetAllowOversizeProtos
    SetAllowOversizeProtos(False)
    q = self.proto_cls()
    try:
      q.ParseFromString(self.p_serialized)
    except message.DecodeError as e:
      self.assertEqual(str(e), &#39;Error parsing message&#39;)

  def testSucceedOversizeProto(self):
    from google.protobuf.pyext._message import SetAllowOversizeProtos
    SetAllowOversizeProtos(True)
    q = self.proto_cls()
    q.ParseFromString(self.p_serialized)
    self.assertEqual(self.p.field.payload, q.field.payload)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.OversizeProtosTest.setUpClass"><code class="name flex">
<span>def <span class="ident">setUpClass</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for setting up class fixture before running tests in the class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def setUpClass(cls):
  # At the moment, reference cycles between DescriptorPool and Message classes
  # are not detected and these objects are never freed.
  # To avoid errors with ReferenceLeakChecker, we create the class only once.
  file_desc = &#34;&#34;&#34;
    name: &#34;f/f.msg2&#34;
    package: &#34;f&#34;
    message_type {
      name: &#34;msg1&#34;
      field {
        name: &#34;payload&#34;
        number: 1
        label: LABEL_OPTIONAL
        type: TYPE_STRING
      }
    }
    message_type {
      name: &#34;msg2&#34;
      field {
        name: &#34;field&#34;
        number: 1
        label: LABEL_OPTIONAL
        type: TYPE_MESSAGE
        type_name: &#34;msg1&#34;
      }
    }
  &#34;&#34;&#34;
  pool = descriptor_pool.DescriptorPool()
  desc = descriptor_pb2.FileDescriptorProto()
  text_format.Parse(file_desc, desc)
  pool.Add(desc)
  cls.proto_cls = message_factory.MessageFactory(pool).GetPrototype(
      pool.FindMessageTypeByName(&#39;f.msg2&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.OversizeProtosTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
  self.p = self.proto_cls()
  self.p.field.payload = &#39;c&#39; * (1024 * 1024 * 64 + 1)
  self.p_serialized = self.p.SerializeToString()</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.OversizeProtosTest.testAssertOversizeProto"><code class="name flex">
<span>def <span class="ident">testAssertOversizeProto</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssertOversizeProto(self):
  from google.protobuf.pyext._message import SetAllowOversizeProtos
  SetAllowOversizeProtos(False)
  q = self.proto_cls()
  try:
    q.ParseFromString(self.p_serialized)
  except message.DecodeError as e:
    self.assertEqual(str(e), &#39;Error parsing message&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.OversizeProtosTest.testSucceedOversizeProto"><code class="name flex">
<span>def <span class="ident">testSucceedOversizeProto</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSucceedOversizeProto(self):
  from google.protobuf.pyext._message import SetAllowOversizeProtos
  SetAllowOversizeProtos(True)
  q = self.proto_cls()
  q.ParseFromString(self.p_serialized)
  self.assertEqual(self.p.field.payload, q.field.payload)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.message_test.PackedFieldTest"><code class="flex name class">
<span>class <span class="ident">PackedFieldTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PackedFieldTest(unittest.TestCase):

  def setMessage(self, message):
    message.repeated_int32.append(1)
    message.repeated_int64.append(1)
    message.repeated_uint32.append(1)
    message.repeated_uint64.append(1)
    message.repeated_sint32.append(1)
    message.repeated_sint64.append(1)
    message.repeated_fixed32.append(1)
    message.repeated_fixed64.append(1)
    message.repeated_sfixed32.append(1)
    message.repeated_sfixed64.append(1)
    message.repeated_float.append(1.0)
    message.repeated_double.append(1.0)
    message.repeated_bool.append(True)
    message.repeated_nested_enum.append(1)

  def testPackedFields(self):
    message = packed_field_test_pb2.TestPackedTypes()
    self.setMessage(message)
    golden_data = (b&#39;\x0A\x01\x01&#39;
                   b&#39;\x12\x01\x01&#39;
                   b&#39;\x1A\x01\x01&#39;
                   b&#39;\x22\x01\x01&#39;
                   b&#39;\x2A\x01\x02&#39;
                   b&#39;\x32\x01\x02&#39;
                   b&#39;\x3A\x04\x01\x00\x00\x00&#39;
                   b&#39;\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x4A\x04\x01\x00\x00\x00&#39;
                   b&#39;\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x5A\x04\x00\x00\x80\x3f&#39;
                   b&#39;\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f&#39;
                   b&#39;\x6A\x01\x01&#39;
                   b&#39;\x72\x01\x01&#39;)
    self.assertEqual(golden_data, message.SerializeToString())

  def testUnpackedFields(self):
    message = packed_field_test_pb2.TestUnpackedTypes()
    self.setMessage(message)
    golden_data = (b&#39;\x08\x01&#39;
                   b&#39;\x10\x01&#39;
                   b&#39;\x18\x01&#39;
                   b&#39;\x20\x01&#39;
                   b&#39;\x28\x02&#39;
                   b&#39;\x30\x02&#39;
                   b&#39;\x3D\x01\x00\x00\x00&#39;
                   b&#39;\x41\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x4D\x01\x00\x00\x00&#39;
                   b&#39;\x51\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                   b&#39;\x5D\x00\x00\x80\x3f&#39;
                   b&#39;\x61\x00\x00\x00\x00\x00\x00\xf0\x3f&#39;
                   b&#39;\x68\x01&#39;
                   b&#39;\x70\x01&#39;)
    self.assertEqual(golden_data, message.SerializeToString())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.PackedFieldTest.setMessage"><code class="name flex">
<span>def <span class="ident">setMessage</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMessage(self, message):
  message.repeated_int32.append(1)
  message.repeated_int64.append(1)
  message.repeated_uint32.append(1)
  message.repeated_uint64.append(1)
  message.repeated_sint32.append(1)
  message.repeated_sint64.append(1)
  message.repeated_fixed32.append(1)
  message.repeated_fixed64.append(1)
  message.repeated_sfixed32.append(1)
  message.repeated_sfixed64.append(1)
  message.repeated_float.append(1.0)
  message.repeated_double.append(1.0)
  message.repeated_bool.append(True)
  message.repeated_nested_enum.append(1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.PackedFieldTest.testPackedFields"><code class="name flex">
<span>def <span class="ident">testPackedFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPackedFields(self):
  message = packed_field_test_pb2.TestPackedTypes()
  self.setMessage(message)
  golden_data = (b&#39;\x0A\x01\x01&#39;
                 b&#39;\x12\x01\x01&#39;
                 b&#39;\x1A\x01\x01&#39;
                 b&#39;\x22\x01\x01&#39;
                 b&#39;\x2A\x01\x02&#39;
                 b&#39;\x32\x01\x02&#39;
                 b&#39;\x3A\x04\x01\x00\x00\x00&#39;
                 b&#39;\x42\x08\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                 b&#39;\x4A\x04\x01\x00\x00\x00&#39;
                 b&#39;\x52\x08\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                 b&#39;\x5A\x04\x00\x00\x80\x3f&#39;
                 b&#39;\x62\x08\x00\x00\x00\x00\x00\x00\xf0\x3f&#39;
                 b&#39;\x6A\x01\x01&#39;
                 b&#39;\x72\x01\x01&#39;)
  self.assertEqual(golden_data, message.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.PackedFieldTest.testUnpackedFields"><code class="name flex">
<span>def <span class="ident">testUnpackedFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testUnpackedFields(self):
  message = packed_field_test_pb2.TestUnpackedTypes()
  self.setMessage(message)
  golden_data = (b&#39;\x08\x01&#39;
                 b&#39;\x10\x01&#39;
                 b&#39;\x18\x01&#39;
                 b&#39;\x20\x01&#39;
                 b&#39;\x28\x02&#39;
                 b&#39;\x30\x02&#39;
                 b&#39;\x3D\x01\x00\x00\x00&#39;
                 b&#39;\x41\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                 b&#39;\x4D\x01\x00\x00\x00&#39;
                 b&#39;\x51\x01\x00\x00\x00\x00\x00\x00\x00&#39;
                 b&#39;\x5D\x00\x00\x80\x3f&#39;
                 b&#39;\x61\x00\x00\x00\x00\x00\x00\xf0\x3f&#39;
                 b&#39;\x68\x01&#39;
                 b&#39;\x70\x01&#39;)
  self.assertEqual(golden_data, message.SerializeToString())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test"><code class="flex name class">
<span>class <span class="ident">Proto2Test</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proto2Test(unittest.TestCase):

  def testFieldPresence(self):
    message = unittest_pb2.TestAllTypes()

    self.assertFalse(message.HasField(&#34;optional_int32&#34;))
    self.assertFalse(message.HasField(&#34;optional_bool&#34;))
    self.assertFalse(message.HasField(&#34;optional_nested_message&#34;))

    with self.assertRaises(ValueError):
      message.HasField(&#34;field_doesnt_exist&#34;)

    with self.assertRaises(ValueError):
      message.HasField(&#34;repeated_int32&#34;)
    with self.assertRaises(ValueError):
      message.HasField(&#34;repeated_nested_message&#34;)

    self.assertEqual(0, message.optional_int32)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

    # Fields are set even when setting the values to default values.
    message.optional_int32 = 0
    message.optional_bool = False
    message.optional_nested_message.bb = 0
    self.assertTrue(message.HasField(&#34;optional_int32&#34;))
    self.assertTrue(message.HasField(&#34;optional_bool&#34;))
    self.assertTrue(message.HasField(&#34;optional_nested_message&#34;))

    # Set the fields to non-default values.
    message.optional_int32 = 5
    message.optional_bool = True
    message.optional_nested_message.bb = 15

    self.assertTrue(message.HasField(u&#34;optional_int32&#34;))
    self.assertTrue(message.HasField(&#34;optional_bool&#34;))
    self.assertTrue(message.HasField(&#34;optional_nested_message&#34;))

    # Clearing the fields unsets them and resets their value to default.
    message.ClearField(&#34;optional_int32&#34;)
    message.ClearField(u&#34;optional_bool&#34;)
    message.ClearField(&#34;optional_nested_message&#34;)

    self.assertFalse(message.HasField(&#34;optional_int32&#34;))
    self.assertFalse(message.HasField(&#34;optional_bool&#34;))
    self.assertFalse(message.HasField(&#34;optional_nested_message&#34;))
    self.assertEqual(0, message.optional_int32)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

  def testAssignInvalidEnum(self):
    &#34;&#34;&#34;Assigning an invalid enum number is not allowed in proto2.&#34;&#34;&#34;
    m = unittest_pb2.TestAllTypes()

    # Proto2 can not assign unknown enum.
    with self.assertRaises(ValueError) as _:
      m.optional_nested_enum = 1234567
    self.assertRaises(ValueError, m.repeated_nested_enum.append, 1234567)
    # Assignment is a different code path than append for the C++ impl.
    m.repeated_nested_enum.append(2)
    m.repeated_nested_enum[0] = 2
    with self.assertRaises(ValueError):
      m.repeated_nested_enum[0] = 123456

    # Unknown enum value can be parsed but is ignored.
    m2 = unittest_proto3_arena_pb2.TestAllTypes()
    m2.optional_nested_enum = 1234567
    m2.repeated_nested_enum.append(7654321)
    serialized = m2.SerializeToString()

    m3 = unittest_pb2.TestAllTypes()
    m3.ParseFromString(serialized)
    self.assertFalse(m3.HasField(&#39;optional_nested_enum&#39;))
    # 1 is the default value for optional_nested_enum.
    self.assertEqual(1, m3.optional_nested_enum)
    self.assertEqual(0, len(m3.repeated_nested_enum))
    m2.Clear()
    m2.ParseFromString(m3.SerializeToString())
    self.assertEqual(1234567, m2.optional_nested_enum)
    self.assertEqual(7654321, m2.repeated_nested_enum[0])

  def testUnknownEnumMap(self):
    m = map_proto2_unittest_pb2.TestEnumMap()
    m.known_map_field[123] = 0
    with self.assertRaises(ValueError):
      m.unknown_map_field[1] = 123

  def testExtensionsErrors(self):
    msg = unittest_pb2.TestAllTypes()
    self.assertRaises(AttributeError, getattr, msg, &#39;Extensions&#39;)

  def testMergeFromExtensions(self):
    msg1 = more_extensions_pb2.TopLevelMessage()
    msg2 = more_extensions_pb2.TopLevelMessage()
    # Cpp extension will lazily create a sub message which is immutable.
    self.assertEqual(0, msg1.submessage.Extensions[
        more_extensions_pb2.optional_int_extension])
    self.assertFalse(msg1.HasField(&#39;submessage&#39;))
    msg2.submessage.Extensions[
        more_extensions_pb2.optional_int_extension] = 123
    # Make sure cmessage and extensions pointing to a mutable message
    # after merge instead of the lazily created message.
    msg1.MergeFrom(msg2)
    self.assertEqual(123, msg1.submessage.Extensions[
        more_extensions_pb2.optional_int_extension])

  def testGoldenExtensions(self):
    golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
    golden_message = unittest_pb2.TestAllExtensions()
    golden_message.ParseFromString(golden_data)
    all_set = unittest_pb2.TestAllExtensions()
    test_util.SetAllExtensions(all_set)
    self.assertEqual(all_set, golden_message)
    self.assertEqual(golden_data, golden_message.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testGoldenPackedExtensions(self):
    golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
    golden_message = unittest_pb2.TestPackedExtensions()
    golden_message.ParseFromString(golden_data)
    all_set = unittest_pb2.TestPackedExtensions()
    test_util.SetAllPackedExtensions(all_set)
    self.assertEqual(all_set, golden_message)
    self.assertEqual(golden_data, all_set.SerializeToString())
    golden_copy = copy.deepcopy(golden_message)
    self.assertEqual(golden_data, golden_copy.SerializeToString())

  def testPickleIncompleteProto(self):
    golden_message = unittest_pb2.TestRequired(a=1)
    pickled_message = pickle.dumps(golden_message)

    unpickled_message = pickle.loads(pickled_message)
    self.assertEqual(unpickled_message, golden_message)
    self.assertEqual(unpickled_message.a, 1)
    # This is still an incomplete proto - so serializing should fail
    self.assertRaises(message.EncodeError, unpickled_message.SerializeToString)


  # TODO(haberman): this isn&#39;t really a proto2-specific test except that this
  # message has a required field in it.  Should probably be factored out so
  # that we can test the other parts with proto3.
  def testParsingMerge(self):
    &#34;&#34;&#34;Check the merge behavior when a required or optional field appears
    multiple times in the input.&#34;&#34;&#34;
    messages = [
        unittest_pb2.TestAllTypes(),
        unittest_pb2.TestAllTypes(),
        unittest_pb2.TestAllTypes() ]
    messages[0].optional_int32 = 1
    messages[1].optional_int64 = 2
    messages[2].optional_int32 = 3
    messages[2].optional_string = &#39;hello&#39;

    merged_message = unittest_pb2.TestAllTypes()
    merged_message.optional_int32 = 3
    merged_message.optional_int64 = 2
    merged_message.optional_string = &#39;hello&#39;

    generator = unittest_pb2.TestParsingMerge.RepeatedFieldsGenerator()
    generator.field1.extend(messages)
    generator.field2.extend(messages)
    generator.field3.extend(messages)
    generator.ext1.extend(messages)
    generator.ext2.extend(messages)
    generator.group1.add().field1.MergeFrom(messages[0])
    generator.group1.add().field1.MergeFrom(messages[1])
    generator.group1.add().field1.MergeFrom(messages[2])
    generator.group2.add().field1.MergeFrom(messages[0])
    generator.group2.add().field1.MergeFrom(messages[1])
    generator.group2.add().field1.MergeFrom(messages[2])

    data = generator.SerializeToString()
    parsing_merge = unittest_pb2.TestParsingMerge()
    parsing_merge.ParseFromString(data)

    # Required and optional fields should be merged.
    self.assertEqual(parsing_merge.required_all_types, merged_message)
    self.assertEqual(parsing_merge.optional_all_types, merged_message)
    self.assertEqual(parsing_merge.optionalgroup.optional_group_all_types,
                     merged_message)
    self.assertEqual(parsing_merge.Extensions[
                     unittest_pb2.TestParsingMerge.optional_ext],
                     merged_message)

    # Repeated fields should not be merged.
    self.assertEqual(len(parsing_merge.repeated_all_types), 3)
    self.assertEqual(len(parsing_merge.repeatedgroup), 3)
    self.assertEqual(len(parsing_merge.Extensions[
        unittest_pb2.TestParsingMerge.repeated_ext]), 3)

  def testPythonicInit(self):
    message = unittest_pb2.TestAllTypes(
        optional_int32=100,
        optional_fixed32=200,
        optional_float=300.5,
        optional_bytes=b&#39;x&#39;,
        optionalgroup={&#39;a&#39;: 400},
        optional_nested_message={&#39;bb&#39;: 500},
        optional_foreign_message={},
        optional_nested_enum=&#39;BAZ&#39;,
        repeatedgroup=[{&#39;a&#39;: 600},
                       {&#39;a&#39;: 700}],
        repeated_nested_enum=[&#39;FOO&#39;, unittest_pb2.TestAllTypes.BAR],
        default_int32=800,
        oneof_string=&#39;y&#39;)
    self.assertIsInstance(message, unittest_pb2.TestAllTypes)
    self.assertEqual(100, message.optional_int32)
    self.assertEqual(200, message.optional_fixed32)
    self.assertEqual(300.5, message.optional_float)
    self.assertEqual(b&#39;x&#39;, message.optional_bytes)
    self.assertEqual(400, message.optionalgroup.a)
    self.assertIsInstance(message.optional_nested_message,
                          unittest_pb2.TestAllTypes.NestedMessage)
    self.assertEqual(500, message.optional_nested_message.bb)
    self.assertTrue(message.HasField(&#39;optional_foreign_message&#39;))
    self.assertEqual(message.optional_foreign_message,
                     unittest_pb2.ForeignMessage())
    self.assertEqual(unittest_pb2.TestAllTypes.BAZ,
                     message.optional_nested_enum)
    self.assertEqual(2, len(message.repeatedgroup))
    self.assertEqual(600, message.repeatedgroup[0].a)
    self.assertEqual(700, message.repeatedgroup[1].a)
    self.assertEqual(2, len(message.repeated_nested_enum))
    self.assertEqual(unittest_pb2.TestAllTypes.FOO,
                     message.repeated_nested_enum[0])
    self.assertEqual(unittest_pb2.TestAllTypes.BAR,
                     message.repeated_nested_enum[1])
    self.assertEqual(800, message.default_int32)
    self.assertEqual(&#39;y&#39;, message.oneof_string)
    self.assertFalse(message.HasField(&#39;optional_int64&#39;))
    self.assertEqual(0, len(message.repeated_float))
    self.assertEqual(42, message.default_int64)

    message = unittest_pb2.TestAllTypes(optional_nested_enum=u&#39;BAZ&#39;)
    self.assertEqual(unittest_pb2.TestAllTypes.BAZ,
                     message.optional_nested_enum)

    with self.assertRaises(ValueError):
      unittest_pb2.TestAllTypes(
          optional_nested_message={&#39;INVALID_NESTED_FIELD&#39;: 17})

    with self.assertRaises(TypeError):
      unittest_pb2.TestAllTypes(
          optional_nested_message={&#39;bb&#39;: &#39;INVALID_VALUE_TYPE&#39;})

    with self.assertRaises(ValueError):
      unittest_pb2.TestAllTypes(optional_nested_enum=&#39;INVALID_LABEL&#39;)

    with self.assertRaises(ValueError):
      unittest_pb2.TestAllTypes(repeated_nested_enum=&#39;FOO&#39;)

  def testPythonicInitWithDict(self):
    # Both string/unicode field name keys should work.
    kwargs = {
        &#39;optional_int32&#39;: 100,
        u&#39;optional_fixed32&#39;: 200,
    }
    msg = unittest_pb2.TestAllTypes(**kwargs)
    self.assertEqual(100, msg.optional_int32)
    self.assertEqual(200, msg.optional_fixed32)


  def test_documentation(self):
    # Also used by the interactive help() function.
    doc = pydoc.html.document(unittest_pb2.TestAllTypes, &#39;message&#39;)
    self.assertIn(&#39;class TestAllTypes&#39;, doc)
    self.assertIn(&#39;SerializePartialToString&#39;, doc)
    self.assertIn(&#39;repeated_float&#39;, doc)
    base = unittest_pb2.TestAllTypes.__bases__[0]
    self.assertRaises(AttributeError, getattr, base, &#39;_extensions_by_name&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.Proto2Test.testAssignInvalidEnum"><code class="name flex">
<span>def <span class="ident">testAssignInvalidEnum</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigning an invalid enum number is not allowed in proto2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssignInvalidEnum(self):
  &#34;&#34;&#34;Assigning an invalid enum number is not allowed in proto2.&#34;&#34;&#34;
  m = unittest_pb2.TestAllTypes()

  # Proto2 can not assign unknown enum.
  with self.assertRaises(ValueError) as _:
    m.optional_nested_enum = 1234567
  self.assertRaises(ValueError, m.repeated_nested_enum.append, 1234567)
  # Assignment is a different code path than append for the C++ impl.
  m.repeated_nested_enum.append(2)
  m.repeated_nested_enum[0] = 2
  with self.assertRaises(ValueError):
    m.repeated_nested_enum[0] = 123456

  # Unknown enum value can be parsed but is ignored.
  m2 = unittest_proto3_arena_pb2.TestAllTypes()
  m2.optional_nested_enum = 1234567
  m2.repeated_nested_enum.append(7654321)
  serialized = m2.SerializeToString()

  m3 = unittest_pb2.TestAllTypes()
  m3.ParseFromString(serialized)
  self.assertFalse(m3.HasField(&#39;optional_nested_enum&#39;))
  # 1 is the default value for optional_nested_enum.
  self.assertEqual(1, m3.optional_nested_enum)
  self.assertEqual(0, len(m3.repeated_nested_enum))
  m2.Clear()
  m2.ParseFromString(m3.SerializeToString())
  self.assertEqual(1234567, m2.optional_nested_enum)
  self.assertEqual(7654321, m2.repeated_nested_enum[0])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testExtensionsErrors"><code class="name flex">
<span>def <span class="ident">testExtensionsErrors</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionsErrors(self):
  msg = unittest_pb2.TestAllTypes()
  self.assertRaises(AttributeError, getattr, msg, &#39;Extensions&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testFieldPresence"><code class="name flex">
<span>def <span class="ident">testFieldPresence</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFieldPresence(self):
  message = unittest_pb2.TestAllTypes()

  self.assertFalse(message.HasField(&#34;optional_int32&#34;))
  self.assertFalse(message.HasField(&#34;optional_bool&#34;))
  self.assertFalse(message.HasField(&#34;optional_nested_message&#34;))

  with self.assertRaises(ValueError):
    message.HasField(&#34;field_doesnt_exist&#34;)

  with self.assertRaises(ValueError):
    message.HasField(&#34;repeated_int32&#34;)
  with self.assertRaises(ValueError):
    message.HasField(&#34;repeated_nested_message&#34;)

  self.assertEqual(0, message.optional_int32)
  self.assertEqual(False, message.optional_bool)
  self.assertEqual(0, message.optional_nested_message.bb)

  # Fields are set even when setting the values to default values.
  message.optional_int32 = 0
  message.optional_bool = False
  message.optional_nested_message.bb = 0
  self.assertTrue(message.HasField(&#34;optional_int32&#34;))
  self.assertTrue(message.HasField(&#34;optional_bool&#34;))
  self.assertTrue(message.HasField(&#34;optional_nested_message&#34;))

  # Set the fields to non-default values.
  message.optional_int32 = 5
  message.optional_bool = True
  message.optional_nested_message.bb = 15

  self.assertTrue(message.HasField(u&#34;optional_int32&#34;))
  self.assertTrue(message.HasField(&#34;optional_bool&#34;))
  self.assertTrue(message.HasField(&#34;optional_nested_message&#34;))

  # Clearing the fields unsets them and resets their value to default.
  message.ClearField(&#34;optional_int32&#34;)
  message.ClearField(u&#34;optional_bool&#34;)
  message.ClearField(&#34;optional_nested_message&#34;)

  self.assertFalse(message.HasField(&#34;optional_int32&#34;))
  self.assertFalse(message.HasField(&#34;optional_bool&#34;))
  self.assertFalse(message.HasField(&#34;optional_nested_message&#34;))
  self.assertEqual(0, message.optional_int32)
  self.assertEqual(False, message.optional_bool)
  self.assertEqual(0, message.optional_nested_message.bb)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testGoldenExtensions"><code class="name flex">
<span>def <span class="ident">testGoldenExtensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testGoldenExtensions(self):
  golden_data = test_util.GoldenFileData(&#39;golden_message&#39;)
  golden_message = unittest_pb2.TestAllExtensions()
  golden_message.ParseFromString(golden_data)
  all_set = unittest_pb2.TestAllExtensions()
  test_util.SetAllExtensions(all_set)
  self.assertEqual(all_set, golden_message)
  self.assertEqual(golden_data, golden_message.SerializeToString())
  golden_copy = copy.deepcopy(golden_message)
  self.assertEqual(golden_data, golden_copy.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testGoldenPackedExtensions"><code class="name flex">
<span>def <span class="ident">testGoldenPackedExtensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testGoldenPackedExtensions(self):
  golden_data = test_util.GoldenFileData(&#39;golden_packed_fields_message&#39;)
  golden_message = unittest_pb2.TestPackedExtensions()
  golden_message.ParseFromString(golden_data)
  all_set = unittest_pb2.TestPackedExtensions()
  test_util.SetAllPackedExtensions(all_set)
  self.assertEqual(all_set, golden_message)
  self.assertEqual(golden_data, all_set.SerializeToString())
  golden_copy = copy.deepcopy(golden_message)
  self.assertEqual(golden_data, golden_copy.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testMergeFromExtensions"><code class="name flex">
<span>def <span class="ident">testMergeFromExtensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromExtensions(self):
  msg1 = more_extensions_pb2.TopLevelMessage()
  msg2 = more_extensions_pb2.TopLevelMessage()
  # Cpp extension will lazily create a sub message which is immutable.
  self.assertEqual(0, msg1.submessage.Extensions[
      more_extensions_pb2.optional_int_extension])
  self.assertFalse(msg1.HasField(&#39;submessage&#39;))
  msg2.submessage.Extensions[
      more_extensions_pb2.optional_int_extension] = 123
  # Make sure cmessage and extensions pointing to a mutable message
  # after merge instead of the lazily created message.
  msg1.MergeFrom(msg2)
  self.assertEqual(123, msg1.submessage.Extensions[
      more_extensions_pb2.optional_int_extension])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testParsingMerge"><code class="name flex">
<span>def <span class="ident">testParsingMerge</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Check the merge behavior when a required or optional field appears
multiple times in the input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParsingMerge(self):
  &#34;&#34;&#34;Check the merge behavior when a required or optional field appears
  multiple times in the input.&#34;&#34;&#34;
  messages = [
      unittest_pb2.TestAllTypes(),
      unittest_pb2.TestAllTypes(),
      unittest_pb2.TestAllTypes() ]
  messages[0].optional_int32 = 1
  messages[1].optional_int64 = 2
  messages[2].optional_int32 = 3
  messages[2].optional_string = &#39;hello&#39;

  merged_message = unittest_pb2.TestAllTypes()
  merged_message.optional_int32 = 3
  merged_message.optional_int64 = 2
  merged_message.optional_string = &#39;hello&#39;

  generator = unittest_pb2.TestParsingMerge.RepeatedFieldsGenerator()
  generator.field1.extend(messages)
  generator.field2.extend(messages)
  generator.field3.extend(messages)
  generator.ext1.extend(messages)
  generator.ext2.extend(messages)
  generator.group1.add().field1.MergeFrom(messages[0])
  generator.group1.add().field1.MergeFrom(messages[1])
  generator.group1.add().field1.MergeFrom(messages[2])
  generator.group2.add().field1.MergeFrom(messages[0])
  generator.group2.add().field1.MergeFrom(messages[1])
  generator.group2.add().field1.MergeFrom(messages[2])

  data = generator.SerializeToString()
  parsing_merge = unittest_pb2.TestParsingMerge()
  parsing_merge.ParseFromString(data)

  # Required and optional fields should be merged.
  self.assertEqual(parsing_merge.required_all_types, merged_message)
  self.assertEqual(parsing_merge.optional_all_types, merged_message)
  self.assertEqual(parsing_merge.optionalgroup.optional_group_all_types,
                   merged_message)
  self.assertEqual(parsing_merge.Extensions[
                   unittest_pb2.TestParsingMerge.optional_ext],
                   merged_message)

  # Repeated fields should not be merged.
  self.assertEqual(len(parsing_merge.repeated_all_types), 3)
  self.assertEqual(len(parsing_merge.repeatedgroup), 3)
  self.assertEqual(len(parsing_merge.Extensions[
      unittest_pb2.TestParsingMerge.repeated_ext]), 3)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testPickleIncompleteProto"><code class="name flex">
<span>def <span class="ident">testPickleIncompleteProto</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPickleIncompleteProto(self):
  golden_message = unittest_pb2.TestRequired(a=1)
  pickled_message = pickle.dumps(golden_message)

  unpickled_message = pickle.loads(pickled_message)
  self.assertEqual(unpickled_message, golden_message)
  self.assertEqual(unpickled_message.a, 1)
  # This is still an incomplete proto - so serializing should fail
  self.assertRaises(message.EncodeError, unpickled_message.SerializeToString)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testPythonicInit"><code class="name flex">
<span>def <span class="ident">testPythonicInit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPythonicInit(self):
  message = unittest_pb2.TestAllTypes(
      optional_int32=100,
      optional_fixed32=200,
      optional_float=300.5,
      optional_bytes=b&#39;x&#39;,
      optionalgroup={&#39;a&#39;: 400},
      optional_nested_message={&#39;bb&#39;: 500},
      optional_foreign_message={},
      optional_nested_enum=&#39;BAZ&#39;,
      repeatedgroup=[{&#39;a&#39;: 600},
                     {&#39;a&#39;: 700}],
      repeated_nested_enum=[&#39;FOO&#39;, unittest_pb2.TestAllTypes.BAR],
      default_int32=800,
      oneof_string=&#39;y&#39;)
  self.assertIsInstance(message, unittest_pb2.TestAllTypes)
  self.assertEqual(100, message.optional_int32)
  self.assertEqual(200, message.optional_fixed32)
  self.assertEqual(300.5, message.optional_float)
  self.assertEqual(b&#39;x&#39;, message.optional_bytes)
  self.assertEqual(400, message.optionalgroup.a)
  self.assertIsInstance(message.optional_nested_message,
                        unittest_pb2.TestAllTypes.NestedMessage)
  self.assertEqual(500, message.optional_nested_message.bb)
  self.assertTrue(message.HasField(&#39;optional_foreign_message&#39;))
  self.assertEqual(message.optional_foreign_message,
                   unittest_pb2.ForeignMessage())
  self.assertEqual(unittest_pb2.TestAllTypes.BAZ,
                   message.optional_nested_enum)
  self.assertEqual(2, len(message.repeatedgroup))
  self.assertEqual(600, message.repeatedgroup[0].a)
  self.assertEqual(700, message.repeatedgroup[1].a)
  self.assertEqual(2, len(message.repeated_nested_enum))
  self.assertEqual(unittest_pb2.TestAllTypes.FOO,
                   message.repeated_nested_enum[0])
  self.assertEqual(unittest_pb2.TestAllTypes.BAR,
                   message.repeated_nested_enum[1])
  self.assertEqual(800, message.default_int32)
  self.assertEqual(&#39;y&#39;, message.oneof_string)
  self.assertFalse(message.HasField(&#39;optional_int64&#39;))
  self.assertEqual(0, len(message.repeated_float))
  self.assertEqual(42, message.default_int64)

  message = unittest_pb2.TestAllTypes(optional_nested_enum=u&#39;BAZ&#39;)
  self.assertEqual(unittest_pb2.TestAllTypes.BAZ,
                   message.optional_nested_enum)

  with self.assertRaises(ValueError):
    unittest_pb2.TestAllTypes(
        optional_nested_message={&#39;INVALID_NESTED_FIELD&#39;: 17})

  with self.assertRaises(TypeError):
    unittest_pb2.TestAllTypes(
        optional_nested_message={&#39;bb&#39;: &#39;INVALID_VALUE_TYPE&#39;})

  with self.assertRaises(ValueError):
    unittest_pb2.TestAllTypes(optional_nested_enum=&#39;INVALID_LABEL&#39;)

  with self.assertRaises(ValueError):
    unittest_pb2.TestAllTypes(repeated_nested_enum=&#39;FOO&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testPythonicInitWithDict"><code class="name flex">
<span>def <span class="ident">testPythonicInitWithDict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPythonicInitWithDict(self):
  # Both string/unicode field name keys should work.
  kwargs = {
      &#39;optional_int32&#39;: 100,
      u&#39;optional_fixed32&#39;: 200,
  }
  msg = unittest_pb2.TestAllTypes(**kwargs)
  self.assertEqual(100, msg.optional_int32)
  self.assertEqual(200, msg.optional_fixed32)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.testUnknownEnumMap"><code class="name flex">
<span>def <span class="ident">testUnknownEnumMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testUnknownEnumMap(self):
  m = map_proto2_unittest_pb2.TestEnumMap()
  m.known_map_field[123] = 0
  with self.assertRaises(ValueError):
    m.unknown_map_field[1] = 123</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto2Test.test_documentation"><code class="name flex">
<span>def <span class="ident">test_documentation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_documentation(self):
  # Also used by the interactive help() function.
  doc = pydoc.html.document(unittest_pb2.TestAllTypes, &#39;message&#39;)
  self.assertIn(&#39;class TestAllTypes&#39;, doc)
  self.assertIn(&#39;SerializePartialToString&#39;, doc)
  self.assertIn(&#39;repeated_float&#39;, doc)
  base = unittest_pb2.TestAllTypes.__bases__[0]
  self.assertRaises(AttributeError, getattr, base, &#39;_extensions_by_name&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test"><code class="flex name class">
<span>class <span class="ident">Proto3Test</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proto3Test(unittest.TestCase):

  # Utility method for comparing equality with a map.
  def assertMapIterEquals(self, map_iter, dict_value):
    # Avoid mutating caller&#39;s copy.
    dict_value = dict(dict_value)

    for k, v in map_iter:
      self.assertEqual(v, dict_value[k])
      del dict_value[k]

    self.assertEqual({}, dict_value)

  def testFieldPresence(self):
    message = unittest_proto3_arena_pb2.TestAllTypes()

    # We can&#39;t test presence of non-repeated, non-submessage fields.
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_int32&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_float&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_string&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;optional_bool&#39;)

    # But we can still test presence of submessage fields.
    self.assertFalse(message.HasField(&#39;optional_nested_message&#39;))

    # As with proto2, we can&#39;t test presence of fields that don&#39;t exist, or
    # repeated fields.
    with self.assertRaises(ValueError):
      message.HasField(&#39;field_doesnt_exist&#39;)

    with self.assertRaises(ValueError):
      message.HasField(&#39;repeated_int32&#39;)
    with self.assertRaises(ValueError):
      message.HasField(&#39;repeated_nested_message&#39;)

    # Fields should default to their type-specific default.
    self.assertEqual(0, message.optional_int32)
    self.assertEqual(0, message.optional_float)
    self.assertEqual(&#39;&#39;, message.optional_string)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

    # Setting a submessage should still return proper presence information.
    message.optional_nested_message.bb = 0
    self.assertTrue(message.HasField(&#39;optional_nested_message&#39;))

    # Set the fields to non-default values.
    message.optional_int32 = 5
    message.optional_float = 1.1
    message.optional_string = &#39;abc&#39;
    message.optional_bool = True
    message.optional_nested_message.bb = 15

    # Clearing the fields unsets them and resets their value to default.
    message.ClearField(&#39;optional_int32&#39;)
    message.ClearField(&#39;optional_float&#39;)
    message.ClearField(&#39;optional_string&#39;)
    message.ClearField(&#39;optional_bool&#39;)
    message.ClearField(&#39;optional_nested_message&#39;)

    self.assertEqual(0, message.optional_int32)
    self.assertEqual(0, message.optional_float)
    self.assertEqual(&#39;&#39;, message.optional_string)
    self.assertEqual(False, message.optional_bool)
    self.assertEqual(0, message.optional_nested_message.bb)

  def testAssignUnknownEnum(self):
    &#34;&#34;&#34;Assigning an unknown enum value is allowed and preserves the value.&#34;&#34;&#34;
    m = unittest_proto3_arena_pb2.TestAllTypes()

    # Proto3 can assign unknown enums.
    m.optional_nested_enum = 1234567
    self.assertEqual(1234567, m.optional_nested_enum)
    m.repeated_nested_enum.append(22334455)
    self.assertEqual(22334455, m.repeated_nested_enum[0])
    # Assignment is a different code path than append for the C++ impl.
    m.repeated_nested_enum[0] = 7654321
    self.assertEqual(7654321, m.repeated_nested_enum[0])
    serialized = m.SerializeToString()

    m2 = unittest_proto3_arena_pb2.TestAllTypes()
    m2.ParseFromString(serialized)
    self.assertEqual(1234567, m2.optional_nested_enum)
    self.assertEqual(7654321, m2.repeated_nested_enum[0])

  # Map isn&#39;t really a proto3-only feature. But there is no proto2 equivalent
  # of google/protobuf/map_unittest.proto right now, so it&#39;s not easy to
  # test both with the same test like we do for the other proto2/proto3 tests.
  # (google/protobuf/map_proto2_unittest.proto is very different in the set
  # of messages and fields it contains).
  def testScalarMapDefaults(self):
    msg = map_unittest_pb2.TestMap()

    # Scalars start out unset.
    self.assertFalse(-123 in msg.map_int32_int32)
    self.assertFalse(-2**33 in msg.map_int64_int64)
    self.assertFalse(123 in msg.map_uint32_uint32)
    self.assertFalse(2**33 in msg.map_uint64_uint64)
    self.assertFalse(123 in msg.map_int32_double)
    self.assertFalse(False in msg.map_bool_bool)
    self.assertFalse(&#39;abc&#39; in msg.map_string_string)
    self.assertFalse(111 in msg.map_int32_bytes)
    self.assertFalse(888 in msg.map_int32_enum)

    # Accessing an unset key returns the default.
    self.assertEqual(0, msg.map_int32_int32[-123])
    self.assertEqual(0, msg.map_int64_int64[-2**33])
    self.assertEqual(0, msg.map_uint32_uint32[123])
    self.assertEqual(0, msg.map_uint64_uint64[2**33])
    self.assertEqual(0.0, msg.map_int32_double[123])
    self.assertTrue(isinstance(msg.map_int32_double[123], float))
    self.assertEqual(False, msg.map_bool_bool[False])
    self.assertTrue(isinstance(msg.map_bool_bool[False], bool))
    self.assertEqual(&#39;&#39;, msg.map_string_string[&#39;abc&#39;])
    self.assertEqual(b&#39;&#39;, msg.map_int32_bytes[111])
    self.assertEqual(0, msg.map_int32_enum[888])

    # It also sets the value in the map
    self.assertTrue(-123 in msg.map_int32_int32)
    self.assertTrue(-2**33 in msg.map_int64_int64)
    self.assertTrue(123 in msg.map_uint32_uint32)
    self.assertTrue(2**33 in msg.map_uint64_uint64)
    self.assertTrue(123 in msg.map_int32_double)
    self.assertTrue(False in msg.map_bool_bool)
    self.assertTrue(&#39;abc&#39; in msg.map_string_string)
    self.assertTrue(111 in msg.map_int32_bytes)
    self.assertTrue(888 in msg.map_int32_enum)

    self.assertIsInstance(msg.map_string_string[&#39;abc&#39;], six.text_type)

    # Accessing an unset key still throws TypeError if the type of the key
    # is incorrect.
    with self.assertRaises(TypeError):
      msg.map_string_string[123]

    with self.assertRaises(TypeError):
      123 in msg.map_string_string

  def testMapGet(self):
    # Need to test that get() properly returns the default, even though the dict
    # has defaultdict-like semantics.
    msg = map_unittest_pb2.TestMap()

    self.assertIsNone(msg.map_int32_int32.get(5))
    self.assertEqual(10, msg.map_int32_int32.get(5, 10))
    self.assertEqual(10, msg.map_int32_int32.get(key=5, default=10))
    self.assertIsNone(msg.map_int32_int32.get(5))

    msg.map_int32_int32[5] = 15
    self.assertEqual(15, msg.map_int32_int32.get(5))
    self.assertEqual(15, msg.map_int32_int32.get(5))
    with self.assertRaises(TypeError):
      msg.map_int32_int32.get(&#39;&#39;)

    self.assertIsNone(msg.map_int32_foreign_message.get(5))
    self.assertEqual(10, msg.map_int32_foreign_message.get(5, 10))
    self.assertEqual(10, msg.map_int32_foreign_message.get(key=5, default=10))

    submsg = msg.map_int32_foreign_message[5]
    self.assertIs(submsg, msg.map_int32_foreign_message.get(5))
    with self.assertRaises(TypeError):
      msg.map_int32_foreign_message.get(&#39;&#39;)

  def testScalarMap(self):
    msg = map_unittest_pb2.TestMap()

    self.assertEqual(0, len(msg.map_int32_int32))
    self.assertFalse(5 in msg.map_int32_int32)

    msg.map_int32_int32[-123] = -456
    msg.map_int64_int64[-2**33] = -2**34
    msg.map_uint32_uint32[123] = 456
    msg.map_uint64_uint64[2**33] = 2**34
    msg.map_int32_float[2] = 1.2
    msg.map_int32_double[1] = 3.3
    msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
    msg.map_bool_bool[True] = True
    msg.map_int32_enum[888] = 2
    # Unknown numeric enum is supported in proto3.
    msg.map_int32_enum[123] = 456

    self.assertEqual([], msg.FindInitializationErrors())

    self.assertEqual(1, len(msg.map_string_string))

    # Bad key.
    with self.assertRaises(TypeError):
      msg.map_string_string[123] = &#39;123&#39;

    # Verify that trying to assign a bad key doesn&#39;t actually add a member to
    # the map.
    self.assertEqual(1, len(msg.map_string_string))

    # Bad value.
    with self.assertRaises(TypeError):
      msg.map_string_string[&#39;123&#39;] = 123

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    # Bad key.
    with self.assertRaises(TypeError):
      msg2.map_string_string[123] = &#39;123&#39;

    # Bad value.
    with self.assertRaises(TypeError):
      msg2.map_string_string[&#39;123&#39;] = 123

    self.assertEqual(-456, msg2.map_int32_int32[-123])
    self.assertEqual(-2**34, msg2.map_int64_int64[-2**33])
    self.assertEqual(456, msg2.map_uint32_uint32[123])
    self.assertEqual(2**34, msg2.map_uint64_uint64[2**33])
    self.assertAlmostEqual(1.2, msg.map_int32_float[2])
    self.assertEqual(3.3, msg.map_int32_double[1])
    self.assertEqual(&#39;123&#39;, msg2.map_string_string[&#39;abc&#39;])
    self.assertEqual(True, msg2.map_bool_bool[True])
    self.assertEqual(2, msg2.map_int32_enum[888])
    self.assertEqual(456, msg2.map_int32_enum[123])
    self.assertEqual(&#39;{-123: -456}&#39;,
                     str(msg2.map_int32_int32))

  def testMapEntryAlwaysSerialized(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[0] = 0
    msg.map_string_string[&#39;&#39;] = &#39;&#39;
    self.assertEqual(msg.ByteSize(), 12)
    self.assertEqual(b&#39;\n\x04\x08\x00\x10\x00r\x04\n\x00\x12\x00&#39;,
                     msg.SerializeToString())

  def testStringUnicodeConversionInMap(self):
    msg = map_unittest_pb2.TestMap()

    unicode_obj = u&#39;\u1234&#39;
    bytes_obj = unicode_obj.encode(&#39;utf8&#39;)

    msg.map_string_string[bytes_obj] = bytes_obj

    (key, value) = list(msg.map_string_string.items())[0]

    self.assertEqual(key, unicode_obj)
    self.assertEqual(value, unicode_obj)

    self.assertIsInstance(key, six.text_type)
    self.assertIsInstance(value, six.text_type)

  def testMessageMap(self):
    msg = map_unittest_pb2.TestMap()

    self.assertEqual(0, len(msg.map_int32_foreign_message))
    self.assertFalse(5 in msg.map_int32_foreign_message)

    msg.map_int32_foreign_message[123]
    # get_or_create() is an alias for getitem.
    msg.map_int32_foreign_message.get_or_create(-456)

    self.assertEqual(2, len(msg.map_int32_foreign_message))
    self.assertIn(123, msg.map_int32_foreign_message)
    self.assertIn(-456, msg.map_int32_foreign_message)
    self.assertEqual(2, len(msg.map_int32_foreign_message))

    # Bad key.
    with self.assertRaises(TypeError):
      msg.map_int32_foreign_message[&#39;123&#39;]

    # Can&#39;t assign directly to submessage.
    with self.assertRaises(ValueError):
      msg.map_int32_foreign_message[999] = msg.map_int32_foreign_message[123]

    # Verify that trying to assign a bad key doesn&#39;t actually add a member to
    # the map.
    self.assertEqual(2, len(msg.map_int32_foreign_message))

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    self.assertEqual(2, len(msg2.map_int32_foreign_message))
    self.assertIn(123, msg2.map_int32_foreign_message)
    self.assertIn(-456, msg2.map_int32_foreign_message)
    self.assertEqual(2, len(msg2.map_int32_foreign_message))
    msg2.map_int32_foreign_message[123].c = 1
    # TODO(jieluo): Fix text format for message map.
    self.assertIn(str(msg2.map_int32_foreign_message),
                  (&#39;{-456: , 123: c: 1\n}&#39;, &#39;{123: c: 1\n, -456: }&#39;))

  def testNestedMessageMapItemDelete(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_all_types[1].optional_nested_message.bb = 1
    del msg.map_int32_all_types[1]
    msg.map_int32_all_types[2].optional_nested_message.bb = 2
    self.assertEqual(1, len(msg.map_int32_all_types))
    msg.map_int32_all_types[1].optional_nested_message.bb = 1
    self.assertEqual(2, len(msg.map_int32_all_types))

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)
    keys = [1, 2]
    # The loop triggers PyErr_Occurred() in c extension.
    for key in keys:
      del msg2.map_int32_all_types[key]

  def testMapByteSize(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[1] = 1
    size = msg.ByteSize()
    msg.map_int32_int32[1] = 128
    self.assertEqual(msg.ByteSize(), size + 1)

    msg.map_int32_foreign_message[19].c = 1
    size = msg.ByteSize()
    msg.map_int32_foreign_message[19].c = 128
    self.assertEqual(msg.ByteSize(), size + 1)

  def testMergeFrom(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[12] = 34
    msg.map_int32_int32[56] = 78
    msg.map_int64_int64[22] = 33
    msg.map_int32_foreign_message[111].c = 5
    msg.map_int32_foreign_message[222].c = 10

    msg2 = map_unittest_pb2.TestMap()
    msg2.map_int32_int32[12] = 55
    msg2.map_int64_int64[88] = 99
    msg2.map_int32_foreign_message[222].c = 15
    msg2.map_int32_foreign_message[222].d = 20
    old_map_value = msg2.map_int32_foreign_message[222]

    msg2.MergeFrom(msg)
    # Compare with expected message instead of call
    # msg2.map_int32_foreign_message[222] to make sure MergeFrom does not
    # sync with repeated field and there is no duplicated keys.
    expected_msg = map_unittest_pb2.TestMap()
    expected_msg.CopyFrom(msg)
    expected_msg.map_int64_int64[88] = 99
    self.assertEqual(msg2, expected_msg)

    self.assertEqual(34, msg2.map_int32_int32[12])
    self.assertEqual(78, msg2.map_int32_int32[56])
    self.assertEqual(33, msg2.map_int64_int64[22])
    self.assertEqual(99, msg2.map_int64_int64[88])
    self.assertEqual(5, msg2.map_int32_foreign_message[111].c)
    self.assertEqual(10, msg2.map_int32_foreign_message[222].c)
    self.assertFalse(msg2.map_int32_foreign_message[222].HasField(&#39;d&#39;))
    if api_implementation.Type() != &#39;cpp&#39;:
      # During the call to MergeFrom(), the C++ implementation will have
      # deallocated the underlying message, but this is very difficult to detect
      # properly. The line below is likely to cause a segmentation fault.
      # With the Python implementation, old_map_value is just &#39;detached&#39; from
      # the main message. Using it will not crash of course, but since it still
      # have a reference to the parent message I&#39;m sure we can find interesting
      # ways to cause inconsistencies.
      self.assertEqual(15, old_map_value.c)

    # Verify that there is only one entry per key, even though the MergeFrom
    # may have internally created multiple entries for a single key in the
    # list representation.
    as_dict = {}
    for key in msg2.map_int32_foreign_message:
      self.assertFalse(key in as_dict)
      as_dict[key] = msg2.map_int32_foreign_message[key].c

    self.assertEqual({111: 5, 222: 10}, as_dict)

    # Special case: test that delete of item really removes the item, even if
    # there might have physically been duplicate keys due to the previous merge.
    # This is only a special case for the C++ implementation which stores the
    # map as an array.
    del msg2.map_int32_int32[12]
    self.assertFalse(12 in msg2.map_int32_int32)

    del msg2.map_int32_foreign_message[222]
    self.assertFalse(222 in msg2.map_int32_foreign_message)
    with self.assertRaises(TypeError):
      del msg2.map_int32_foreign_message[&#39;&#39;]

  def testMapMergeFrom(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[12] = 34
    msg.map_int32_int32[56] = 78
    msg.map_int64_int64[22] = 33
    msg.map_int32_foreign_message[111].c = 5
    msg.map_int32_foreign_message[222].c = 10

    msg2 = map_unittest_pb2.TestMap()
    msg2.map_int32_int32[12] = 55
    msg2.map_int64_int64[88] = 99
    msg2.map_int32_foreign_message[222].c = 15
    msg2.map_int32_foreign_message[222].d = 20

    msg2.map_int32_int32.MergeFrom(msg.map_int32_int32)
    self.assertEqual(34, msg2.map_int32_int32[12])
    self.assertEqual(78, msg2.map_int32_int32[56])

    msg2.map_int64_int64.MergeFrom(msg.map_int64_int64)
    self.assertEqual(33, msg2.map_int64_int64[22])
    self.assertEqual(99, msg2.map_int64_int64[88])

    msg2.map_int32_foreign_message.MergeFrom(msg.map_int32_foreign_message)
    # Compare with expected message instead of call
    # msg.map_int32_foreign_message[222] to make sure MergeFrom does not
    # sync with repeated field and no duplicated keys.
    expected_msg = map_unittest_pb2.TestMap()
    expected_msg.CopyFrom(msg)
    expected_msg.map_int64_int64[88] = 99
    self.assertEqual(msg2, expected_msg)

    # Test when cpp extension cache a map.
    m1 = map_unittest_pb2.TestMap()
    m2 = map_unittest_pb2.TestMap()
    self.assertEqual(m1.map_int32_foreign_message,
                     m1.map_int32_foreign_message)
    m2.map_int32_foreign_message[123].c = 10
    m1.MergeFrom(m2)
    self.assertEqual(10, m2.map_int32_foreign_message[123].c)

    # Test merge maps within different message types.
    m1 = map_unittest_pb2.TestMap()
    m2 = map_unittest_pb2.TestMessageMap()
    m2.map_int32_message[123].optional_int32 = 10
    m1.map_int32_all_types.MergeFrom(m2.map_int32_message)
    self.assertEqual(10, m1.map_int32_all_types[123].optional_int32)

    # Test overwrite message value map
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_foreign_message[222].c = 123
    msg2 = map_unittest_pb2.TestMap()
    msg2.map_int32_foreign_message[222].d = 20
    msg.MergeFromString(msg2.SerializeToString())
    self.assertEqual(msg.map_int32_foreign_message[222].d, 20)
    self.assertNotEqual(msg.map_int32_foreign_message[222].c, 123)

  def testMergeFromBadType(self):
    msg = map_unittest_pb2.TestMap()
    with self.assertRaisesRegexp(
        TypeError,
        r&#39;Parameter to MergeFrom\(\) must be instance of same class: expected &#39;
        r&#39;.*TestMap got int\.&#39;):
      msg.MergeFrom(1)

  def testCopyFromBadType(self):
    msg = map_unittest_pb2.TestMap()
    with self.assertRaisesRegexp(
        TypeError,
        r&#39;Parameter to [A-Za-z]*From\(\) must be instance of same class: &#39;
        r&#39;expected .*TestMap got int\.&#39;):
      msg.CopyFrom(1)

  def testIntegerMapWithLongs(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[long(-123)] = long(-456)
    msg.map_int64_int64[long(-2**33)] = long(-2**34)
    msg.map_uint32_uint32[long(123)] = long(456)
    msg.map_uint64_uint64[long(2**33)] = long(2**34)

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    self.assertEqual(-456, msg2.map_int32_int32[-123])
    self.assertEqual(-2**34, msg2.map_int64_int64[-2**33])
    self.assertEqual(456, msg2.map_uint32_uint32[123])
    self.assertEqual(2**34, msg2.map_uint64_uint64[2**33])

  def testMapAssignmentCausesPresence(self):
    msg = map_unittest_pb2.TestMapSubmessage()
    msg.test_map.map_int32_int32[123] = 456

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMapSubmessage()
    msg2.ParseFromString(serialized)

    self.assertEqual(msg, msg2)

    # Now test that various mutations of the map properly invalidate the
    # cached size of the submessage.
    msg.test_map.map_int32_int32[888] = 999
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

    msg.test_map.map_int32_int32.clear()
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

  def testMapAssignmentCausesPresenceForSubmessages(self):
    msg = map_unittest_pb2.TestMapSubmessage()
    msg.test_map.map_int32_foreign_message[123].c = 5

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMapSubmessage()
    msg2.ParseFromString(serialized)

    self.assertEqual(msg, msg2)

    # Now test that various mutations of the map properly invalidate the
    # cached size of the submessage.
    msg.test_map.map_int32_foreign_message[888].c = 7
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

    msg.test_map.map_int32_foreign_message[888].MergeFrom(
        msg.test_map.map_int32_foreign_message[123])
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

    msg.test_map.map_int32_foreign_message.clear()
    serialized = msg.SerializeToString()
    msg2.ParseFromString(serialized)
    self.assertEqual(msg, msg2)

  def testModifyMapWhileIterating(self):
    msg = map_unittest_pb2.TestMap()

    string_string_iter = iter(msg.map_string_string)
    int32_foreign_iter = iter(msg.map_int32_foreign_message)

    msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
    msg.map_int32_foreign_message[5].c = 5

    with self.assertRaises(RuntimeError):
      for key in string_string_iter:
        pass

    with self.assertRaises(RuntimeError):
      for key in int32_foreign_iter:
        pass

  def testSubmessageMap(self):
    msg = map_unittest_pb2.TestMap()

    submsg = msg.map_int32_foreign_message[111]
    self.assertIs(submsg, msg.map_int32_foreign_message[111])
    self.assertIsInstance(submsg, unittest_pb2.ForeignMessage)

    submsg.c = 5

    serialized = msg.SerializeToString()
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(serialized)

    self.assertEqual(5, msg2.map_int32_foreign_message[111].c)

    # Doesn&#39;t allow direct submessage assignment.
    with self.assertRaises(ValueError):
      msg.map_int32_foreign_message[88] = unittest_pb2.ForeignMessage()

  def testMapIteration(self):
    msg = map_unittest_pb2.TestMap()

    for k, v in msg.map_int32_int32.items():
      # Should not be reached.
      self.assertTrue(False)

    msg.map_int32_int32[2] = 4
    msg.map_int32_int32[3] = 6
    msg.map_int32_int32[4] = 8
    self.assertEqual(3, len(msg.map_int32_int32))

    matching_dict = {2: 4, 3: 6, 4: 8}
    self.assertMapIterEquals(msg.map_int32_int32.items(), matching_dict)

  def testPython2Map(self):
    if sys.version_info &lt; (3,):
      msg = map_unittest_pb2.TestMap()
      msg.map_int32_int32[2] = 4
      msg.map_int32_int32[3] = 6
      msg.map_int32_int32[4] = 8
      msg.map_int32_int32[5] = 10
      map_int32 = msg.map_int32_int32
      self.assertEqual(4, len(map_int32))
      msg2 = map_unittest_pb2.TestMap()
      msg2.ParseFromString(msg.SerializeToString())

      def CheckItems(seq, iterator):
        self.assertEqual(next(iterator), seq[0])
        self.assertEqual(list(iterator), seq[1:])

      CheckItems(map_int32.items(), map_int32.iteritems())
      CheckItems(map_int32.keys(), map_int32.iterkeys())
      CheckItems(map_int32.values(), map_int32.itervalues())

      self.assertEqual(6, map_int32.get(3))
      self.assertEqual(None, map_int32.get(999))
      self.assertEqual(6, map_int32.pop(3))
      self.assertEqual(0, map_int32.pop(3))
      self.assertEqual(3, len(map_int32))
      key, value = map_int32.popitem()
      self.assertEqual(2 * key, value)
      self.assertEqual(2, len(map_int32))
      map_int32.clear()
      self.assertEqual(0, len(map_int32))

      with self.assertRaises(KeyError):
        map_int32.popitem()

      self.assertEqual(0, map_int32.setdefault(2))
      self.assertEqual(1, len(map_int32))

      map_int32.update(msg2.map_int32_int32)
      self.assertEqual(4, len(map_int32))

      with self.assertRaises(TypeError):
        map_int32.update(msg2.map_int32_int32,
                         msg2.map_int32_int32)
      with self.assertRaises(TypeError):
        map_int32.update(0)
      with self.assertRaises(TypeError):
        map_int32.update(value=12)

  def testMapItems(self):
    # Map items used to have strange behaviors when use c extension. Because
    # [] may reorder the map and invalidate any exsting iterators.
    # TODO(jieluo): Check if [] reordering the map is a bug or intended
    # behavior.
    msg = map_unittest_pb2.TestMap()
    msg.map_string_string[&#39;local_init_op&#39;] = &#39;&#39;
    msg.map_string_string[&#39;trainable_variables&#39;] = &#39;&#39;
    msg.map_string_string[&#39;variables&#39;] = &#39;&#39;
    msg.map_string_string[&#39;init_op&#39;] = &#39;&#39;
    msg.map_string_string[&#39;summaries&#39;] = &#39;&#39;
    items1 = msg.map_string_string.items()
    items2 = msg.map_string_string.items()
    self.assertEqual(items1, items2)

  def testMapDeterministicSerialization(self):
    golden_data = (b&#39;r\x0c\n\x07init_op\x12\x01d&#39;
                   b&#39;r\n\n\x05item1\x12\x01e&#39;
                   b&#39;r\n\n\x05item2\x12\x01f&#39;
                   b&#39;r\n\n\x05item3\x12\x01g&#39;
                   b&#39;r\x0b\n\x05item4\x12\x02QQ&#39;
                   b&#39;r\x12\n\rlocal_init_op\x12\x01a&#39;
                   b&#39;r\x0e\n\tsummaries\x12\x01e&#39;
                   b&#39;r\x18\n\x13trainable_variables\x12\x01b&#39;
                   b&#39;r\x0e\n\tvariables\x12\x01c&#39;)
    msg = map_unittest_pb2.TestMap()
    msg.map_string_string[&#39;local_init_op&#39;] = &#39;a&#39;
    msg.map_string_string[&#39;trainable_variables&#39;] = &#39;b&#39;
    msg.map_string_string[&#39;variables&#39;] = &#39;c&#39;
    msg.map_string_string[&#39;init_op&#39;] = &#39;d&#39;
    msg.map_string_string[&#39;summaries&#39;] = &#39;e&#39;
    msg.map_string_string[&#39;item1&#39;] = &#39;e&#39;
    msg.map_string_string[&#39;item2&#39;] = &#39;f&#39;
    msg.map_string_string[&#39;item3&#39;] = &#39;g&#39;
    msg.map_string_string[&#39;item4&#39;] = &#39;QQ&#39;

    # If deterministic serialization is not working correctly, this will be
    # &#34;flaky&#34; depending on the exact python dict hash seed.
    #
    # Fortunately, there are enough items in this map that it is extremely
    # unlikely to ever hit the &#34;right&#34; in-order combination, so the test
    # itself should fail reliably.
    self.assertEqual(golden_data, msg.SerializeToString(deterministic=True))

  def testMapIterationClearMessage(self):
    # Iterator needs to work even if message and map are deleted.
    msg = map_unittest_pb2.TestMap()

    msg.map_int32_int32[2] = 4
    msg.map_int32_int32[3] = 6
    msg.map_int32_int32[4] = 8

    it = msg.map_int32_int32.items()
    del msg

    matching_dict = {2: 4, 3: 6, 4: 8}
    self.assertMapIterEquals(it, matching_dict)

  def testMapConstruction(self):
    msg = map_unittest_pb2.TestMap(map_int32_int32={1: 2, 3: 4})
    self.assertEqual(2, msg.map_int32_int32[1])
    self.assertEqual(4, msg.map_int32_int32[3])

    msg = map_unittest_pb2.TestMap(
        map_int32_foreign_message={3: unittest_pb2.ForeignMessage(c=5)})
    self.assertEqual(5, msg.map_int32_foreign_message[3].c)

  def testMapScalarFieldConstruction(self):
    msg1 = map_unittest_pb2.TestMap()
    msg1.map_int32_int32[1] = 42
    msg2 = map_unittest_pb2.TestMap(map_int32_int32=msg1.map_int32_int32)
    self.assertEqual(42, msg2.map_int32_int32[1])

  def testMapMessageFieldConstruction(self):
    msg1 = map_unittest_pb2.TestMap()
    msg1.map_string_foreign_message[&#39;test&#39;].c = 42
    msg2 = map_unittest_pb2.TestMap(
      map_string_foreign_message=msg1.map_string_foreign_message)
    self.assertEqual(42, msg2.map_string_foreign_message[&#39;test&#39;].c)

  def testMapFieldRaisesCorrectError(self):
    # Should raise a TypeError when given a non-iterable.
    with self.assertRaises(TypeError):
      map_unittest_pb2.TestMap(map_string_foreign_message=1)

  def testMapValidAfterFieldCleared(self):
    # Map needs to work even if field is cleared.
    # For the C++ implementation this tests the correctness of
    # MapContainer::Release()
    msg = map_unittest_pb2.TestMap()
    int32_map = msg.map_int32_int32

    int32_map[2] = 4
    int32_map[3] = 6
    int32_map[4] = 8

    msg.ClearField(&#39;map_int32_int32&#39;)
    self.assertEqual(b&#39;&#39;, msg.SerializeToString())
    matching_dict = {2: 4, 3: 6, 4: 8}
    self.assertMapIterEquals(int32_map.items(), matching_dict)

  def testMessageMapValidAfterFieldCleared(self):
    # Map needs to work even if field is cleared.
    # For the C++ implementation this tests the correctness of
    # MapContainer::Release()
    msg = map_unittest_pb2.TestMap()
    int32_foreign_message = msg.map_int32_foreign_message

    int32_foreign_message[2].c = 5

    msg.ClearField(&#39;map_int32_foreign_message&#39;)
    self.assertEqual(b&#39;&#39;, msg.SerializeToString())
    self.assertTrue(2 in int32_foreign_message.keys())

  def testMessageMapItemValidAfterTopMessageCleared(self):
    # Message map item needs to work even if it is cleared.
    # For the C++ implementation this tests the correctness of
    # MapContainer::Release()
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_all_types[2].optional_string = &#39;bar&#39;

    if api_implementation.Type() == &#39;cpp&#39;:
      # Need to keep the map reference because of b/27942626.
      # TODO(jieluo): Remove it.
      unused_map = msg.map_int32_all_types  # pylint: disable=unused-variable
    msg_value = msg.map_int32_all_types[2]
    msg.Clear()

    # Reset to trigger sync between repeated field and map in c++.
    msg.map_int32_all_types[3].optional_string = &#39;foo&#39;
    self.assertEqual(msg_value.optional_string, &#39;bar&#39;)

  def testMapIterInvalidatedByClearField(self):
    # Map iterator is invalidated when field is cleared.
    # But this case does need to not crash the interpreter.
    # For the C++ implementation this tests the correctness of
    # ScalarMapContainer::Release()
    msg = map_unittest_pb2.TestMap()

    it = iter(msg.map_int32_int32)

    msg.ClearField(&#39;map_int32_int32&#39;)
    with self.assertRaises(RuntimeError):
      for _ in it:
        pass

    it = iter(msg.map_int32_foreign_message)
    msg.ClearField(&#39;map_int32_foreign_message&#39;)
    with self.assertRaises(RuntimeError):
      for _ in it:
        pass

  def testMapDelete(self):
    msg = map_unittest_pb2.TestMap()

    self.assertEqual(0, len(msg.map_int32_int32))

    msg.map_int32_int32[4] = 6
    self.assertEqual(1, len(msg.map_int32_int32))

    with self.assertRaises(KeyError):
      del msg.map_int32_int32[88]

    del msg.map_int32_int32[4]
    self.assertEqual(0, len(msg.map_int32_int32))

    with self.assertRaises(KeyError):
      del msg.map_int32_all_types[32]

  def testMapsAreMapping(self):
    msg = map_unittest_pb2.TestMap()
    self.assertIsInstance(msg.map_int32_int32, collections_abc.Mapping)
    self.assertIsInstance(msg.map_int32_int32, collections_abc.MutableMapping)
    self.assertIsInstance(msg.map_int32_foreign_message, collections_abc.Mapping)
    self.assertIsInstance(msg.map_int32_foreign_message,
                          collections_abc.MutableMapping)

  def testMapsCompare(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[-123] = -456
    self.assertEqual(msg.map_int32_int32, msg.map_int32_int32)
    self.assertEqual(msg.map_int32_foreign_message,
                     msg.map_int32_foreign_message)
    self.assertNotEqual(msg.map_int32_int32, 0)

  def testMapFindInitializationErrorsSmokeTest(self):
    msg = map_unittest_pb2.TestMap()
    msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
    msg.map_int32_int32[35] = 64
    msg.map_string_foreign_message[&#39;foo&#39;].c = 5
    self.assertEqual(0, len(msg.FindInitializationErrors()))

  @unittest.skipIf(sys.maxunicode == UCS2_MAXUNICODE, &#39;Skip for ucs2&#39;)
  def testStrictUtf8Check(self):
    # Test u&#39;\ud801&#39; is rejected at parser in both python2 and python3.
    serialized = (b&#39;r\x03\xed\xa0\x81&#39;)
    msg = unittest_proto3_arena_pb2.TestAllTypes()
    with self.assertRaises(Exception) as context:
      msg.MergeFromString(serialized)
    if api_implementation.Type() == &#39;python&#39;:
      self.assertIn(&#39;optional_string&#39;, str(context.exception))
    else:
      self.assertIn(&#39;Error parsing message&#39;, str(context.exception))

    # Test optional_string=u&#39;😍&#39; is accepted.
    serialized = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;😍&#39;).SerializeToString()
    msg2 = unittest_proto3_arena_pb2.TestAllTypes()
    msg2.MergeFromString(serialized)
    self.assertEqual(msg2.optional_string, u&#39;😍&#39;)

    msg = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud001&#39;)
    self.assertEqual(msg.optional_string, u&#39;\ud001&#39;)

  @unittest.skipIf(six.PY2, &#39;Surrogates are acceptable in python2&#39;)
  def testSurrogatesInPython3(self):
    # Surrogates like U+D83D is an invalid unicode character, it is
    # supported by Python2 only because in some builds, unicode strings
    # use 2-bytes code units. Since Python 3.3, we don&#39;t have this problem.
    #
    # Surrogates are utf16 code units, in a unicode string they are invalid
    # characters even when they appear in pairs like u&#39;\ud801\udc01&#39;. Protobuf
    # Python3 reject such cases at setters and parsers. Python2 accpect it
    # to keep same features with the language itself. &#39;Unpaired pairs&#39;
    # like u&#39;\ud801&#39; are rejected at parsers when strict utf8 check is enabled
    # in proto3 to keep same behavior with c extension.

    # Surrogates are rejected at setters in Python3.
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=u&#39;\ud801\udc01&#39;)
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=b&#39;\xed\xa0\x81&#39;)
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=u&#39;\ud801&#39;)
    with self.assertRaises(ValueError):
      unittest_proto3_arena_pb2.TestAllTypes(
          optional_string=u&#39;\ud801\ud801&#39;)

  @unittest.skipIf(six.PY3 or sys.maxunicode == UCS2_MAXUNICODE,
                   &#39;Surrogates are rejected at setters in Python3&#39;)
  def testSurrogatesInPython2(self):
    # Test optional_string=u&#39;\ud801\udc01&#39;.
    # surrogate pair is acceptable in python2.
    msg = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801\udc01&#39;)
    # TODO(jieluo): Change pure python to have same behavior with c extension.
    # Some build in python2 consider u&#39;\ud801\udc01&#39; and u&#39;\U00010401&#39; are
    # equal, some are not equal.
    if api_implementation.Type() == &#39;python&#39;:
      self.assertEqual(msg.optional_string, u&#39;\ud801\udc01&#39;)
    else:
      self.assertEqual(msg.optional_string, u&#39;\U00010401&#39;)
    serialized = msg.SerializeToString()
    msg2 = unittest_proto3_arena_pb2.TestAllTypes()
    msg2.MergeFromString(serialized)
    self.assertEqual(msg2.optional_string, u&#39;\U00010401&#39;)

    # Python2 does not reject surrogates at setters.
    msg = unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=b&#39;\xed\xa0\x81&#39;)
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801&#39;)
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801\ud801&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.Proto3Test.assertMapIterEquals"><code class="name flex">
<span>def <span class="ident">assertMapIterEquals</span></span>(<span>self, map_iter, dict_value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertMapIterEquals(self, map_iter, dict_value):
  # Avoid mutating caller&#39;s copy.
  dict_value = dict(dict_value)

  for k, v in map_iter:
    self.assertEqual(v, dict_value[k])
    del dict_value[k]

  self.assertEqual({}, dict_value)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testAssignUnknownEnum"><code class="name flex">
<span>def <span class="ident">testAssignUnknownEnum</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigning an unknown enum value is allowed and preserves the value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAssignUnknownEnum(self):
  &#34;&#34;&#34;Assigning an unknown enum value is allowed and preserves the value.&#34;&#34;&#34;
  m = unittest_proto3_arena_pb2.TestAllTypes()

  # Proto3 can assign unknown enums.
  m.optional_nested_enum = 1234567
  self.assertEqual(1234567, m.optional_nested_enum)
  m.repeated_nested_enum.append(22334455)
  self.assertEqual(22334455, m.repeated_nested_enum[0])
  # Assignment is a different code path than append for the C++ impl.
  m.repeated_nested_enum[0] = 7654321
  self.assertEqual(7654321, m.repeated_nested_enum[0])
  serialized = m.SerializeToString()

  m2 = unittest_proto3_arena_pb2.TestAllTypes()
  m2.ParseFromString(serialized)
  self.assertEqual(1234567, m2.optional_nested_enum)
  self.assertEqual(7654321, m2.repeated_nested_enum[0])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testCopyFromBadType"><code class="name flex">
<span>def <span class="ident">testCopyFromBadType</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testCopyFromBadType(self):
  msg = map_unittest_pb2.TestMap()
  with self.assertRaisesRegexp(
      TypeError,
      r&#39;Parameter to [A-Za-z]*From\(\) must be instance of same class: &#39;
      r&#39;expected .*TestMap got int\.&#39;):
    msg.CopyFrom(1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testFieldPresence"><code class="name flex">
<span>def <span class="ident">testFieldPresence</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFieldPresence(self):
  message = unittest_proto3_arena_pb2.TestAllTypes()

  # We can&#39;t test presence of non-repeated, non-submessage fields.
  with self.assertRaises(ValueError):
    message.HasField(&#39;optional_int32&#39;)
  with self.assertRaises(ValueError):
    message.HasField(&#39;optional_float&#39;)
  with self.assertRaises(ValueError):
    message.HasField(&#39;optional_string&#39;)
  with self.assertRaises(ValueError):
    message.HasField(&#39;optional_bool&#39;)

  # But we can still test presence of submessage fields.
  self.assertFalse(message.HasField(&#39;optional_nested_message&#39;))

  # As with proto2, we can&#39;t test presence of fields that don&#39;t exist, or
  # repeated fields.
  with self.assertRaises(ValueError):
    message.HasField(&#39;field_doesnt_exist&#39;)

  with self.assertRaises(ValueError):
    message.HasField(&#39;repeated_int32&#39;)
  with self.assertRaises(ValueError):
    message.HasField(&#39;repeated_nested_message&#39;)

  # Fields should default to their type-specific default.
  self.assertEqual(0, message.optional_int32)
  self.assertEqual(0, message.optional_float)
  self.assertEqual(&#39;&#39;, message.optional_string)
  self.assertEqual(False, message.optional_bool)
  self.assertEqual(0, message.optional_nested_message.bb)

  # Setting a submessage should still return proper presence information.
  message.optional_nested_message.bb = 0
  self.assertTrue(message.HasField(&#39;optional_nested_message&#39;))

  # Set the fields to non-default values.
  message.optional_int32 = 5
  message.optional_float = 1.1
  message.optional_string = &#39;abc&#39;
  message.optional_bool = True
  message.optional_nested_message.bb = 15

  # Clearing the fields unsets them and resets their value to default.
  message.ClearField(&#39;optional_int32&#39;)
  message.ClearField(&#39;optional_float&#39;)
  message.ClearField(&#39;optional_string&#39;)
  message.ClearField(&#39;optional_bool&#39;)
  message.ClearField(&#39;optional_nested_message&#39;)

  self.assertEqual(0, message.optional_int32)
  self.assertEqual(0, message.optional_float)
  self.assertEqual(&#39;&#39;, message.optional_string)
  self.assertEqual(False, message.optional_bool)
  self.assertEqual(0, message.optional_nested_message.bb)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testIntegerMapWithLongs"><code class="name flex">
<span>def <span class="ident">testIntegerMapWithLongs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testIntegerMapWithLongs(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_int32[long(-123)] = long(-456)
  msg.map_int64_int64[long(-2**33)] = long(-2**34)
  msg.map_uint32_uint32[long(123)] = long(456)
  msg.map_uint64_uint64[long(2**33)] = long(2**34)

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMap()
  msg2.ParseFromString(serialized)

  self.assertEqual(-456, msg2.map_int32_int32[-123])
  self.assertEqual(-2**34, msg2.map_int64_int64[-2**33])
  self.assertEqual(456, msg2.map_uint32_uint32[123])
  self.assertEqual(2**34, msg2.map_uint64_uint64[2**33])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapAssignmentCausesPresence"><code class="name flex">
<span>def <span class="ident">testMapAssignmentCausesPresence</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapAssignmentCausesPresence(self):
  msg = map_unittest_pb2.TestMapSubmessage()
  msg.test_map.map_int32_int32[123] = 456

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMapSubmessage()
  msg2.ParseFromString(serialized)

  self.assertEqual(msg, msg2)

  # Now test that various mutations of the map properly invalidate the
  # cached size of the submessage.
  msg.test_map.map_int32_int32[888] = 999
  serialized = msg.SerializeToString()
  msg2.ParseFromString(serialized)
  self.assertEqual(msg, msg2)

  msg.test_map.map_int32_int32.clear()
  serialized = msg.SerializeToString()
  msg2.ParseFromString(serialized)
  self.assertEqual(msg, msg2)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapAssignmentCausesPresenceForSubmessages"><code class="name flex">
<span>def <span class="ident">testMapAssignmentCausesPresenceForSubmessages</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapAssignmentCausesPresenceForSubmessages(self):
  msg = map_unittest_pb2.TestMapSubmessage()
  msg.test_map.map_int32_foreign_message[123].c = 5

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMapSubmessage()
  msg2.ParseFromString(serialized)

  self.assertEqual(msg, msg2)

  # Now test that various mutations of the map properly invalidate the
  # cached size of the submessage.
  msg.test_map.map_int32_foreign_message[888].c = 7
  serialized = msg.SerializeToString()
  msg2.ParseFromString(serialized)
  self.assertEqual(msg, msg2)

  msg.test_map.map_int32_foreign_message[888].MergeFrom(
      msg.test_map.map_int32_foreign_message[123])
  serialized = msg.SerializeToString()
  msg2.ParseFromString(serialized)
  self.assertEqual(msg, msg2)

  msg.test_map.map_int32_foreign_message.clear()
  serialized = msg.SerializeToString()
  msg2.ParseFromString(serialized)
  self.assertEqual(msg, msg2)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapByteSize"><code class="name flex">
<span>def <span class="ident">testMapByteSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapByteSize(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_int32[1] = 1
  size = msg.ByteSize()
  msg.map_int32_int32[1] = 128
  self.assertEqual(msg.ByteSize(), size + 1)

  msg.map_int32_foreign_message[19].c = 1
  size = msg.ByteSize()
  msg.map_int32_foreign_message[19].c = 128
  self.assertEqual(msg.ByteSize(), size + 1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapConstruction"><code class="name flex">
<span>def <span class="ident">testMapConstruction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapConstruction(self):
  msg = map_unittest_pb2.TestMap(map_int32_int32={1: 2, 3: 4})
  self.assertEqual(2, msg.map_int32_int32[1])
  self.assertEqual(4, msg.map_int32_int32[3])

  msg = map_unittest_pb2.TestMap(
      map_int32_foreign_message={3: unittest_pb2.ForeignMessage(c=5)})
  self.assertEqual(5, msg.map_int32_foreign_message[3].c)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapDelete"><code class="name flex">
<span>def <span class="ident">testMapDelete</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapDelete(self):
  msg = map_unittest_pb2.TestMap()

  self.assertEqual(0, len(msg.map_int32_int32))

  msg.map_int32_int32[4] = 6
  self.assertEqual(1, len(msg.map_int32_int32))

  with self.assertRaises(KeyError):
    del msg.map_int32_int32[88]

  del msg.map_int32_int32[4]
  self.assertEqual(0, len(msg.map_int32_int32))

  with self.assertRaises(KeyError):
    del msg.map_int32_all_types[32]</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapDeterministicSerialization"><code class="name flex">
<span>def <span class="ident">testMapDeterministicSerialization</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapDeterministicSerialization(self):
  golden_data = (b&#39;r\x0c\n\x07init_op\x12\x01d&#39;
                 b&#39;r\n\n\x05item1\x12\x01e&#39;
                 b&#39;r\n\n\x05item2\x12\x01f&#39;
                 b&#39;r\n\n\x05item3\x12\x01g&#39;
                 b&#39;r\x0b\n\x05item4\x12\x02QQ&#39;
                 b&#39;r\x12\n\rlocal_init_op\x12\x01a&#39;
                 b&#39;r\x0e\n\tsummaries\x12\x01e&#39;
                 b&#39;r\x18\n\x13trainable_variables\x12\x01b&#39;
                 b&#39;r\x0e\n\tvariables\x12\x01c&#39;)
  msg = map_unittest_pb2.TestMap()
  msg.map_string_string[&#39;local_init_op&#39;] = &#39;a&#39;
  msg.map_string_string[&#39;trainable_variables&#39;] = &#39;b&#39;
  msg.map_string_string[&#39;variables&#39;] = &#39;c&#39;
  msg.map_string_string[&#39;init_op&#39;] = &#39;d&#39;
  msg.map_string_string[&#39;summaries&#39;] = &#39;e&#39;
  msg.map_string_string[&#39;item1&#39;] = &#39;e&#39;
  msg.map_string_string[&#39;item2&#39;] = &#39;f&#39;
  msg.map_string_string[&#39;item3&#39;] = &#39;g&#39;
  msg.map_string_string[&#39;item4&#39;] = &#39;QQ&#39;

  # If deterministic serialization is not working correctly, this will be
  # &#34;flaky&#34; depending on the exact python dict hash seed.
  #
  # Fortunately, there are enough items in this map that it is extremely
  # unlikely to ever hit the &#34;right&#34; in-order combination, so the test
  # itself should fail reliably.
  self.assertEqual(golden_data, msg.SerializeToString(deterministic=True))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapEntryAlwaysSerialized"><code class="name flex">
<span>def <span class="ident">testMapEntryAlwaysSerialized</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapEntryAlwaysSerialized(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_int32[0] = 0
  msg.map_string_string[&#39;&#39;] = &#39;&#39;
  self.assertEqual(msg.ByteSize(), 12)
  self.assertEqual(b&#39;\n\x04\x08\x00\x10\x00r\x04\n\x00\x12\x00&#39;,
                   msg.SerializeToString())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapFieldRaisesCorrectError"><code class="name flex">
<span>def <span class="ident">testMapFieldRaisesCorrectError</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapFieldRaisesCorrectError(self):
  # Should raise a TypeError when given a non-iterable.
  with self.assertRaises(TypeError):
    map_unittest_pb2.TestMap(map_string_foreign_message=1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapFindInitializationErrorsSmokeTest"><code class="name flex">
<span>def <span class="ident">testMapFindInitializationErrorsSmokeTest</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapFindInitializationErrorsSmokeTest(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
  msg.map_int32_int32[35] = 64
  msg.map_string_foreign_message[&#39;foo&#39;].c = 5
  self.assertEqual(0, len(msg.FindInitializationErrors()))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapGet"><code class="name flex">
<span>def <span class="ident">testMapGet</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapGet(self):
  # Need to test that get() properly returns the default, even though the dict
  # has defaultdict-like semantics.
  msg = map_unittest_pb2.TestMap()

  self.assertIsNone(msg.map_int32_int32.get(5))
  self.assertEqual(10, msg.map_int32_int32.get(5, 10))
  self.assertEqual(10, msg.map_int32_int32.get(key=5, default=10))
  self.assertIsNone(msg.map_int32_int32.get(5))

  msg.map_int32_int32[5] = 15
  self.assertEqual(15, msg.map_int32_int32.get(5))
  self.assertEqual(15, msg.map_int32_int32.get(5))
  with self.assertRaises(TypeError):
    msg.map_int32_int32.get(&#39;&#39;)

  self.assertIsNone(msg.map_int32_foreign_message.get(5))
  self.assertEqual(10, msg.map_int32_foreign_message.get(5, 10))
  self.assertEqual(10, msg.map_int32_foreign_message.get(key=5, default=10))

  submsg = msg.map_int32_foreign_message[5]
  self.assertIs(submsg, msg.map_int32_foreign_message.get(5))
  with self.assertRaises(TypeError):
    msg.map_int32_foreign_message.get(&#39;&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapItems"><code class="name flex">
<span>def <span class="ident">testMapItems</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapItems(self):
  # Map items used to have strange behaviors when use c extension. Because
  # [] may reorder the map and invalidate any exsting iterators.
  # TODO(jieluo): Check if [] reordering the map is a bug or intended
  # behavior.
  msg = map_unittest_pb2.TestMap()
  msg.map_string_string[&#39;local_init_op&#39;] = &#39;&#39;
  msg.map_string_string[&#39;trainable_variables&#39;] = &#39;&#39;
  msg.map_string_string[&#39;variables&#39;] = &#39;&#39;
  msg.map_string_string[&#39;init_op&#39;] = &#39;&#39;
  msg.map_string_string[&#39;summaries&#39;] = &#39;&#39;
  items1 = msg.map_string_string.items()
  items2 = msg.map_string_string.items()
  self.assertEqual(items1, items2)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapIterInvalidatedByClearField"><code class="name flex">
<span>def <span class="ident">testMapIterInvalidatedByClearField</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapIterInvalidatedByClearField(self):
  # Map iterator is invalidated when field is cleared.
  # But this case does need to not crash the interpreter.
  # For the C++ implementation this tests the correctness of
  # ScalarMapContainer::Release()
  msg = map_unittest_pb2.TestMap()

  it = iter(msg.map_int32_int32)

  msg.ClearField(&#39;map_int32_int32&#39;)
  with self.assertRaises(RuntimeError):
    for _ in it:
      pass

  it = iter(msg.map_int32_foreign_message)
  msg.ClearField(&#39;map_int32_foreign_message&#39;)
  with self.assertRaises(RuntimeError):
    for _ in it:
      pass</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapIteration"><code class="name flex">
<span>def <span class="ident">testMapIteration</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapIteration(self):
  msg = map_unittest_pb2.TestMap()

  for k, v in msg.map_int32_int32.items():
    # Should not be reached.
    self.assertTrue(False)

  msg.map_int32_int32[2] = 4
  msg.map_int32_int32[3] = 6
  msg.map_int32_int32[4] = 8
  self.assertEqual(3, len(msg.map_int32_int32))

  matching_dict = {2: 4, 3: 6, 4: 8}
  self.assertMapIterEquals(msg.map_int32_int32.items(), matching_dict)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapIterationClearMessage"><code class="name flex">
<span>def <span class="ident">testMapIterationClearMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapIterationClearMessage(self):
  # Iterator needs to work even if message and map are deleted.
  msg = map_unittest_pb2.TestMap()

  msg.map_int32_int32[2] = 4
  msg.map_int32_int32[3] = 6
  msg.map_int32_int32[4] = 8

  it = msg.map_int32_int32.items()
  del msg

  matching_dict = {2: 4, 3: 6, 4: 8}
  self.assertMapIterEquals(it, matching_dict)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapMergeFrom"><code class="name flex">
<span>def <span class="ident">testMapMergeFrom</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapMergeFrom(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_int32[12] = 34
  msg.map_int32_int32[56] = 78
  msg.map_int64_int64[22] = 33
  msg.map_int32_foreign_message[111].c = 5
  msg.map_int32_foreign_message[222].c = 10

  msg2 = map_unittest_pb2.TestMap()
  msg2.map_int32_int32[12] = 55
  msg2.map_int64_int64[88] = 99
  msg2.map_int32_foreign_message[222].c = 15
  msg2.map_int32_foreign_message[222].d = 20

  msg2.map_int32_int32.MergeFrom(msg.map_int32_int32)
  self.assertEqual(34, msg2.map_int32_int32[12])
  self.assertEqual(78, msg2.map_int32_int32[56])

  msg2.map_int64_int64.MergeFrom(msg.map_int64_int64)
  self.assertEqual(33, msg2.map_int64_int64[22])
  self.assertEqual(99, msg2.map_int64_int64[88])

  msg2.map_int32_foreign_message.MergeFrom(msg.map_int32_foreign_message)
  # Compare with expected message instead of call
  # msg.map_int32_foreign_message[222] to make sure MergeFrom does not
  # sync with repeated field and no duplicated keys.
  expected_msg = map_unittest_pb2.TestMap()
  expected_msg.CopyFrom(msg)
  expected_msg.map_int64_int64[88] = 99
  self.assertEqual(msg2, expected_msg)

  # Test when cpp extension cache a map.
  m1 = map_unittest_pb2.TestMap()
  m2 = map_unittest_pb2.TestMap()
  self.assertEqual(m1.map_int32_foreign_message,
                   m1.map_int32_foreign_message)
  m2.map_int32_foreign_message[123].c = 10
  m1.MergeFrom(m2)
  self.assertEqual(10, m2.map_int32_foreign_message[123].c)

  # Test merge maps within different message types.
  m1 = map_unittest_pb2.TestMap()
  m2 = map_unittest_pb2.TestMessageMap()
  m2.map_int32_message[123].optional_int32 = 10
  m1.map_int32_all_types.MergeFrom(m2.map_int32_message)
  self.assertEqual(10, m1.map_int32_all_types[123].optional_int32)

  # Test overwrite message value map
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_foreign_message[222].c = 123
  msg2 = map_unittest_pb2.TestMap()
  msg2.map_int32_foreign_message[222].d = 20
  msg.MergeFromString(msg2.SerializeToString())
  self.assertEqual(msg.map_int32_foreign_message[222].d, 20)
  self.assertNotEqual(msg.map_int32_foreign_message[222].c, 123)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapMessageFieldConstruction"><code class="name flex">
<span>def <span class="ident">testMapMessageFieldConstruction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapMessageFieldConstruction(self):
  msg1 = map_unittest_pb2.TestMap()
  msg1.map_string_foreign_message[&#39;test&#39;].c = 42
  msg2 = map_unittest_pb2.TestMap(
    map_string_foreign_message=msg1.map_string_foreign_message)
  self.assertEqual(42, msg2.map_string_foreign_message[&#39;test&#39;].c)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapScalarFieldConstruction"><code class="name flex">
<span>def <span class="ident">testMapScalarFieldConstruction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapScalarFieldConstruction(self):
  msg1 = map_unittest_pb2.TestMap()
  msg1.map_int32_int32[1] = 42
  msg2 = map_unittest_pb2.TestMap(map_int32_int32=msg1.map_int32_int32)
  self.assertEqual(42, msg2.map_int32_int32[1])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapValidAfterFieldCleared"><code class="name flex">
<span>def <span class="ident">testMapValidAfterFieldCleared</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapValidAfterFieldCleared(self):
  # Map needs to work even if field is cleared.
  # For the C++ implementation this tests the correctness of
  # MapContainer::Release()
  msg = map_unittest_pb2.TestMap()
  int32_map = msg.map_int32_int32

  int32_map[2] = 4
  int32_map[3] = 6
  int32_map[4] = 8

  msg.ClearField(&#39;map_int32_int32&#39;)
  self.assertEqual(b&#39;&#39;, msg.SerializeToString())
  matching_dict = {2: 4, 3: 6, 4: 8}
  self.assertMapIterEquals(int32_map.items(), matching_dict)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapsAreMapping"><code class="name flex">
<span>def <span class="ident">testMapsAreMapping</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapsAreMapping(self):
  msg = map_unittest_pb2.TestMap()
  self.assertIsInstance(msg.map_int32_int32, collections_abc.Mapping)
  self.assertIsInstance(msg.map_int32_int32, collections_abc.MutableMapping)
  self.assertIsInstance(msg.map_int32_foreign_message, collections_abc.Mapping)
  self.assertIsInstance(msg.map_int32_foreign_message,
                        collections_abc.MutableMapping)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMapsCompare"><code class="name flex">
<span>def <span class="ident">testMapsCompare</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapsCompare(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_int32[-123] = -456
  self.assertEqual(msg.map_int32_int32, msg.map_int32_int32)
  self.assertEqual(msg.map_int32_foreign_message,
                   msg.map_int32_foreign_message)
  self.assertNotEqual(msg.map_int32_int32, 0)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMergeFrom"><code class="name flex">
<span>def <span class="ident">testMergeFrom</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFrom(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_int32[12] = 34
  msg.map_int32_int32[56] = 78
  msg.map_int64_int64[22] = 33
  msg.map_int32_foreign_message[111].c = 5
  msg.map_int32_foreign_message[222].c = 10

  msg2 = map_unittest_pb2.TestMap()
  msg2.map_int32_int32[12] = 55
  msg2.map_int64_int64[88] = 99
  msg2.map_int32_foreign_message[222].c = 15
  msg2.map_int32_foreign_message[222].d = 20
  old_map_value = msg2.map_int32_foreign_message[222]

  msg2.MergeFrom(msg)
  # Compare with expected message instead of call
  # msg2.map_int32_foreign_message[222] to make sure MergeFrom does not
  # sync with repeated field and there is no duplicated keys.
  expected_msg = map_unittest_pb2.TestMap()
  expected_msg.CopyFrom(msg)
  expected_msg.map_int64_int64[88] = 99
  self.assertEqual(msg2, expected_msg)

  self.assertEqual(34, msg2.map_int32_int32[12])
  self.assertEqual(78, msg2.map_int32_int32[56])
  self.assertEqual(33, msg2.map_int64_int64[22])
  self.assertEqual(99, msg2.map_int64_int64[88])
  self.assertEqual(5, msg2.map_int32_foreign_message[111].c)
  self.assertEqual(10, msg2.map_int32_foreign_message[222].c)
  self.assertFalse(msg2.map_int32_foreign_message[222].HasField(&#39;d&#39;))
  if api_implementation.Type() != &#39;cpp&#39;:
    # During the call to MergeFrom(), the C++ implementation will have
    # deallocated the underlying message, but this is very difficult to detect
    # properly. The line below is likely to cause a segmentation fault.
    # With the Python implementation, old_map_value is just &#39;detached&#39; from
    # the main message. Using it will not crash of course, but since it still
    # have a reference to the parent message I&#39;m sure we can find interesting
    # ways to cause inconsistencies.
    self.assertEqual(15, old_map_value.c)

  # Verify that there is only one entry per key, even though the MergeFrom
  # may have internally created multiple entries for a single key in the
  # list representation.
  as_dict = {}
  for key in msg2.map_int32_foreign_message:
    self.assertFalse(key in as_dict)
    as_dict[key] = msg2.map_int32_foreign_message[key].c

  self.assertEqual({111: 5, 222: 10}, as_dict)

  # Special case: test that delete of item really removes the item, even if
  # there might have physically been duplicate keys due to the previous merge.
  # This is only a special case for the C++ implementation which stores the
  # map as an array.
  del msg2.map_int32_int32[12]
  self.assertFalse(12 in msg2.map_int32_int32)

  del msg2.map_int32_foreign_message[222]
  self.assertFalse(222 in msg2.map_int32_foreign_message)
  with self.assertRaises(TypeError):
    del msg2.map_int32_foreign_message[&#39;&#39;]</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMergeFromBadType"><code class="name flex">
<span>def <span class="ident">testMergeFromBadType</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMergeFromBadType(self):
  msg = map_unittest_pb2.TestMap()
  with self.assertRaisesRegexp(
      TypeError,
      r&#39;Parameter to MergeFrom\(\) must be instance of same class: expected &#39;
      r&#39;.*TestMap got int\.&#39;):
    msg.MergeFrom(1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMessageMap"><code class="name flex">
<span>def <span class="ident">testMessageMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMessageMap(self):
  msg = map_unittest_pb2.TestMap()

  self.assertEqual(0, len(msg.map_int32_foreign_message))
  self.assertFalse(5 in msg.map_int32_foreign_message)

  msg.map_int32_foreign_message[123]
  # get_or_create() is an alias for getitem.
  msg.map_int32_foreign_message.get_or_create(-456)

  self.assertEqual(2, len(msg.map_int32_foreign_message))
  self.assertIn(123, msg.map_int32_foreign_message)
  self.assertIn(-456, msg.map_int32_foreign_message)
  self.assertEqual(2, len(msg.map_int32_foreign_message))

  # Bad key.
  with self.assertRaises(TypeError):
    msg.map_int32_foreign_message[&#39;123&#39;]

  # Can&#39;t assign directly to submessage.
  with self.assertRaises(ValueError):
    msg.map_int32_foreign_message[999] = msg.map_int32_foreign_message[123]

  # Verify that trying to assign a bad key doesn&#39;t actually add a member to
  # the map.
  self.assertEqual(2, len(msg.map_int32_foreign_message))

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMap()
  msg2.ParseFromString(serialized)

  self.assertEqual(2, len(msg2.map_int32_foreign_message))
  self.assertIn(123, msg2.map_int32_foreign_message)
  self.assertIn(-456, msg2.map_int32_foreign_message)
  self.assertEqual(2, len(msg2.map_int32_foreign_message))
  msg2.map_int32_foreign_message[123].c = 1
  # TODO(jieluo): Fix text format for message map.
  self.assertIn(str(msg2.map_int32_foreign_message),
                (&#39;{-456: , 123: c: 1\n}&#39;, &#39;{123: c: 1\n, -456: }&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMessageMapItemValidAfterTopMessageCleared"><code class="name flex">
<span>def <span class="ident">testMessageMapItemValidAfterTopMessageCleared</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMessageMapItemValidAfterTopMessageCleared(self):
  # Message map item needs to work even if it is cleared.
  # For the C++ implementation this tests the correctness of
  # MapContainer::Release()
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_all_types[2].optional_string = &#39;bar&#39;

  if api_implementation.Type() == &#39;cpp&#39;:
    # Need to keep the map reference because of b/27942626.
    # TODO(jieluo): Remove it.
    unused_map = msg.map_int32_all_types  # pylint: disable=unused-variable
  msg_value = msg.map_int32_all_types[2]
  msg.Clear()

  # Reset to trigger sync between repeated field and map in c++.
  msg.map_int32_all_types[3].optional_string = &#39;foo&#39;
  self.assertEqual(msg_value.optional_string, &#39;bar&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testMessageMapValidAfterFieldCleared"><code class="name flex">
<span>def <span class="ident">testMessageMapValidAfterFieldCleared</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMessageMapValidAfterFieldCleared(self):
  # Map needs to work even if field is cleared.
  # For the C++ implementation this tests the correctness of
  # MapContainer::Release()
  msg = map_unittest_pb2.TestMap()
  int32_foreign_message = msg.map_int32_foreign_message

  int32_foreign_message[2].c = 5

  msg.ClearField(&#39;map_int32_foreign_message&#39;)
  self.assertEqual(b&#39;&#39;, msg.SerializeToString())
  self.assertTrue(2 in int32_foreign_message.keys())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testModifyMapWhileIterating"><code class="name flex">
<span>def <span class="ident">testModifyMapWhileIterating</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testModifyMapWhileIterating(self):
  msg = map_unittest_pb2.TestMap()

  string_string_iter = iter(msg.map_string_string)
  int32_foreign_iter = iter(msg.map_int32_foreign_message)

  msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
  msg.map_int32_foreign_message[5].c = 5

  with self.assertRaises(RuntimeError):
    for key in string_string_iter:
      pass

  with self.assertRaises(RuntimeError):
    for key in int32_foreign_iter:
      pass</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testNestedMessageMapItemDelete"><code class="name flex">
<span>def <span class="ident">testNestedMessageMapItemDelete</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNestedMessageMapItemDelete(self):
  msg = map_unittest_pb2.TestMap()
  msg.map_int32_all_types[1].optional_nested_message.bb = 1
  del msg.map_int32_all_types[1]
  msg.map_int32_all_types[2].optional_nested_message.bb = 2
  self.assertEqual(1, len(msg.map_int32_all_types))
  msg.map_int32_all_types[1].optional_nested_message.bb = 1
  self.assertEqual(2, len(msg.map_int32_all_types))

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMap()
  msg2.ParseFromString(serialized)
  keys = [1, 2]
  # The loop triggers PyErr_Occurred() in c extension.
  for key in keys:
    del msg2.map_int32_all_types[key]</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testPython2Map"><code class="name flex">
<span>def <span class="ident">testPython2Map</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPython2Map(self):
  if sys.version_info &lt; (3,):
    msg = map_unittest_pb2.TestMap()
    msg.map_int32_int32[2] = 4
    msg.map_int32_int32[3] = 6
    msg.map_int32_int32[4] = 8
    msg.map_int32_int32[5] = 10
    map_int32 = msg.map_int32_int32
    self.assertEqual(4, len(map_int32))
    msg2 = map_unittest_pb2.TestMap()
    msg2.ParseFromString(msg.SerializeToString())

    def CheckItems(seq, iterator):
      self.assertEqual(next(iterator), seq[0])
      self.assertEqual(list(iterator), seq[1:])

    CheckItems(map_int32.items(), map_int32.iteritems())
    CheckItems(map_int32.keys(), map_int32.iterkeys())
    CheckItems(map_int32.values(), map_int32.itervalues())

    self.assertEqual(6, map_int32.get(3))
    self.assertEqual(None, map_int32.get(999))
    self.assertEqual(6, map_int32.pop(3))
    self.assertEqual(0, map_int32.pop(3))
    self.assertEqual(3, len(map_int32))
    key, value = map_int32.popitem()
    self.assertEqual(2 * key, value)
    self.assertEqual(2, len(map_int32))
    map_int32.clear()
    self.assertEqual(0, len(map_int32))

    with self.assertRaises(KeyError):
      map_int32.popitem()

    self.assertEqual(0, map_int32.setdefault(2))
    self.assertEqual(1, len(map_int32))

    map_int32.update(msg2.map_int32_int32)
    self.assertEqual(4, len(map_int32))

    with self.assertRaises(TypeError):
      map_int32.update(msg2.map_int32_int32,
                       msg2.map_int32_int32)
    with self.assertRaises(TypeError):
      map_int32.update(0)
    with self.assertRaises(TypeError):
      map_int32.update(value=12)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testScalarMap"><code class="name flex">
<span>def <span class="ident">testScalarMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testScalarMap(self):
  msg = map_unittest_pb2.TestMap()

  self.assertEqual(0, len(msg.map_int32_int32))
  self.assertFalse(5 in msg.map_int32_int32)

  msg.map_int32_int32[-123] = -456
  msg.map_int64_int64[-2**33] = -2**34
  msg.map_uint32_uint32[123] = 456
  msg.map_uint64_uint64[2**33] = 2**34
  msg.map_int32_float[2] = 1.2
  msg.map_int32_double[1] = 3.3
  msg.map_string_string[&#39;abc&#39;] = &#39;123&#39;
  msg.map_bool_bool[True] = True
  msg.map_int32_enum[888] = 2
  # Unknown numeric enum is supported in proto3.
  msg.map_int32_enum[123] = 456

  self.assertEqual([], msg.FindInitializationErrors())

  self.assertEqual(1, len(msg.map_string_string))

  # Bad key.
  with self.assertRaises(TypeError):
    msg.map_string_string[123] = &#39;123&#39;

  # Verify that trying to assign a bad key doesn&#39;t actually add a member to
  # the map.
  self.assertEqual(1, len(msg.map_string_string))

  # Bad value.
  with self.assertRaises(TypeError):
    msg.map_string_string[&#39;123&#39;] = 123

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMap()
  msg2.ParseFromString(serialized)

  # Bad key.
  with self.assertRaises(TypeError):
    msg2.map_string_string[123] = &#39;123&#39;

  # Bad value.
  with self.assertRaises(TypeError):
    msg2.map_string_string[&#39;123&#39;] = 123

  self.assertEqual(-456, msg2.map_int32_int32[-123])
  self.assertEqual(-2**34, msg2.map_int64_int64[-2**33])
  self.assertEqual(456, msg2.map_uint32_uint32[123])
  self.assertEqual(2**34, msg2.map_uint64_uint64[2**33])
  self.assertAlmostEqual(1.2, msg.map_int32_float[2])
  self.assertEqual(3.3, msg.map_int32_double[1])
  self.assertEqual(&#39;123&#39;, msg2.map_string_string[&#39;abc&#39;])
  self.assertEqual(True, msg2.map_bool_bool[True])
  self.assertEqual(2, msg2.map_int32_enum[888])
  self.assertEqual(456, msg2.map_int32_enum[123])
  self.assertEqual(&#39;{-123: -456}&#39;,
                   str(msg2.map_int32_int32))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testScalarMapDefaults"><code class="name flex">
<span>def <span class="ident">testScalarMapDefaults</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testScalarMapDefaults(self):
  msg = map_unittest_pb2.TestMap()

  # Scalars start out unset.
  self.assertFalse(-123 in msg.map_int32_int32)
  self.assertFalse(-2**33 in msg.map_int64_int64)
  self.assertFalse(123 in msg.map_uint32_uint32)
  self.assertFalse(2**33 in msg.map_uint64_uint64)
  self.assertFalse(123 in msg.map_int32_double)
  self.assertFalse(False in msg.map_bool_bool)
  self.assertFalse(&#39;abc&#39; in msg.map_string_string)
  self.assertFalse(111 in msg.map_int32_bytes)
  self.assertFalse(888 in msg.map_int32_enum)

  # Accessing an unset key returns the default.
  self.assertEqual(0, msg.map_int32_int32[-123])
  self.assertEqual(0, msg.map_int64_int64[-2**33])
  self.assertEqual(0, msg.map_uint32_uint32[123])
  self.assertEqual(0, msg.map_uint64_uint64[2**33])
  self.assertEqual(0.0, msg.map_int32_double[123])
  self.assertTrue(isinstance(msg.map_int32_double[123], float))
  self.assertEqual(False, msg.map_bool_bool[False])
  self.assertTrue(isinstance(msg.map_bool_bool[False], bool))
  self.assertEqual(&#39;&#39;, msg.map_string_string[&#39;abc&#39;])
  self.assertEqual(b&#39;&#39;, msg.map_int32_bytes[111])
  self.assertEqual(0, msg.map_int32_enum[888])

  # It also sets the value in the map
  self.assertTrue(-123 in msg.map_int32_int32)
  self.assertTrue(-2**33 in msg.map_int64_int64)
  self.assertTrue(123 in msg.map_uint32_uint32)
  self.assertTrue(2**33 in msg.map_uint64_uint64)
  self.assertTrue(123 in msg.map_int32_double)
  self.assertTrue(False in msg.map_bool_bool)
  self.assertTrue(&#39;abc&#39; in msg.map_string_string)
  self.assertTrue(111 in msg.map_int32_bytes)
  self.assertTrue(888 in msg.map_int32_enum)

  self.assertIsInstance(msg.map_string_string[&#39;abc&#39;], six.text_type)

  # Accessing an unset key still throws TypeError if the type of the key
  # is incorrect.
  with self.assertRaises(TypeError):
    msg.map_string_string[123]

  with self.assertRaises(TypeError):
    123 in msg.map_string_string</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testStrictUtf8Check"><code class="name flex">
<span>def <span class="ident">testStrictUtf8Check</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(sys.maxunicode == UCS2_MAXUNICODE, &#39;Skip for ucs2&#39;)
def testStrictUtf8Check(self):
  # Test u&#39;\ud801&#39; is rejected at parser in both python2 and python3.
  serialized = (b&#39;r\x03\xed\xa0\x81&#39;)
  msg = unittest_proto3_arena_pb2.TestAllTypes()
  with self.assertRaises(Exception) as context:
    msg.MergeFromString(serialized)
  if api_implementation.Type() == &#39;python&#39;:
    self.assertIn(&#39;optional_string&#39;, str(context.exception))
  else:
    self.assertIn(&#39;Error parsing message&#39;, str(context.exception))

  # Test optional_string=u&#39;😍&#39; is accepted.
  serialized = unittest_proto3_arena_pb2.TestAllTypes(
      optional_string=u&#39;😍&#39;).SerializeToString()
  msg2 = unittest_proto3_arena_pb2.TestAllTypes()
  msg2.MergeFromString(serialized)
  self.assertEqual(msg2.optional_string, u&#39;😍&#39;)

  msg = unittest_proto3_arena_pb2.TestAllTypes(
      optional_string=u&#39;\ud001&#39;)
  self.assertEqual(msg.optional_string, u&#39;\ud001&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testStringUnicodeConversionInMap"><code class="name flex">
<span>def <span class="ident">testStringUnicodeConversionInMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testStringUnicodeConversionInMap(self):
  msg = map_unittest_pb2.TestMap()

  unicode_obj = u&#39;\u1234&#39;
  bytes_obj = unicode_obj.encode(&#39;utf8&#39;)

  msg.map_string_string[bytes_obj] = bytes_obj

  (key, value) = list(msg.map_string_string.items())[0]

  self.assertEqual(key, unicode_obj)
  self.assertEqual(value, unicode_obj)

  self.assertIsInstance(key, six.text_type)
  self.assertIsInstance(value, six.text_type)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testSubmessageMap"><code class="name flex">
<span>def <span class="ident">testSubmessageMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSubmessageMap(self):
  msg = map_unittest_pb2.TestMap()

  submsg = msg.map_int32_foreign_message[111]
  self.assertIs(submsg, msg.map_int32_foreign_message[111])
  self.assertIsInstance(submsg, unittest_pb2.ForeignMessage)

  submsg.c = 5

  serialized = msg.SerializeToString()
  msg2 = map_unittest_pb2.TestMap()
  msg2.ParseFromString(serialized)

  self.assertEqual(5, msg2.map_int32_foreign_message[111].c)

  # Doesn&#39;t allow direct submessage assignment.
  with self.assertRaises(ValueError):
    msg.map_int32_foreign_message[88] = unittest_pb2.ForeignMessage()</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testSurrogatesInPython2"><code class="name flex">
<span>def <span class="ident">testSurrogatesInPython2</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(six.PY3 or sys.maxunicode == UCS2_MAXUNICODE,
                 &#39;Surrogates are rejected at setters in Python3&#39;)
def testSurrogatesInPython2(self):
  # Test optional_string=u&#39;\ud801\udc01&#39;.
  # surrogate pair is acceptable in python2.
  msg = unittest_proto3_arena_pb2.TestAllTypes(
      optional_string=u&#39;\ud801\udc01&#39;)
  # TODO(jieluo): Change pure python to have same behavior with c extension.
  # Some build in python2 consider u&#39;\ud801\udc01&#39; and u&#39;\U00010401&#39; are
  # equal, some are not equal.
  if api_implementation.Type() == &#39;python&#39;:
    self.assertEqual(msg.optional_string, u&#39;\ud801\udc01&#39;)
  else:
    self.assertEqual(msg.optional_string, u&#39;\U00010401&#39;)
  serialized = msg.SerializeToString()
  msg2 = unittest_proto3_arena_pb2.TestAllTypes()
  msg2.MergeFromString(serialized)
  self.assertEqual(msg2.optional_string, u&#39;\U00010401&#39;)

  # Python2 does not reject surrogates at setters.
  msg = unittest_proto3_arena_pb2.TestAllTypes(
      optional_string=b&#39;\xed\xa0\x81&#39;)
  unittest_proto3_arena_pb2.TestAllTypes(
      optional_string=u&#39;\ud801&#39;)
  unittest_proto3_arena_pb2.TestAllTypes(
      optional_string=u&#39;\ud801\ud801&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.Proto3Test.testSurrogatesInPython3"><code class="name flex">
<span>def <span class="ident">testSurrogatesInPython3</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@unittest.skipIf(six.PY2, &#39;Surrogates are acceptable in python2&#39;)
def testSurrogatesInPython3(self):
  # Surrogates like U+D83D is an invalid unicode character, it is
  # supported by Python2 only because in some builds, unicode strings
  # use 2-bytes code units. Since Python 3.3, we don&#39;t have this problem.
  #
  # Surrogates are utf16 code units, in a unicode string they are invalid
  # characters even when they appear in pairs like u&#39;\ud801\udc01&#39;. Protobuf
  # Python3 reject such cases at setters and parsers. Python2 accpect it
  # to keep same features with the language itself. &#39;Unpaired pairs&#39;
  # like u&#39;\ud801&#39; are rejected at parsers when strict utf8 check is enabled
  # in proto3 to keep same behavior with c extension.

  # Surrogates are rejected at setters in Python3.
  with self.assertRaises(ValueError):
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801\udc01&#39;)
  with self.assertRaises(ValueError):
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=b&#39;\xed\xa0\x81&#39;)
  with self.assertRaises(ValueError):
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801&#39;)
  with self.assertRaises(ValueError):
    unittest_proto3_arena_pb2.TestAllTypes(
        optional_string=u&#39;\ud801\ud801&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.message_test.ValidTypeNamesTest"><code class="flex name class">
<span>class <span class="ident">ValidTypeNamesTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidTypeNamesTest(unittest.TestCase):

  def assertImportFromName(self, msg, base_name):
    # Parse &lt;type &#39;module.class_name&#39;&gt; to extra &#39;some.name&#39; as a string.
    tp_name = str(type(msg)).split(&#34;&#39;&#34;)[1]
    valid_names = (&#39;Repeated%sContainer&#39; % base_name,
                   &#39;Repeated%sFieldContainer&#39; % base_name)
    self.assertTrue(any(tp_name.endswith(v) for v in valid_names),
                    &#39;%r does end with any of %r&#39; % (tp_name, valid_names))

    parts = tp_name.split(&#39;.&#39;)
    class_name = parts[-1]
    module_name = &#39;.&#39;.join(parts[:-1])
    __import__(module_name, fromlist=[class_name])

  def testTypeNamesCanBeImported(self):
    # If import doesn&#39;t work, pickling won&#39;t work either.
    pb = unittest_pb2.TestAllTypes()
    self.assertImportFromName(pb.repeated_int32, &#39;Scalar&#39;)
    self.assertImportFromName(pb.repeated_nested_message, &#39;Composite&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.message_test.ValidTypeNamesTest.assertImportFromName"><code class="name flex">
<span>def <span class="ident">assertImportFromName</span></span>(<span>self, msg, base_name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assertImportFromName(self, msg, base_name):
  # Parse &lt;type &#39;module.class_name&#39;&gt; to extra &#39;some.name&#39; as a string.
  tp_name = str(type(msg)).split(&#34;&#39;&#34;)[1]
  valid_names = (&#39;Repeated%sContainer&#39; % base_name,
                 &#39;Repeated%sFieldContainer&#39; % base_name)
  self.assertTrue(any(tp_name.endswith(v) for v in valid_names),
                  &#39;%r does end with any of %r&#39; % (tp_name, valid_names))

  parts = tp_name.split(&#39;.&#39;)
  class_name = parts[-1]
  module_name = &#39;.&#39;.join(parts[:-1])
  __import__(module_name, fromlist=[class_name])</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.message_test.ValidTypeNamesTest.testTypeNamesCanBeImported"><code class="name flex">
<span>def <span class="ident">testTypeNamesCanBeImported</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTypeNamesCanBeImported(self):
  # If import doesn&#39;t work, pickling won&#39;t work either.
  pb = unittest_pb2.TestAllTypes()
  self.assertImportFromName(pb.repeated_int32, &#39;Scalar&#39;)
  self.assertImportFromName(pb.repeated_nested_message, &#39;Composite&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.protobuf.internal" href="index.html">google.protobuf.internal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.IsNegInf" href="#google.protobuf.internal.message_test.IsNegInf">IsNegInf</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.IsPosInf" href="#google.protobuf.internal.message_test.IsPosInf">IsPosInf</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.cmp" href="#google.protobuf.internal.message_test.cmp">cmp</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.isinf" href="#google.protobuf.internal.message_test.isinf">isinf</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.isnan" href="#google.protobuf.internal.message_test.isnan">isnan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.protobuf.internal.message_test.MessageTest" href="#google.protobuf.internal.message_test.MessageTest">MessageTest</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.MessageTest.FALSY_VALUES" href="#google.protobuf.internal.message_test.MessageTest.FALSY_VALUES">FALSY_VALUES</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.TestIterable" href="#google.protobuf.internal.message_test.MessageTest.TestIterable">TestIterable</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.ensureNestedMessageExists" href="#google.protobuf.internal.message_test.MessageTest.ensureNestedMessageExists">ensureNestedMessageExists</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testAddWrongRepeatedNestedField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testAddWrongRepeatedNestedField_proto2">testAddWrongRepeatedNestedField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testAddWrongRepeatedNestedField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testAddWrongRepeatedNestedField_proto3">testAddWrongRepeatedNestedField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testAppendRepeatedCompositeField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testAppendRepeatedCompositeField_proto2">testAppendRepeatedCompositeField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testAppendRepeatedCompositeField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testAppendRepeatedCompositeField_proto3">testAppendRepeatedCompositeField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testAssignByteStringToUnicodeField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testAssignByteStringToUnicodeField_proto2">testAssignByteStringToUnicodeField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testAssignByteStringToUnicodeField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testAssignByteStringToUnicodeField_proto3">testAssignByteStringToUnicodeField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testBadUtf8String_proto2" href="#google.protobuf.internal.message_test.MessageTest.testBadUtf8String_proto2">testBadUtf8String_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testBadUtf8String_proto3" href="#google.protobuf.internal.message_test.MessageTest.testBadUtf8String_proto3">testBadUtf8String_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testDeterminismParameters_proto2" href="#google.protobuf.internal.message_test.MessageTest.testDeterminismParameters_proto2">testDeterminismParameters_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testDeterminismParameters_proto3" href="#google.protobuf.internal.message_test.MessageTest.testDeterminismParameters_proto3">testDeterminismParameters_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithIterable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendFloatWithIterable_proto2">testExtendFloatWithIterable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithIterable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendFloatWithIterable_proto3">testExtendFloatWithIterable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithNothing_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendFloatWithNothing_proto2">testExtendFloatWithNothing_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithNothing_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendFloatWithNothing_proto3">testExtendFloatWithNothing_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithPythonList_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendFloatWithPythonList_proto2">testExtendFloatWithPythonList_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendFloatWithPythonList_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendFloatWithPythonList_proto3">testExtendFloatWithPythonList_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithIterable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendInt32WithIterable_proto2">testExtendInt32WithIterable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithIterable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendInt32WithIterable_proto3">testExtendInt32WithIterable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithNothing_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendInt32WithNothing_proto2">testExtendInt32WithNothing_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithNothing_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendInt32WithNothing_proto3">testExtendInt32WithNothing_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithPythonList_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendInt32WithPythonList_proto2">testExtendInt32WithPythonList_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendInt32WithPythonList_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendInt32WithPythonList_proto3">testExtendInt32WithPythonList_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendShouldNotSwallowExceptions_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendShouldNotSwallowExceptions_proto2">testExtendShouldNotSwallowExceptions_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendShouldNotSwallowExceptions_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendShouldNotSwallowExceptions_proto3">testExtendShouldNotSwallowExceptions_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithIterable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithIterable_proto2">testExtendStringWithIterable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithIterable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithIterable_proto3">testExtendStringWithIterable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithNothing_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithNothing_proto2">testExtendStringWithNothing_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithNothing_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithNothing_proto3">testExtendStringWithNothing_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithPythonList_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithPythonList_proto2">testExtendStringWithPythonList_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithPythonList_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithPythonList_proto3">testExtendStringWithPythonList_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithString_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithString_proto2">testExtendStringWithString_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtendStringWithString_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtendStringWithString_proto3">testExtendStringWithString_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtremeDoubleValues_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtremeDoubleValues_proto2">testExtremeDoubleValues_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtremeDoubleValues_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtremeDoubleValues_proto3">testExtremeDoubleValues_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtremeFloatValues_proto2" href="#google.protobuf.internal.message_test.MessageTest.testExtremeFloatValues_proto2">testExtremeFloatValues_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testExtremeFloatValues_proto3" href="#google.protobuf.internal.message_test.MessageTest.testExtremeFloatValues_proto3">testExtremeFloatValues_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testFloatPrinting_proto2" href="#google.protobuf.internal.message_test.MessageTest.testFloatPrinting_proto2">testFloatPrinting_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testFloatPrinting_proto3" href="#google.protobuf.internal.message_test.MessageTest.testFloatPrinting_proto3">testFloatPrinting_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testGoldenMessage_proto2" href="#google.protobuf.internal.message_test.MessageTest.testGoldenMessage_proto2">testGoldenMessage_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testGoldenMessage_proto3" href="#google.protobuf.internal.message_test.MessageTest.testGoldenMessage_proto3">testGoldenMessage_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testGoldenPackedMessage_proto2" href="#google.protobuf.internal.message_test.MessageTest.testGoldenPackedMessage_proto2">testGoldenPackedMessage_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testGoldenPackedMessage_proto3" href="#google.protobuf.internal.message_test.MessageTest.testGoldenPackedMessage_proto3">testGoldenPackedMessage_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testHasFieldOnRepeatedField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testHasFieldOnRepeatedField_proto2">testHasFieldOnRepeatedField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testHasFieldOnRepeatedField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testHasFieldOnRepeatedField_proto3">testHasFieldOnRepeatedField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testHighPrecisionFloatPrinting_proto2" href="#google.protobuf.internal.message_test.MessageTest.testHighPrecisionFloatPrinting_proto2">testHighPrecisionFloatPrinting_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testHighPrecisionFloatPrinting_proto3" href="#google.protobuf.internal.message_test.MessageTest.testHighPrecisionFloatPrinting_proto3">testHighPrecisionFloatPrinting_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testInsertRepeatedCompositeField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testInsertRepeatedCompositeField_proto2">testInsertRepeatedCompositeField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testInsertRepeatedCompositeField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testInsertRepeatedCompositeField_proto3">testInsertRepeatedCompositeField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testLongValuedSlice_proto2" href="#google.protobuf.internal.message_test.MessageTest.testLongValuedSlice_proto2">testLongValuedSlice_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testLongValuedSlice_proto3" href="#google.protobuf.internal.message_test.MessageTest.testLongValuedSlice_proto3">testLongValuedSlice_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromEmpty_proto2" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromEmpty_proto2">testMergeFromEmpty_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromEmpty_proto3" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromEmpty_proto3">testMergeFromEmpty_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromRepeatedField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromRepeatedField_proto2">testMergeFromRepeatedField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromRepeatedField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromRepeatedField_proto3">testMergeFromRepeatedField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewIsPy2Error_proto2" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewIsPy2Error_proto2">testMergeFromStringUsingMemoryViewIsPy2Error_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewIsPy2Error_proto3" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewIsPy2Error_proto3">testMergeFromStringUsingMemoryViewIsPy2Error_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewWorksInPy3_proto2" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewWorksInPy3_proto2">testMergeFromStringUsingMemoryViewWorksInPy3_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewWorksInPy3_proto3" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromStringUsingMemoryViewWorksInPy3_proto3">testMergeFromStringUsingMemoryViewWorksInPy3_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromString_proto2" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromString_proto2">testMergeFromString_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFromString_proto3" href="#google.protobuf.internal.message_test.MessageTest.testMergeFromString_proto3">testMergeFromString_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFrom_proto2" href="#google.protobuf.internal.message_test.MessageTest.testMergeFrom_proto2">testMergeFrom_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testMergeFrom_proto3" href="#google.protobuf.internal.message_test.MessageTest.testMergeFrom_proto3">testMergeFrom_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNegativeInfinityPacked_proto2" href="#google.protobuf.internal.message_test.MessageTest.testNegativeInfinityPacked_proto2">testNegativeInfinityPacked_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNegativeInfinityPacked_proto3" href="#google.protobuf.internal.message_test.MessageTest.testNegativeInfinityPacked_proto3">testNegativeInfinityPacked_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNegativeInfinity_proto2" href="#google.protobuf.internal.message_test.MessageTest.testNegativeInfinity_proto2">testNegativeInfinity_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNegativeInfinity_proto3" href="#google.protobuf.internal.message_test.MessageTest.testNegativeInfinity_proto3">testNegativeInfinity_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNotANumberPacked_proto2" href="#google.protobuf.internal.message_test.MessageTest.testNotANumberPacked_proto2">testNotANumberPacked_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNotANumberPacked_proto3" href="#google.protobuf.internal.message_test.MessageTest.testNotANumberPacked_proto3">testNotANumberPacked_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNotANumber_proto2" href="#google.protobuf.internal.message_test.MessageTest.testNotANumber_proto2">testNotANumber_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testNotANumber_proto3" href="#google.protobuf.internal.message_test.MessageTest.testNotANumber_proto3">testNotANumber_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClearField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofClearField_proto2">testOneofClearField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClearField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofClearField_proto3">testOneofClearField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClearSetField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofClearSetField_proto2">testOneofClearSetField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClearSetField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofClearSetField_proto3">testOneofClearSetField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClearUnsetField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofClearUnsetField_proto2">testOneofClearUnsetField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClearUnsetField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofClearUnsetField_proto3">testOneofClearUnsetField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClear_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofClear_proto2">testOneofClear_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofClear_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofClear_proto3">testOneofClear_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofCompositeFieldReadAccess_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofCompositeFieldReadAccess_proto2">testOneofCompositeFieldReadAccess_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofCompositeFieldReadAccess_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofCompositeFieldReadAccess_proto3">testOneofCompositeFieldReadAccess_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofCopyFrom_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofCopyFrom_proto2">testOneofCopyFrom_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofCopyFrom_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofCopyFrom_proto3">testOneofCopyFrom_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofDefaultValues_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofDefaultValues_proto2">testOneofDefaultValues_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofDefaultValues_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofDefaultValues_proto3">testOneofDefaultValues_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofDeserialize_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofDeserialize_proto2">testOneofDeserialize_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofDeserialize_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofDeserialize_proto3">testOneofDeserialize_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofGetCaseNonexistingField_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofGetCaseNonexistingField_proto2">testOneofGetCaseNonexistingField_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofGetCaseNonexistingField_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofGetCaseNonexistingField_proto3">testOneofGetCaseNonexistingField_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofMessageMergeFrom_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofMessageMergeFrom_proto2">testOneofMessageMergeFrom_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofMessageMergeFrom_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofMessageMergeFrom_proto3">testOneofMessageMergeFrom_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofNestedMergeFrom_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofNestedMergeFrom_proto2">testOneofNestedMergeFrom_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofNestedMergeFrom_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofNestedMergeFrom_proto3">testOneofNestedMergeFrom_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofNestedMessageInit_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofNestedMessageInit_proto2">testOneofNestedMessageInit_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofNestedMessageInit_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofNestedMessageInit_proto3">testOneofNestedMessageInit_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofSemantics_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofSemantics_proto2">testOneofSemantics_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofSemantics_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofSemantics_proto3">testOneofSemantics_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofWhichOneof_proto2" href="#google.protobuf.internal.message_test.MessageTest.testOneofWhichOneof_proto2">testOneofWhichOneof_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testOneofWhichOneof_proto3" href="#google.protobuf.internal.message_test.MessageTest.testOneofWhichOneof_proto3">testOneofWhichOneof_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testParseErrors_proto2" href="#google.protobuf.internal.message_test.MessageTest.testParseErrors_proto2">testParseErrors_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testParseErrors_proto3" href="#google.protobuf.internal.message_test.MessageTest.testParseErrors_proto3">testParseErrors_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleNestedMessage_proto2" href="#google.protobuf.internal.message_test.MessageTest.testPickleNestedMessage_proto2">testPickleNestedMessage_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleNestedMessage_proto3" href="#google.protobuf.internal.message_test.MessageTest.testPickleNestedMessage_proto3">testPickleNestedMessage_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleNestedNestedMessage_proto2" href="#google.protobuf.internal.message_test.MessageTest.testPickleNestedNestedMessage_proto2">testPickleNestedNestedMessage_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleNestedNestedMessage_proto3" href="#google.protobuf.internal.message_test.MessageTest.testPickleNestedNestedMessage_proto3">testPickleNestedNestedMessage_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleRepeatedScalarContainer_proto2" href="#google.protobuf.internal.message_test.MessageTest.testPickleRepeatedScalarContainer_proto2">testPickleRepeatedScalarContainer_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleRepeatedScalarContainer_proto3" href="#google.protobuf.internal.message_test.MessageTest.testPickleRepeatedScalarContainer_proto3">testPickleRepeatedScalarContainer_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleSupport_proto2" href="#google.protobuf.internal.message_test.MessageTest.testPickleSupport_proto2">testPickleSupport_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPickleSupport_proto3" href="#google.protobuf.internal.message_test.MessageTest.testPickleSupport_proto3">testPickleSupport_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPositiveInfinityPacked_proto2" href="#google.protobuf.internal.message_test.MessageTest.testPositiveInfinityPacked_proto2">testPositiveInfinityPacked_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPositiveInfinityPacked_proto3" href="#google.protobuf.internal.message_test.MessageTest.testPositiveInfinityPacked_proto3">testPositiveInfinityPacked_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPositiveInfinity_proto2" href="#google.protobuf.internal.message_test.MessageTest.testPositiveInfinity_proto2">testPositiveInfinity_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testPositiveInfinity_proto3" href="#google.protobuf.internal.message_test.MessageTest.testPositiveInfinity_proto3">testPositiveInfinity_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testReleasedNestedMessages_proto2" href="#google.protobuf.internal.message_test.MessageTest.testReleasedNestedMessages_proto2">testReleasedNestedMessages_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testReleasedNestedMessages_proto3" href="#google.protobuf.internal.message_test.MessageTest.testReleasedNestedMessages_proto3">testReleasedNestedMessages_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedCompareWithSelf_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedCompareWithSelf_proto2">testRepeatedCompareWithSelf_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedCompareWithSelf_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedCompareWithSelf_proto3">testRepeatedCompareWithSelf_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldPop_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldPop_proto2">testRepeatedCompositeFieldPop_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldPop_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldPop_proto3">testRepeatedCompositeFieldPop_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldSortArguments_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldSortArguments_proto2">testRepeatedCompositeFieldSortArguments_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldSortArguments_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedCompositeFieldSortArguments_proto3">testRepeatedCompositeFieldSortArguments_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedContains_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedContains_proto2">testRepeatedContains_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedContains_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedContains_proto3">testRepeatedContains_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldInsideNestedMessage_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldInsideNestedMessage_proto2">testRepeatedFieldInsideNestedMessage_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldInsideNestedMessage_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldInsideNestedMessage_proto3">testRepeatedFieldInsideNestedMessage_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsAreSequences_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsAreSequences_proto2">testRepeatedFieldsAreSequences_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsAreSequences_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsAreSequences_proto3">testRepeatedFieldsAreSequences_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsComparable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsComparable_proto2">testRepeatedFieldsComparable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsComparable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsComparable_proto3">testRepeatedFieldsComparable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsNotHashable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsNotHashable_proto2">testRepeatedFieldsNotHashable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsNotHashable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedFieldsNotHashable_proto3">testRepeatedFieldsNotHashable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedNestedFieldIteration_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedNestedFieldIteration_proto2">testRepeatedNestedFieldIteration_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedNestedFieldIteration_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedNestedFieldIteration_proto3">testRepeatedNestedFieldIteration_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldPop_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldPop_proto2">testRepeatedScalarFieldPop_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldPop_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldPop_proto3">testRepeatedScalarFieldPop_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldSortArguments_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldSortArguments_proto2">testRepeatedScalarFieldSortArguments_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldSortArguments_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedScalarFieldSortArguments_proto3">testRepeatedScalarFieldSortArguments_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarIterable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedScalarIterable_proto2">testRepeatedScalarIterable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testRepeatedScalarIterable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testRepeatedScalarIterable_proto3">testRepeatedScalarIterable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testReturningType_proto2" href="#google.protobuf.internal.message_test.MessageTest.testReturningType_proto2">testReturningType_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testReturningType_proto3" href="#google.protobuf.internal.message_test.MessageTest.testReturningType_proto3">testReturningType_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSetRepeatedComposite_proto2" href="#google.protobuf.internal.message_test.MessageTest.testSetRepeatedComposite_proto2">testSetRepeatedComposite_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSetRepeatedComposite_proto3" href="#google.protobuf.internal.message_test.MessageTest.testSetRepeatedComposite_proto3">testSetRepeatedComposite_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortEmptyRepeatedCompositeContainer_proto2" href="#google.protobuf.internal.message_test.MessageTest.testSortEmptyRepeatedCompositeContainer_proto2">testSortEmptyRepeatedCompositeContainer_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortEmptyRepeatedCompositeContainer_proto3" href="#google.protobuf.internal.message_test.MessageTest.testSortEmptyRepeatedCompositeContainer_proto3">testSortEmptyRepeatedCompositeContainer_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsCustomComparator_proto2" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsCustomComparator_proto2">testSortingRepeatedCompositeFieldsCustomComparator_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsCustomComparator_proto3" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsCustomComparator_proto3">testSortingRepeatedCompositeFieldsCustomComparator_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsStable_proto2" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsStable_proto2">testSortingRepeatedCompositeFieldsStable_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsStable_proto3" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedCompositeFieldsStable_proto3">testSortingRepeatedCompositeFieldsStable_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsCustomComparator_proto2" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsCustomComparator_proto2">testSortingRepeatedScalarFieldsCustomComparator_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsCustomComparator_proto3" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsCustomComparator_proto3">testSortingRepeatedScalarFieldsCustomComparator_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsDefaultComparator_proto2" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsDefaultComparator_proto2">testSortingRepeatedScalarFieldsDefaultComparator_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsDefaultComparator_proto3" href="#google.protobuf.internal.message_test.MessageTest.testSortingRepeatedScalarFieldsDefaultComparator_proto3">testSortingRepeatedScalarFieldsDefaultComparator_proto3</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testUnknownFieldPrinting_proto2" href="#google.protobuf.internal.message_test.MessageTest.testUnknownFieldPrinting_proto2">testUnknownFieldPrinting_proto2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.MessageTest.testUnknownFieldPrinting_proto3" href="#google.protobuf.internal.message_test.MessageTest.testUnknownFieldPrinting_proto3">testUnknownFieldPrinting_proto3</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.message_test.OversizeProtosTest" href="#google.protobuf.internal.message_test.OversizeProtosTest">OversizeProtosTest</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.OversizeProtosTest.setUp" href="#google.protobuf.internal.message_test.OversizeProtosTest.setUp">setUp</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.OversizeProtosTest.setUpClass" href="#google.protobuf.internal.message_test.OversizeProtosTest.setUpClass">setUpClass</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.OversizeProtosTest.testAssertOversizeProto" href="#google.protobuf.internal.message_test.OversizeProtosTest.testAssertOversizeProto">testAssertOversizeProto</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.OversizeProtosTest.testSucceedOversizeProto" href="#google.protobuf.internal.message_test.OversizeProtosTest.testSucceedOversizeProto">testSucceedOversizeProto</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.message_test.PackedFieldTest" href="#google.protobuf.internal.message_test.PackedFieldTest">PackedFieldTest</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.PackedFieldTest.setMessage" href="#google.protobuf.internal.message_test.PackedFieldTest.setMessage">setMessage</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.PackedFieldTest.testPackedFields" href="#google.protobuf.internal.message_test.PackedFieldTest.testPackedFields">testPackedFields</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.PackedFieldTest.testUnpackedFields" href="#google.protobuf.internal.message_test.PackedFieldTest.testUnpackedFields">testUnpackedFields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.message_test.Proto2Test" href="#google.protobuf.internal.message_test.Proto2Test">Proto2Test</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testAssignInvalidEnum" href="#google.protobuf.internal.message_test.Proto2Test.testAssignInvalidEnum">testAssignInvalidEnum</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testExtensionsErrors" href="#google.protobuf.internal.message_test.Proto2Test.testExtensionsErrors">testExtensionsErrors</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testFieldPresence" href="#google.protobuf.internal.message_test.Proto2Test.testFieldPresence">testFieldPresence</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testGoldenExtensions" href="#google.protobuf.internal.message_test.Proto2Test.testGoldenExtensions">testGoldenExtensions</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testGoldenPackedExtensions" href="#google.protobuf.internal.message_test.Proto2Test.testGoldenPackedExtensions">testGoldenPackedExtensions</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testMergeFromExtensions" href="#google.protobuf.internal.message_test.Proto2Test.testMergeFromExtensions">testMergeFromExtensions</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testParsingMerge" href="#google.protobuf.internal.message_test.Proto2Test.testParsingMerge">testParsingMerge</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testPickleIncompleteProto" href="#google.protobuf.internal.message_test.Proto2Test.testPickleIncompleteProto">testPickleIncompleteProto</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testPythonicInit" href="#google.protobuf.internal.message_test.Proto2Test.testPythonicInit">testPythonicInit</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testPythonicInitWithDict" href="#google.protobuf.internal.message_test.Proto2Test.testPythonicInitWithDict">testPythonicInitWithDict</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.testUnknownEnumMap" href="#google.protobuf.internal.message_test.Proto2Test.testUnknownEnumMap">testUnknownEnumMap</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto2Test.test_documentation" href="#google.protobuf.internal.message_test.Proto2Test.test_documentation">test_documentation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.message_test.Proto3Test" href="#google.protobuf.internal.message_test.Proto3Test">Proto3Test</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.assertMapIterEquals" href="#google.protobuf.internal.message_test.Proto3Test.assertMapIterEquals">assertMapIterEquals</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testAssignUnknownEnum" href="#google.protobuf.internal.message_test.Proto3Test.testAssignUnknownEnum">testAssignUnknownEnum</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testCopyFromBadType" href="#google.protobuf.internal.message_test.Proto3Test.testCopyFromBadType">testCopyFromBadType</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testFieldPresence" href="#google.protobuf.internal.message_test.Proto3Test.testFieldPresence">testFieldPresence</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testIntegerMapWithLongs" href="#google.protobuf.internal.message_test.Proto3Test.testIntegerMapWithLongs">testIntegerMapWithLongs</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapAssignmentCausesPresence" href="#google.protobuf.internal.message_test.Proto3Test.testMapAssignmentCausesPresence">testMapAssignmentCausesPresence</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapAssignmentCausesPresenceForSubmessages" href="#google.protobuf.internal.message_test.Proto3Test.testMapAssignmentCausesPresenceForSubmessages">testMapAssignmentCausesPresenceForSubmessages</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapByteSize" href="#google.protobuf.internal.message_test.Proto3Test.testMapByteSize">testMapByteSize</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapConstruction" href="#google.protobuf.internal.message_test.Proto3Test.testMapConstruction">testMapConstruction</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapDelete" href="#google.protobuf.internal.message_test.Proto3Test.testMapDelete">testMapDelete</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapDeterministicSerialization" href="#google.protobuf.internal.message_test.Proto3Test.testMapDeterministicSerialization">testMapDeterministicSerialization</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapEntryAlwaysSerialized" href="#google.protobuf.internal.message_test.Proto3Test.testMapEntryAlwaysSerialized">testMapEntryAlwaysSerialized</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapFieldRaisesCorrectError" href="#google.protobuf.internal.message_test.Proto3Test.testMapFieldRaisesCorrectError">testMapFieldRaisesCorrectError</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapFindInitializationErrorsSmokeTest" href="#google.protobuf.internal.message_test.Proto3Test.testMapFindInitializationErrorsSmokeTest">testMapFindInitializationErrorsSmokeTest</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapGet" href="#google.protobuf.internal.message_test.Proto3Test.testMapGet">testMapGet</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapItems" href="#google.protobuf.internal.message_test.Proto3Test.testMapItems">testMapItems</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapIterInvalidatedByClearField" href="#google.protobuf.internal.message_test.Proto3Test.testMapIterInvalidatedByClearField">testMapIterInvalidatedByClearField</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapIteration" href="#google.protobuf.internal.message_test.Proto3Test.testMapIteration">testMapIteration</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapIterationClearMessage" href="#google.protobuf.internal.message_test.Proto3Test.testMapIterationClearMessage">testMapIterationClearMessage</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapMergeFrom" href="#google.protobuf.internal.message_test.Proto3Test.testMapMergeFrom">testMapMergeFrom</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapMessageFieldConstruction" href="#google.protobuf.internal.message_test.Proto3Test.testMapMessageFieldConstruction">testMapMessageFieldConstruction</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapScalarFieldConstruction" href="#google.protobuf.internal.message_test.Proto3Test.testMapScalarFieldConstruction">testMapScalarFieldConstruction</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapValidAfterFieldCleared" href="#google.protobuf.internal.message_test.Proto3Test.testMapValidAfterFieldCleared">testMapValidAfterFieldCleared</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapsAreMapping" href="#google.protobuf.internal.message_test.Proto3Test.testMapsAreMapping">testMapsAreMapping</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMapsCompare" href="#google.protobuf.internal.message_test.Proto3Test.testMapsCompare">testMapsCompare</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMergeFrom" href="#google.protobuf.internal.message_test.Proto3Test.testMergeFrom">testMergeFrom</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMergeFromBadType" href="#google.protobuf.internal.message_test.Proto3Test.testMergeFromBadType">testMergeFromBadType</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMessageMap" href="#google.protobuf.internal.message_test.Proto3Test.testMessageMap">testMessageMap</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMessageMapItemValidAfterTopMessageCleared" href="#google.protobuf.internal.message_test.Proto3Test.testMessageMapItemValidAfterTopMessageCleared">testMessageMapItemValidAfterTopMessageCleared</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testMessageMapValidAfterFieldCleared" href="#google.protobuf.internal.message_test.Proto3Test.testMessageMapValidAfterFieldCleared">testMessageMapValidAfterFieldCleared</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testModifyMapWhileIterating" href="#google.protobuf.internal.message_test.Proto3Test.testModifyMapWhileIterating">testModifyMapWhileIterating</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testNestedMessageMapItemDelete" href="#google.protobuf.internal.message_test.Proto3Test.testNestedMessageMapItemDelete">testNestedMessageMapItemDelete</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testPython2Map" href="#google.protobuf.internal.message_test.Proto3Test.testPython2Map">testPython2Map</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testScalarMap" href="#google.protobuf.internal.message_test.Proto3Test.testScalarMap">testScalarMap</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testScalarMapDefaults" href="#google.protobuf.internal.message_test.Proto3Test.testScalarMapDefaults">testScalarMapDefaults</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testStrictUtf8Check" href="#google.protobuf.internal.message_test.Proto3Test.testStrictUtf8Check">testStrictUtf8Check</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testStringUnicodeConversionInMap" href="#google.protobuf.internal.message_test.Proto3Test.testStringUnicodeConversionInMap">testStringUnicodeConversionInMap</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testSubmessageMap" href="#google.protobuf.internal.message_test.Proto3Test.testSubmessageMap">testSubmessageMap</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testSurrogatesInPython2" href="#google.protobuf.internal.message_test.Proto3Test.testSurrogatesInPython2">testSurrogatesInPython2</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.Proto3Test.testSurrogatesInPython3" href="#google.protobuf.internal.message_test.Proto3Test.testSurrogatesInPython3">testSurrogatesInPython3</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.message_test.ValidTypeNamesTest" href="#google.protobuf.internal.message_test.ValidTypeNamesTest">ValidTypeNamesTest</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.message_test.ValidTypeNamesTest.assertImportFromName" href="#google.protobuf.internal.message_test.ValidTypeNamesTest.assertImportFromName">assertImportFromName</a></code></li>
<li><code><a title="google.protobuf.internal.message_test.ValidTypeNamesTest.testTypeNamesCanBeImported" href="#google.protobuf.internal.message_test.ValidTypeNamesTest.testTypeNamesCanBeImported">testTypeNamesCanBeImported</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>