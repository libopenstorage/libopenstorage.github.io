<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.protobuf.internal.json_format_test API documentation</title>
<meta name="description" content="Test for google.protobuf.json_format." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.protobuf.internal.json_format_test</code></h1>
</header>
<section id="section-intro">
<p>Test for google.protobuf.json_format.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/env python
#
# Protocol Buffers - Google&#39;s data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

&#34;&#34;&#34;Test for google.protobuf.json_format.&#34;&#34;&#34;

__author__ = &#39;jieluo@google.com (Jie Luo)&#39;

import json
import math
import sys

try:
  import unittest2 as unittest  #PY26
except ImportError:
  import unittest

from google.protobuf import any_pb2
from google.protobuf import duration_pb2
from google.protobuf import field_mask_pb2
from google.protobuf import struct_pb2
from google.protobuf import timestamp_pb2
from google.protobuf import wrappers_pb2
from google.protobuf import any_test_pb2
from google.protobuf import unittest_mset_pb2
from google.protobuf import unittest_pb2
from google.protobuf import descriptor_pool
from google.protobuf import json_format
from google.protobuf.util import json_format_pb2
from google.protobuf.util import json_format_proto3_pb2


class JsonFormatBase(unittest.TestCase):

  def FillAllFields(self, message):
    message.int32_value = 20
    message.int64_value = -20
    message.uint32_value = 3120987654
    message.uint64_value = 12345678900
    message.float_value = float(&#39;-inf&#39;)
    message.double_value = 3.1415
    message.bool_value = True
    message.string_value = &#39;foo&#39;
    message.bytes_value = b&#39;bar&#39;
    message.message_value.value = 10
    message.enum_value = json_format_proto3_pb2.BAR
    # Repeated
    message.repeated_int32_value.append(0x7FFFFFFF)
    message.repeated_int32_value.append(-2147483648)
    message.repeated_int64_value.append(9007199254740992)
    message.repeated_int64_value.append(-9007199254740992)
    message.repeated_uint32_value.append(0xFFFFFFF)
    message.repeated_uint32_value.append(0x7FFFFFF)
    message.repeated_uint64_value.append(9007199254740992)
    message.repeated_uint64_value.append(9007199254740991)
    message.repeated_float_value.append(0)

    message.repeated_double_value.append(1E-15)
    message.repeated_double_value.append(float(&#39;inf&#39;))
    message.repeated_bool_value.append(True)
    message.repeated_bool_value.append(False)
    message.repeated_string_value.append(&#39;Few symbols!#$,;&#39;)
    message.repeated_string_value.append(&#39;bar&#39;)
    message.repeated_bytes_value.append(b&#39;foo&#39;)
    message.repeated_bytes_value.append(b&#39;bar&#39;)
    message.repeated_message_value.add().value = 10
    message.repeated_message_value.add().value = 11
    message.repeated_enum_value.append(json_format_proto3_pb2.FOO)
    message.repeated_enum_value.append(json_format_proto3_pb2.BAR)
    self.message = message

  def CheckParseBack(self, message, parsed_message):
    json_format.Parse(json_format.MessageToJson(message),
                      parsed_message)
    self.assertEqual(message, parsed_message)

  def CheckError(self, text, error_message):
    message = json_format_proto3_pb2.TestMessage()
    self.assertRaisesRegexp(
        json_format.ParseError,
        error_message,
        json_format.Parse, text, message)


class JsonFormatTest(JsonFormatBase):

  def testEmptyMessageToJson(self):
    message = json_format_proto3_pb2.TestMessage()
    self.assertEqual(json_format.MessageToJson(message),
                     &#39;{}&#39;)
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)

  def testPartialMessageToJson(self):
    message = json_format_proto3_pb2.TestMessage(
        string_value=&#39;test&#39;,
        repeated_int32_value=[89, 4])
    self.assertEqual(json.loads(json_format.MessageToJson(message)),
                     json.loads(&#39;{&#34;stringValue&#34;: &#34;test&#34;, &#39;
                                &#39;&#34;repeatedInt32Value&#34;: [89, 4]}&#39;))
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)

  def testAllFieldsToJson(self):
    message = json_format_proto3_pb2.TestMessage()
    text = (&#39;{&#34;int32Value&#34;: 20, &#39;
            &#39;&#34;int64Value&#34;: &#34;-20&#34;, &#39;
            &#39;&#34;uint32Value&#34;: 3120987654,&#39;
            &#39;&#34;uint64Value&#34;: &#34;12345678900&#34;,&#39;
            &#39;&#34;floatValue&#34;: &#34;-Infinity&#34;,&#39;
            &#39;&#34;doubleValue&#34;: 3.1415,&#39;
            &#39;&#34;boolValue&#34;: true,&#39;
            &#39;&#34;stringValue&#34;: &#34;foo&#34;,&#39;
            &#39;&#34;bytesValue&#34;: &#34;YmFy&#34;,&#39;
            &#39;&#34;messageValue&#34;: {&#34;value&#34;: 10},&#39;
            &#39;&#34;enumValue&#34;: &#34;BAR&#34;,&#39;
            &#39;&#34;repeatedInt32Value&#34;: [2147483647, -2147483648],&#39;
            &#39;&#34;repeatedInt64Value&#34;: [&#34;9007199254740992&#34;, &#34;-9007199254740992&#34;],&#39;
            &#39;&#34;repeatedUint32Value&#34;: [268435455, 134217727],&#39;
            &#39;&#34;repeatedUint64Value&#34;: [&#34;9007199254740992&#34;, &#34;9007199254740991&#34;],&#39;
            &#39;&#34;repeatedFloatValue&#34;: [0],&#39;
            &#39;&#34;repeatedDoubleValue&#34;: [1e-15, &#34;Infinity&#34;],&#39;
            &#39;&#34;repeatedBoolValue&#34;: [true, false],&#39;
            &#39;&#34;repeatedStringValue&#34;: [&#34;Few symbols!#$,;&#34;, &#34;bar&#34;],&#39;
            &#39;&#34;repeatedBytesValue&#34;: [&#34;Zm9v&#34;, &#34;YmFy&#34;],&#39;
            &#39;&#34;repeatedMessageValue&#34;: [{&#34;value&#34;: 10}, {&#34;value&#34;: 11}],&#39;
            &#39;&#34;repeatedEnumValue&#34;: [&#34;FOO&#34;, &#34;BAR&#34;]&#39;
            &#39;}&#39;)
    self.FillAllFields(message)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message)),
        json.loads(text))
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message)
    self.assertEqual(message, parsed_message)

  def testUnknownEnumToJsonAndBack(self):
    text = &#39;{\n  &#34;enumValue&#34;: 999\n}&#39;
    message = json_format_proto3_pb2.TestMessage()
    message.enum_value = 999
    self.assertEqual(json_format.MessageToJson(message),
                     text)
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message)
    self.assertEqual(message, parsed_message)

  def testExtensionToJsonAndBack(self):
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_text = json_format.MessageToJson(
        message
    )
    parsed_message = unittest_mset_pb2.TestMessageSetContainer()
    json_format.Parse(message_text, parsed_message)
    self.assertEqual(message, parsed_message)

  def testExtensionErrors(self):
    self.CheckError(&#39;{&#34;[extensionField]&#34;: {}}&#39;,
                    &#39;Message type proto3.TestMessage does not have extensions&#39;)

  def testExtensionToDictAndBack(self):
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    parsed_message = unittest_mset_pb2.TestMessageSetContainer()
    json_format.ParseDict(message_dict, parsed_message)
    self.assertEqual(message, parsed_message)

  def testExtensionToDictAndBackWithScalar(self):
    message = unittest_pb2.TestAllExtensions()
    ext1 = unittest_pb2.TestNestedExtension.test
    message.Extensions[ext1] = &#39;data&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    parsed_message = unittest_pb2.TestAllExtensions()
    json_format.ParseDict(message_dict, parsed_message)
    self.assertEqual(message, parsed_message)

  def testJsonParseDictToAnyDoesNotAlterInput(self):
    orig_dict = {
        &#39;int32Value&#39;: 20,
        &#39;@type&#39;: &#39;type.googleapis.com/proto3.TestMessage&#39;
    }
    copied_dict = json.loads(json.dumps(orig_dict))
    parsed_message = any_pb2.Any()
    json_format.ParseDict(copied_dict, parsed_message)
    self.assertEqual(copied_dict, orig_dict)

  def testExtensionSerializationDictMatchesProto3Spec(self):
    &#34;&#34;&#34;See go/proto3-json-spec for spec.
    &#34;&#34;&#34;
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    golden_dict = {
        &#39;messageSet&#39;: {
            &#39;[protobuf_unittest.&#39;
            &#39;TestMessageSetExtension1.messageSetExtension]&#39;: {
                &#39;i&#39;: 23,
            },
            &#39;[protobuf_unittest.&#39;
            &#39;TestMessageSetExtension2.messageSetExtension]&#39;: {
                &#39;str&#39;: u&#39;foo&#39;,
            },
        },
    }
    self.assertEqual(golden_dict, message_dict)

  def testExtensionSerializationDictMatchesProto3SpecMore(self):
    &#34;&#34;&#34;See go/proto3-json-spec for spec.
    &#34;&#34;&#34;
    message = json_format_pb2.TestMessageWithExtension()
    ext = json_format_pb2.TestExtension.ext
    message.Extensions[ext].value = &#39;stuff&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    expected_dict = {
        &#39;[protobuf_unittest.TestExtension.ext]&#39;: {
            &#39;value&#39;: u&#39;stuff&#39;,
        },
    }
    self.assertEqual(expected_dict, message_dict)


  def testExtensionSerializationJsonMatchesProto3Spec(self):
    &#34;&#34;&#34;See go/proto3-json-spec for spec.
    &#34;&#34;&#34;
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_text = json_format.MessageToJson(
        message
    )
    ext1_text = (&#39;protobuf_unittest.TestMessageSetExtension1.&#39;
                 &#39;messageSetExtension&#39;)
    ext2_text = (&#39;protobuf_unittest.TestMessageSetExtension2.&#39;
                 &#39;messageSetExtension&#39;)
    golden_text = (&#39;{&#34;messageSet&#34;: {&#39;
                   &#39;    &#34;[%s]&#34;: {&#39;
                   &#39;        &#34;i&#34;: 23&#39;
                   &#39;    },&#39;
                   &#39;    &#34;[%s]&#34;: {&#39;
                   &#39;        &#34;str&#34;: &#34;foo&#34;&#39;
                   &#39;    }&#39;
                   &#39;}}&#39;) % (ext1_text, ext2_text)
    self.assertEqual(json.loads(golden_text), json.loads(message_text))


  def testJsonEscapeString(self):
    message = json_format_proto3_pb2.TestMessage()
    if sys.version_info[0] &lt; 3:
      message.string_value = &#39;&amp;\n&lt;\&#34;\r&gt;\b\t\f\\\001/\xe2\x80\xa8\xe2\x80\xa9&#39;
    else:
      message.string_value = &#39;&amp;\n&lt;\&#34;\r&gt;\b\t\f\\\001/&#39;
      message.string_value += (b&#39;\xe2\x80\xa8\xe2\x80\xa9&#39;).decode(&#39;utf-8&#39;)
    self.assertEqual(
        json_format.MessageToJson(message),
        &#39;{\n  &#34;stringValue&#34;: &#39;
        &#39;&#34;&amp;\\n&lt;\\\&#34;\\r&gt;\\b\\t\\f\\\\\\u0001/\\u2028\\u2029&#34;\n}&#39;)
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)
    text = u&#39;{&#34;int32Value&#34;: &#34;\u0031&#34;}&#39;
    json_format.Parse(text, message)
    self.assertEqual(message.int32_value, 1)

  def testAlwaysSeriliaze(self):
    message = json_format_proto3_pb2.TestMessage(
        string_value=&#39;foo&#39;)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;repeatedStringValue&#34;: [],&#39;
                   &#39;&#34;stringValue&#34;: &#34;foo&#34;,&#39;
                   &#39;&#34;repeatedBoolValue&#34;: [],&#39;
                   &#39;&#34;repeatedUint32Value&#34;: [],&#39;
                   &#39;&#34;repeatedInt32Value&#34;: [],&#39;
                   &#39;&#34;enumValue&#34;: &#34;FOO&#34;,&#39;
                   &#39;&#34;int32Value&#34;: 0,&#39;
                   &#39;&#34;floatValue&#34;: 0,&#39;
                   &#39;&#34;int64Value&#34;: &#34;0&#34;,&#39;
                   &#39;&#34;uint32Value&#34;: 0,&#39;
                   &#39;&#34;repeatedBytesValue&#34;: [],&#39;
                   &#39;&#34;repeatedUint64Value&#34;: [],&#39;
                   &#39;&#34;repeatedDoubleValue&#34;: [],&#39;
                   &#39;&#34;bytesValue&#34;: &#34;&#34;,&#39;
                   &#39;&#34;boolValue&#34;: false,&#39;
                   &#39;&#34;repeatedEnumValue&#34;: [],&#39;
                   &#39;&#34;uint64Value&#34;: &#34;0&#34;,&#39;
                   &#39;&#34;doubleValue&#34;: 0,&#39;
                   &#39;&#34;repeatedFloatValue&#34;: [],&#39;
                   &#39;&#34;repeatedInt64Value&#34;: [],&#39;
                   &#39;&#34;repeatedMessageValue&#34;: []}&#39;))
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)

  def testIntegersRepresentedAsFloat(self):
    message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(&#39;{&#34;int32Value&#34;: -2.147483648e9}&#39;, message)
    self.assertEqual(message.int32_value, -2147483648)
    json_format.Parse(&#39;{&#34;int32Value&#34;: 1e5}&#39;, message)
    self.assertEqual(message.int32_value, 100000)
    json_format.Parse(&#39;{&#34;int32Value&#34;: 1.0}&#39;, message)
    self.assertEqual(message.int32_value, 1)

  def testMapFields(self):
    message = json_format_proto3_pb2.TestNestedMap()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;boolMap&#34;: {},&#39;
                   &#39;&#34;int32Map&#34;: {},&#39;
                   &#39;&#34;int64Map&#34;: {},&#39;
                   &#39;&#34;uint32Map&#34;: {},&#39;
                   &#39;&#34;uint64Map&#34;: {},&#39;
                   &#39;&#34;stringMap&#34;: {},&#39;
                   &#39;&#34;mapMap&#34;: {}&#39;
                   &#39;}&#39;))
    message.bool_map[True] = 1
    message.bool_map[False] = 2
    message.int32_map[1] = 2
    message.int32_map[2] = 3
    message.int64_map[1] = 2
    message.int64_map[2] = 3
    message.uint32_map[1] = 2
    message.uint32_map[2] = 3
    message.uint64_map[1] = 2
    message.uint64_map[2] = 3
    message.string_map[&#39;1&#39;] = 2
    message.string_map[&#39;null&#39;] = 3
    message.map_map[&#39;1&#39;].bool_map[True] = 3
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(&#39;{&#39;
                   &#39;&#34;boolMap&#34;: {&#34;false&#34;: 2, &#34;true&#34;: 1},&#39;
                   &#39;&#34;int32Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;int64Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;uint32Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;uint64Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;stringMap&#34;: {&#34;1&#34;: 2, &#34;null&#34;: 3},&#39;
                   &#39;&#34;mapMap&#34;: {&#34;1&#34;: {&#34;boolMap&#34;: {&#34;true&#34;: 3}}}&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestNestedMap()
    self.CheckParseBack(message, parsed_message)

  def testOneofFields(self):
    message = json_format_proto3_pb2.TestOneof()
    # Always print does not affect oneof fields.
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{}&#39;)
    message.oneof_int32_value = 0
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{\n&#39;
        &#39;  &#34;oneofInt32Value&#34;: 0\n&#39;
        &#39;}&#39;)
    parsed_message = json_format_proto3_pb2.TestOneof()
    self.CheckParseBack(message, parsed_message)

  def testSurrogates(self):
    # Test correct surrogate handling.
    message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(&#39;{&#34;stringValue&#34;: &#34;\\uD83D\\uDE01&#34;}&#39;, message)
    self.assertEqual(message.string_value,
                     b&#39;\xF0\x9F\x98\x81&#39;.decode(&#39;utf-8&#39;, &#39;strict&#39;))

    # Error case: unpaired high surrogate.
    self.CheckError(
        &#39;{&#34;stringValue&#34;: &#34;\\uD83D&#34;}&#39;,
        r&#39;Invalid \\uXXXX escape|Unpaired.*surrogate&#39;)

    # Unpaired low surrogate.
    self.CheckError(
        &#39;{&#34;stringValue&#34;: &#34;\\uDE01&#34;}&#39;,
        r&#39;Invalid \\uXXXX escape|Unpaired.*surrogate&#39;)

  def testTimestampMessage(self):
    message = json_format_proto3_pb2.TestTimestamp()
    message.value.seconds = 0
    message.value.nanos = 0
    message.repeated_value.add().seconds = 20
    message.repeated_value[0].nanos = 1
    message.repeated_value.add().seconds = 0
    message.repeated_value[1].nanos = 10000
    message.repeated_value.add().seconds = 100000000
    message.repeated_value[2].nanos = 0
    # Maximum time
    message.repeated_value.add().seconds = 253402300799
    message.repeated_value[3].nanos = 999999999
    # Minimum time
    message.repeated_value.add().seconds = -62135596800
    message.repeated_value[4].nanos = 0
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;value&#34;: &#34;1970-01-01T00:00:00Z&#34;,&#39;
                   &#39;&#34;repeatedValue&#34;: [&#39;
                   &#39;  &#34;1970-01-01T00:00:20.000000001Z&#34;,&#39;
                   &#39;  &#34;1970-01-01T00:00:00.000010Z&#34;,&#39;
                   &#39;  &#34;1973-03-03T09:46:40Z&#34;,&#39;
                   &#39;  &#34;9999-12-31T23:59:59.999999999Z&#34;,&#39;
                   &#39;  &#34;0001-01-01T00:00:00Z&#34;&#39;
                   &#39;]&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestTimestamp()
    self.CheckParseBack(message, parsed_message)
    text = (r&#39;{&#34;value&#34;: &#34;1970-01-01T00:00:00.01+08:00&#34;,&#39;
            r&#39;&#34;repeatedValue&#34;:[&#39;
            r&#39;  &#34;1970-01-01T00:00:00.01+08:30&#34;,&#39;
            r&#39;  &#34;1970-01-01T00:00:00.01-01:23&#34;]}&#39;)
    json_format.Parse(text, parsed_message)
    self.assertEqual(parsed_message.value.seconds, -8 * 3600)
    self.assertEqual(parsed_message.value.nanos, 10000000)
    self.assertEqual(parsed_message.repeated_value[0].seconds, -8.5 * 3600)
    self.assertEqual(parsed_message.repeated_value[1].seconds, 3600 + 23 * 60)

  def testDurationMessage(self):
    message = json_format_proto3_pb2.TestDuration()
    message.value.seconds = 1
    message.repeated_value.add().seconds = 0
    message.repeated_value[0].nanos = 10
    message.repeated_value.add().seconds = -1
    message.repeated_value[1].nanos = -1000
    message.repeated_value.add().seconds = 10
    message.repeated_value[2].nanos = 11000000
    message.repeated_value.add().seconds = -315576000000
    message.repeated_value.add().seconds = 315576000000
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;value&#34;: &#34;1s&#34;,&#39;
                   &#39;&#34;repeatedValue&#34;: [&#39;
                   &#39;  &#34;0.000000010s&#34;,&#39;
                   &#39;  &#34;-1.000001s&#34;,&#39;
                   &#39;  &#34;10.011s&#34;,&#39;
                   &#39;  &#34;-315576000000s&#34;,&#39;
                   &#39;  &#34;315576000000s&#34;&#39;
                   &#39;]&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestDuration()
    self.CheckParseBack(message, parsed_message)

  def testFieldMaskMessage(self):
    message = json_format_proto3_pb2.TestFieldMask()
    message.value.paths.append(&#39;foo.bar&#39;)
    message.value.paths.append(&#39;bar&#39;)
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{\n&#39;
        &#39;  &#34;value&#34;: &#34;foo.bar,bar&#34;\n&#39;
        &#39;}&#39;)
    parsed_message = json_format_proto3_pb2.TestFieldMask()
    self.CheckParseBack(message, parsed_message)

    message.value.Clear()
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{\n&#39;
        &#39;  &#34;value&#34;: &#34;&#34;\n&#39;
        &#39;}&#39;)
    self.CheckParseBack(message, parsed_message)

  def testWrapperMessage(self):
    message = json_format_proto3_pb2.TestWrapper()
    message.bool_value.value = False
    message.int32_value.value = 0
    message.string_value.value = &#39;&#39;
    message.bytes_value.value = b&#39;&#39;
    message.repeated_bool_value.add().value = True
    message.repeated_bool_value.add().value = False
    message.repeated_int32_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{\n&#39;
                   &#39;  &#34;int32Value&#34;: 0,&#39;
                   &#39;  &#34;boolValue&#34;: false,&#39;
                   &#39;  &#34;stringValue&#34;: &#34;&#34;,&#39;
                   &#39;  &#34;bytesValue&#34;: &#34;&#34;,&#39;
                   &#39;  &#34;repeatedBoolValue&#34;: [true, false],&#39;
                   &#39;  &#34;repeatedInt32Value&#34;: [0],&#39;
                   &#39;  &#34;repeatedUint32Value&#34;: [],&#39;
                   &#39;  &#34;repeatedFloatValue&#34;: [],&#39;
                   &#39;  &#34;repeatedDoubleValue&#34;: [],&#39;
                   &#39;  &#34;repeatedBytesValue&#34;: [],&#39;
                   &#39;  &#34;repeatedInt64Value&#34;: [],&#39;
                   &#39;  &#34;repeatedUint64Value&#34;: [],&#39;
                   &#39;  &#34;repeatedStringValue&#34;: []&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestWrapper()
    self.CheckParseBack(message, parsed_message)

  def testStructMessage(self):
    message = json_format_proto3_pb2.TestStruct()
    message.value[&#39;name&#39;] = &#39;Jim&#39;
    message.value[&#39;age&#39;] = 10
    message.value[&#39;attend&#39;] = True
    message.value[&#39;email&#39;] = None
    message.value.get_or_create_struct(&#39;address&#39;)[&#39;city&#39;] = &#39;SFO&#39;
    message.value[&#39;address&#39;][&#39;house_number&#39;] = 1024
    message.value.get_or_create_struct(&#39;empty_struct&#39;)
    message.value.get_or_create_list(&#39;empty_list&#39;)
    struct_list = message.value.get_or_create_list(&#39;list&#39;)
    struct_list.extend([6, &#39;seven&#39;, True, False, None])
    struct_list.add_struct()[&#39;subkey2&#39;] = 9
    message.repeated_value.add()[&#39;age&#39;] = 11
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#39;
            &#39;  &#34;value&#34;: {&#39;
            &#39;    &#34;address&#34;: {&#39;
            &#39;      &#34;city&#34;: &#34;SFO&#34;, &#39;
            &#39;      &#34;house_number&#34;: 1024&#39;
            &#39;    }, &#39;
            &#39;    &#34;empty_struct&#34;: {}, &#39;
            &#39;    &#34;empty_list&#34;: [], &#39;
            &#39;    &#34;age&#34;: 10, &#39;
            &#39;    &#34;name&#34;: &#34;Jim&#34;, &#39;
            &#39;    &#34;attend&#34;: true, &#39;
            &#39;    &#34;email&#34;: null, &#39;
            &#39;    &#34;list&#34;: [6, &#34;seven&#34;, true, false, null, {&#34;subkey2&#34;: 9}]&#39;
            &#39;  },&#39;
            &#39;  &#34;repeatedValue&#34;: [{&#34;age&#34;: 11}, {}]&#39;
            &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestStruct()
    self.CheckParseBack(message, parsed_message)
    # check for regression; this used to raise
    parsed_message.value[&#39;empty_struct&#39;]
    parsed_message.value[&#39;empty_list&#39;]

  def testValueMessage(self):
    message = json_format_proto3_pb2.TestValue()
    message.value.string_value = &#39;hello&#39;
    message.repeated_value.add().number_value = 11.1
    message.repeated_value.add().bool_value = False
    message.repeated_value.add().null_value = 0
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#39;
            &#39;  &#34;value&#34;: &#34;hello&#34;,&#39;
            &#39;  &#34;repeatedValue&#34;: [11.1, false, null]&#39;
            &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestValue()
    self.CheckParseBack(message, parsed_message)
    # Can&#39;t parse back if the Value message is not set.
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#39;
            &#39;  &#34;value&#34;: &#34;hello&#34;,&#39;
            &#39;  &#34;repeatedValue&#34;: [11.1, false, null, null]&#39;
            &#39;}&#39;))
    message.Clear()
    json_format.Parse(&#39;{&#34;value&#34;: null}&#39;, message)
    self.assertEqual(message.value.WhichOneof(&#39;kind&#39;), &#39;null_value&#39;)

  def testListValueMessage(self):
    message = json_format_proto3_pb2.TestListValue()
    message.value.values.add().number_value = 11.1
    message.value.values.add().null_value = 0
    message.value.values.add().bool_value = True
    message.value.values.add().string_value = &#39;hello&#39;
    message.value.values.add().struct_value[&#39;name&#39;] = &#39;Jim&#39;
    message.repeated_value.add().values.add().number_value = 1
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#34;value&#34;: [11.1, null, true, &#34;hello&#34;, {&#34;name&#34;: &#34;Jim&#34;}]\n,&#39;
            &#39;&#34;repeatedValue&#34;: [[1], []]}&#39;))
    parsed_message = json_format_proto3_pb2.TestListValue()
    self.CheckParseBack(message, parsed_message)

  def testAnyMessage(self):
    message = json_format_proto3_pb2.TestAny()
    value1 = json_format_proto3_pb2.MessageType()
    value2 = json_format_proto3_pb2.MessageType()
    value1.value = 1234
    value2.value = 5678
    message.value.Pack(value1)
    message.repeated_value.add().Pack(value1)
    message.repeated_value.add().Pack(value2)
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;repeatedValue&#34;: [ {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;value&#34;: 1234\n&#39;
            &#39;  }, {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;value&#34;: 5678\n&#39;
            &#39;  },\n&#39;
            &#39;  {}],\n&#39;
            &#39;  &#34;value&#34;: {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;value&#34;: 1234\n&#39;
            &#39;  }\n&#39;
            &#39;}\n&#39;))
    parsed_message = json_format_proto3_pb2.TestAny()
    self.CheckParseBack(message, parsed_message)
    # Must print @type first
    test_message = json_format_proto3_pb2.TestMessage(
        bool_value=True,
        int32_value=20,
        int64_value=-20,
        uint32_value=20,
        uint64_value=20,
        double_value=3.14,
        string_value=&#39;foo&#39;)
    message.Clear()
    message.value.Pack(test_message)
    self.assertEqual(
        json_format.MessageToJson(message, False)[0:68],
        &#39;{\n&#39;
        &#39;  &#34;value&#34;: {\n&#39;
        &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.TestMessage&#34;&#39;)

  def testAnyMessageDescriptorPoolMissingType(self):
    packed_message = unittest_pb2.OneString()
    packed_message.data = &#39;string&#39;
    message = any_test_pb2.TestAny()
    message.any_value.Pack(packed_message)
    empty_pool = descriptor_pool.DescriptorPool()
    with self.assertRaises(TypeError) as cm:
      json_format.MessageToJson(message, True, descriptor_pool=empty_pool)
    self.assertEqual(
        &#39;Can not find message descriptor by type_url:&#39;
        &#39; type.googleapis.com/protobuf_unittest.OneString.&#39;,
        str(cm.exception))

  def testWellKnownInAnyMessage(self):
    message = any_pb2.Any()
    int32_value = wrappers_pb2.Int32Value()
    int32_value.value = 1234
    message.Pack(int32_value)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: \&#34;type.googleapis.com/google.protobuf.Int32Value\&#34;,\n&#39;
            &#39;  &#34;value&#34;: 1234\n&#39;
            &#39;}\n&#39;))
    parsed_message = any_pb2.Any()
    self.CheckParseBack(message, parsed_message)

    timestamp = timestamp_pb2.Timestamp()
    message.Pack(timestamp)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Timestamp&#34;,\n&#39;
            &#39;  &#34;value&#34;: &#34;1970-01-01T00:00:00Z&#34;\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    duration = duration_pb2.Duration()
    duration.seconds = 1
    message.Pack(duration)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Duration&#34;,\n&#39;
            &#39;  &#34;value&#34;: &#34;1s&#34;\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    field_mask = field_mask_pb2.FieldMask()
    field_mask.paths.append(&#39;foo.bar&#39;)
    field_mask.paths.append(&#39;bar&#39;)
    message.Pack(field_mask)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.FieldMask&#34;,\n&#39;
            &#39;  &#34;value&#34;: &#34;foo.bar,bar&#34;\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    struct_message = struct_pb2.Struct()
    struct_message[&#39;name&#39;] = &#39;Jim&#39;
    message.Pack(struct_message)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Struct&#34;,\n&#39;
            &#39;  &#34;value&#34;: {&#34;name&#34;: &#34;Jim&#34;}\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    nested_any = any_pb2.Any()
    int32_value.value = 5678
    nested_any.Pack(int32_value)
    message.Pack(nested_any)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Any&#34;,\n&#39;
            &#39;  &#34;value&#34;: {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Int32Value&#34;,\n&#39;
            &#39;    &#34;value&#34;: 5678\n&#39;
            &#39;  }\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

  def testParseNull(self):
    message = json_format_proto3_pb2.TestMessage()
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.FillAllFields(parsed_message)
    json_format.Parse(&#39;{&#34;int32Value&#34;: null, &#39;
                      &#39;&#34;int64Value&#34;: null, &#39;
                      &#39;&#34;uint32Value&#34;: null,&#39;
                      &#39;&#34;uint64Value&#34;: null,&#39;
                      &#39;&#34;floatValue&#34;: null,&#39;
                      &#39;&#34;doubleValue&#34;: null,&#39;
                      &#39;&#34;boolValue&#34;: null,&#39;
                      &#39;&#34;stringValue&#34;: null,&#39;
                      &#39;&#34;bytesValue&#34;: null,&#39;
                      &#39;&#34;messageValue&#34;: null,&#39;
                      &#39;&#34;enumValue&#34;: null,&#39;
                      &#39;&#34;repeatedInt32Value&#34;: null,&#39;
                      &#39;&#34;repeatedInt64Value&#34;: null,&#39;
                      &#39;&#34;repeatedUint32Value&#34;: null,&#39;
                      &#39;&#34;repeatedUint64Value&#34;: null,&#39;
                      &#39;&#34;repeatedFloatValue&#34;: null,&#39;
                      &#39;&#34;repeatedDoubleValue&#34;: null,&#39;
                      &#39;&#34;repeatedBoolValue&#34;: null,&#39;
                      &#39;&#34;repeatedStringValue&#34;: null,&#39;
                      &#39;&#34;repeatedBytesValue&#34;: null,&#39;
                      &#39;&#34;repeatedMessageValue&#34;: null,&#39;
                      &#39;&#34;repeatedEnumValue&#34;: null&#39;
                      &#39;}&#39;,
                      parsed_message)
    self.assertEqual(message, parsed_message)
    # Null and {} should have different behavior for sub message.
    self.assertFalse(parsed_message.HasField(&#39;message_value&#39;))
    json_format.Parse(&#39;{&#34;messageValue&#34;: {}}&#39;, parsed_message)
    self.assertTrue(parsed_message.HasField(&#39;message_value&#39;))
    # Null is not allowed to be used as an element in repeated field.
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse repeatedInt32Value field: &#39;
        &#39;null is not allowed to be used as an element in a repeated field.&#39;,
        json_format.Parse,
        &#39;{&#34;repeatedInt32Value&#34;:[1, null]}&#39;,
        parsed_message)
    self.CheckError(&#39;{&#34;repeatedMessageValue&#34;:[null]}&#39;,
                    &#39;Failed to parse repeatedMessageValue field: null is not&#39;
                    &#39; allowed to be used as an element in a repeated field.&#39;)

  def testNanFloat(self):
    message = json_format_proto3_pb2.TestMessage()
    message.float_value = float(&#39;nan&#39;)
    text = &#39;{\n  &#34;floatValue&#34;: &#34;NaN&#34;\n}&#39;
    self.assertEqual(json_format.MessageToJson(message), text)
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message)
    self.assertTrue(math.isnan(parsed_message.float_value))

  def testParseDoubleToFloat(self):
    message = json_format_proto3_pb2.TestMessage()
    text = (&#39;{&#34;repeatedFloatValue&#34;: [3.4028235e+39, 1.4028235e-39]\n}&#39;)
    json_format.Parse(text, message)
    self.assertEqual(message.repeated_float_value[0], float(&#39;inf&#39;))
    self.assertAlmostEqual(message.repeated_float_value[1], 1.4028235e-39)

  def testFloatPrecision(self):
    message = json_format_proto3_pb2.TestMessage()
    message.float_value = 1.123456789
    # Set to 7 valid digits.
    text = &#39;{\n  &#34;floatValue&#34;: 1.123457\n}&#39;
    self.assertEqual(
        json_format.MessageToJson(message, float_precision=7), text)

  def testParseEmptyText(self):
    self.CheckError(&#39;&#39;,
                    r&#39;Failed to load JSON: (Expecting value)|(No JSON).&#39;)

  def testParseEnumValue(self):
    message = json_format_proto3_pb2.TestMessage()
    text = &#39;{&#34;enumValue&#34;: 0}&#39;
    json_format.Parse(text, message)
    text = &#39;{&#34;enumValue&#34;: 1}&#39;
    json_format.Parse(text, message)
    self.CheckError(
        &#39;{&#34;enumValue&#34;: &#34;baz&#34;}&#39;,
        &#39;Failed to parse enumValue field: Invalid enum value baz &#39;
        &#39;for enum type proto3.EnumType.&#39;)
    # Proto3 accepts numeric unknown enums.
    text = &#39;{&#34;enumValue&#34;: 12345}&#39;
    json_format.Parse(text, message)
    # Proto2 does not accept unknown enums.
    message = unittest_pb2.TestAllTypes()
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse optionalNestedEnum field: Invalid enum value 12345 &#39;
        &#39;for enum type protobuf_unittest.TestAllTypes.NestedEnum.&#39;,
        json_format.Parse, &#39;{&#34;optionalNestedEnum&#34;: 12345}&#39;, message)

  def testParseBadIdentifer(self):
    self.CheckError(&#39;{int32Value: 1}&#39;,
                    (r&#39;Failed to load JSON: Expecting property name&#39;
                     r&#39;( enclosed in double quotes)?: line 1&#39;))
    self.CheckError(&#39;{&#34;unknownName&#34;: 1}&#39;,
                    &#39;Message type &#34;proto3.TestMessage&#34; has no field named &#39;
                    &#39;&#34;unknownName&#34;.&#39;)

  def testIgnoreUnknownField(self):
    text = &#39;{&#34;unknownName&#34;: 1}&#39;
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message, ignore_unknown_fields=True)
    text = (&#39;{\n&#39;
            &#39;  &#34;repeatedValue&#34;: [ {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;unknownName&#34;: 1\n&#39;
            &#39;  }]\n&#39;
            &#39;}\n&#39;)
    parsed_message = json_format_proto3_pb2.TestAny()
    json_format.Parse(text, parsed_message, ignore_unknown_fields=True)

  def testDuplicateField(self):
    self.CheckError(&#39;{&#34;int32Value&#34;: 1,\n&#34;int32Value&#34;:2}&#39;,
                    &#39;Failed to load JSON: duplicate key int32Value.&#39;)

  def testInvalidBoolValue(self):
    self.CheckError(&#39;{&#34;boolValue&#34;: 1}&#39;,
                    &#39;Failed to parse boolValue field: &#39;
                    &#39;Expected true or false without quotes.&#39;)
    self.CheckError(&#39;{&#34;boolValue&#34;: &#34;true&#34;}&#39;,
                    &#39;Failed to parse boolValue field: &#39;
                    &#39;Expected true or false without quotes.&#39;)

  def testInvalidIntegerValue(self):
    message = json_format_proto3_pb2.TestMessage()
    text = &#39;{&#34;int32Value&#34;: 0x12345}&#39;
    self.assertRaises(json_format.ParseError,
                      json_format.Parse, text, message)
    self.CheckError(&#39;{&#34;int32Value&#34;: 1.5}&#39;,
                    &#39;Failed to parse int32Value field: &#39;
                    &#39;Couldn\&#39;t parse integer: 1.5.&#39;)
    self.CheckError(&#39;{&#34;int32Value&#34;: 012345}&#39;,
                    (r&#39;Failed to load JSON: Expecting \&#39;?,\&#39;? delimiter: &#39;
                     r&#39;line 1.&#39;))
    self.CheckError(&#39;{&#34;int32Value&#34;: &#34; 1 &#34;}&#39;,
                    &#39;Failed to parse int32Value field: &#39;
                    &#39;Couldn\&#39;t parse integer: &#34; 1 &#34;.&#39;)
    self.CheckError(&#39;{&#34;int32Value&#34;: &#34;1 &#34;}&#39;,
                    &#39;Failed to parse int32Value field: &#39;
                    &#39;Couldn\&#39;t parse integer: &#34;1 &#34;.&#39;)
    self.CheckError(&#39;{&#34;int32Value&#34;: 12345678901234567890}&#39;,
                    &#39;Failed to parse int32Value field: Value out of range: &#39;
                    &#39;12345678901234567890.&#39;)
    self.CheckError(&#39;{&#34;uint32Value&#34;: -1}&#39;,
                    &#39;Failed to parse uint32Value field: &#39;
                    &#39;Value out of range: -1.&#39;)

  def testInvalidFloatValue(self):
    self.CheckError(&#39;{&#34;floatValue&#34;: &#34;nan&#34;}&#39;,
                    &#39;Failed to parse floatValue field: Couldn\&#39;t &#39;
                    &#39;parse float &#34;nan&#34;, use &#34;NaN&#34; instead.&#39;)

  def testInvalidBytesValue(self):
    self.CheckError(&#39;{&#34;bytesValue&#34;: &#34;AQI&#34;}&#39;,
                    &#39;Failed to parse bytesValue field: Incorrect padding.&#39;)
    self.CheckError(&#39;{&#34;bytesValue&#34;: &#34;AQI*&#34;}&#39;,
                    &#39;Failed to parse bytesValue field: Incorrect padding.&#39;)

  def testInvalidRepeated(self):
    self.CheckError(&#39;{&#34;repeatedInt32Value&#34;: 12345}&#39;,
                    (r&#39;Failed to parse repeatedInt32Value field: repeated field&#39;
                     r&#39; repeatedInt32Value must be in \[\] which is 12345.&#39;))

  def testInvalidMap(self):
    message = json_format_proto3_pb2.TestMap()
    text = &#39;{&#34;int32Map&#34;: {&#34;null&#34;: 2, &#34;2&#34;: 3}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse int32Map field: invalid literal&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;int32Map&#34;: {1: 2, &#34;2&#34;: 3}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        (r&#39;Failed to load JSON: Expecting property name&#39;
         r&#39;( enclosed in double quotes)?: line 1&#39;),
        json_format.Parse, text, message)
    text = &#39;{&#34;boolMap&#34;: {&#34;null&#34;: 1}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse boolMap field: Expected &#34;true&#34; or &#34;false&#34;, not null.&#39;,
        json_format.Parse, text, message)
    if sys.version_info &lt; (2, 7):
      return
    text = r&#39;{&#34;stringMap&#34;: {&#34;a&#34;: 3, &#34;\u0061&#34;: 2}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to load JSON: duplicate key a&#39;,
        json_format.Parse, text, message)
    text = r&#39;{&#34;stringMap&#34;: 0}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse stringMap field: Map field string_map must be &#39;
        &#39;in a dict which is 0.&#39;,
        json_format.Parse, text, message)

  def testInvalidTimestamp(self):
    message = json_format_proto3_pb2.TestTimestamp()
    text = &#39;{&#34;value&#34;: &#34;10000-01-01T00:00:00.00Z&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse value field: &#39;
        &#39;time data \&#39;10000-01-01T00:00:00\&#39; does not match&#39;
        &#39; format \&#39;%Y-%m-%dT%H:%M:%S\&#39;.&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;value&#34;: &#34;1970-01-01T00:00:00.0123456789012Z&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;nanos 0123456789012 more than 9 fractional digits.&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;value&#34;: &#34;1972-01-01T01:00:00.01+08&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        (r&#39;Invalid timezone offset value: \+08.&#39;),
        json_format.Parse, text, message)
    # Time smaller than minimum time.
    text = &#39;{&#34;value&#34;: &#34;0000-01-01T00:00:00Z&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse value field: year (0 )?is out of range.&#39;,
        json_format.Parse, text, message)
    # Time bigger than maxinum time.
    message.value.seconds = 253402300800
    self.assertRaisesRegexp(
        OverflowError,
        &#39;date value out of range&#39;,
        json_format.MessageToJson, message)

  def testInvalidOneof(self):
    message = json_format_proto3_pb2.TestOneof()
    text = &#39;{&#34;oneofInt32Value&#34;: 1, &#34;oneofStringValue&#34;: &#34;2&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Message type &#34;proto3.TestOneof&#34;&#39;
        &#39; should not have multiple &#34;oneof_value&#34; oneof fields.&#39;,
        json_format.Parse, text, message)

  def testInvalidListValue(self):
    message = json_format_proto3_pb2.TestListValue()
    text = &#39;{&#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        r&#39;Failed to parse value field: ListValue must be in \[\] which is 1234&#39;,
        json_format.Parse, text, message)

  def testInvalidStruct(self):
    message = json_format_proto3_pb2.TestStruct()
    text = &#39;{&#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse value field: Struct must be in a dict which is 1234&#39;,
        json_format.Parse, text, message)

  def testInvalidAny(self):
    message = any_pb2.Any()
    text = &#39;{&#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Int32Value&#34;}&#39;
    self.assertRaisesRegexp(
        KeyError,
        &#39;value&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;@type is missing when parsing any message.&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;@type&#34;: &#34;type.googleapis.com/MessageNotExist&#34;, &#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        TypeError,
        &#39;Can not find message descriptor by type_url: &#39;
        &#39;type.googleapis.com/MessageNotExist.&#39;,
        json_format.Parse, text, message)
    # Only last part is to be used: b/25630112
    text = (r&#39;{&#34;@type&#34;: &#34;incorrect.googleapis.com/google.protobuf.Int32Value&#34;,&#39;
            r&#39;&#34;value&#34;: 1234}&#39;)
    json_format.Parse(text, message)

  def testPreservingProtoFieldNames(self):
    message = json_format_proto3_pb2.TestMessage()
    message.int32_value = 12345
    self.assertEqual(&#39;{\n  &#34;int32Value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message))
    self.assertEqual(&#39;{\n  &#34;int32_value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message, False, True))
    # When including_default_value_fields is True.
    message = json_format_proto3_pb2.TestTimestamp()
    self.assertEqual(&#39;{\n  &#34;repeatedValue&#34;: []\n}&#39;,
                     json_format.MessageToJson(message, True, False))
    self.assertEqual(&#39;{\n  &#34;repeated_value&#34;: []\n}&#39;,
                     json_format.MessageToJson(message, True, True))

    # Parsers accept both original proto field names and lowerCamelCase names.
    message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(&#39;{&#34;int32Value&#34;: 54321}&#39;, message)
    self.assertEqual(54321, message.int32_value)
    json_format.Parse(&#39;{&#34;int32_value&#34;: 12345}&#39;, message)
    self.assertEqual(12345, message.int32_value)

  def testIndent(self):
    message = json_format_proto3_pb2.TestMessage()
    message.int32_value = 12345
    self.assertEqual(&#39;{\n&#34;int32Value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message, indent=0))

  def testFormatEnumsAsInts(self):
    message = json_format_proto3_pb2.TestMessage()
    message.enum_value = json_format_proto3_pb2.BAR
    message.repeated_enum_value.append(json_format_proto3_pb2.FOO)
    message.repeated_enum_value.append(json_format_proto3_pb2.BAR)
    self.assertEqual(json.loads(&#39;{\n&#39;
                                &#39;  &#34;enumValue&#34;: 1,\n&#39;
                                &#39;  &#34;repeatedEnumValue&#34;: [0, 1]\n&#39;
                                &#39;}\n&#39;),
                     json.loads(json_format.MessageToJson(
                         message, use_integers_for_enums=True)))

  def testParseDict(self):
    expected = 12345
    js_dict = {&#39;int32Value&#39;: expected}
    message = json_format_proto3_pb2.TestMessage()
    json_format.ParseDict(js_dict, message)
    self.assertEqual(expected, message.int32_value)

  def testParseDictAnyDescriptorPoolMissingType(self):
    # Confirm that ParseDict does not raise ParseError with default pool
    js_dict = {
        &#39;any_value&#39;: {
            &#39;@type&#39;: &#39;type.googleapis.com/proto3.MessageType&#39;,
            &#39;value&#39;: 1234
        }
    }
    json_format.ParseDict(js_dict, any_test_pb2.TestAny())
    # Check ParseDict raises ParseError with empty pool
    js_dict = {
        &#39;any_value&#39;: {
            &#39;@type&#39;: &#39;type.googleapis.com/proto3.MessageType&#39;,
            &#39;value&#39;: 1234
        }
    }
    with self.assertRaises(json_format.ParseError) as cm:
      empty_pool = descriptor_pool.DescriptorPool()
      json_format.ParseDict(js_dict,
                            any_test_pb2.TestAny(),
                            descriptor_pool=empty_pool)
    self.assertEqual(
        str(cm.exception),
        &#39;Failed to parse any_value field: Can not find message descriptor by&#39;
        &#39; type_url: type.googleapis.com/proto3.MessageType..&#39;)

  def testMessageToDict(self):
    message = json_format_proto3_pb2.TestMessage()
    message.int32_value = 12345
    expected = {&#39;int32Value&#39;: 12345}
    self.assertEqual(expected,
                     json_format.MessageToDict(message))

  def testJsonName(self):
    message = json_format_proto3_pb2.TestCustomJsonName()
    message.value = 12345
    self.assertEqual(&#39;{\n  &#34;@value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message))
    parsed_message = json_format_proto3_pb2.TestCustomJsonName()
    self.CheckParseBack(message, parsed_message)

  def testSortKeys(self):
    # Testing sort_keys is not perfectly working, as by random luck we could
    # get the output sorted. We just use a selection of names.
    message = json_format_proto3_pb2.TestMessage(bool_value=True,
                                                 int32_value=1,
                                                 int64_value=3,
                                                 uint32_value=4,
                                                 string_value=&#39;bla&#39;)
    self.assertEqual(
        json_format.MessageToJson(message, sort_keys=True),
        # We use json.dumps() instead of a hardcoded string due to differences
        # between Python 2 and Python 3.
        json.dumps({&#39;boolValue&#39;: True, &#39;int32Value&#39;: 1, &#39;int64Value&#39;: &#39;3&#39;,
                    &#39;uint32Value&#39;: 4, &#39;stringValue&#39;: &#39;bla&#39;},
                   indent=2, sort_keys=True))


if __name__ == &#39;__main__&#39;:
  unittest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.protobuf.internal.json_format_test.JsonFormatBase"><code class="flex name class">
<span>class <span class="ident">JsonFormatBase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonFormatBase(unittest.TestCase):

  def FillAllFields(self, message):
    message.int32_value = 20
    message.int64_value = -20
    message.uint32_value = 3120987654
    message.uint64_value = 12345678900
    message.float_value = float(&#39;-inf&#39;)
    message.double_value = 3.1415
    message.bool_value = True
    message.string_value = &#39;foo&#39;
    message.bytes_value = b&#39;bar&#39;
    message.message_value.value = 10
    message.enum_value = json_format_proto3_pb2.BAR
    # Repeated
    message.repeated_int32_value.append(0x7FFFFFFF)
    message.repeated_int32_value.append(-2147483648)
    message.repeated_int64_value.append(9007199254740992)
    message.repeated_int64_value.append(-9007199254740992)
    message.repeated_uint32_value.append(0xFFFFFFF)
    message.repeated_uint32_value.append(0x7FFFFFF)
    message.repeated_uint64_value.append(9007199254740992)
    message.repeated_uint64_value.append(9007199254740991)
    message.repeated_float_value.append(0)

    message.repeated_double_value.append(1E-15)
    message.repeated_double_value.append(float(&#39;inf&#39;))
    message.repeated_bool_value.append(True)
    message.repeated_bool_value.append(False)
    message.repeated_string_value.append(&#39;Few symbols!#$,;&#39;)
    message.repeated_string_value.append(&#39;bar&#39;)
    message.repeated_bytes_value.append(b&#39;foo&#39;)
    message.repeated_bytes_value.append(b&#39;bar&#39;)
    message.repeated_message_value.add().value = 10
    message.repeated_message_value.add().value = 11
    message.repeated_enum_value.append(json_format_proto3_pb2.FOO)
    message.repeated_enum_value.append(json_format_proto3_pb2.BAR)
    self.message = message

  def CheckParseBack(self, message, parsed_message):
    json_format.Parse(json_format.MessageToJson(message),
                      parsed_message)
    self.assertEqual(message, parsed_message)

  def CheckError(self, text, error_message):
    message = json_format_proto3_pb2.TestMessage()
    self.assertRaisesRegexp(
        json_format.ParseError,
        error_message,
        json_format.Parse, text, message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.internal.json_format_test.JsonFormatTest" href="#google.protobuf.internal.json_format_test.JsonFormatTest">JsonFormatTest</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.json_format_test.JsonFormatBase.CheckError"><code class="name flex">
<span>def <span class="ident">CheckError</span></span>(<span>self, text, error_message)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckError(self, text, error_message):
  message = json_format_proto3_pb2.TestMessage()
  self.assertRaisesRegexp(
      json_format.ParseError,
      error_message,
      json_format.Parse, text, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatBase.CheckParseBack"><code class="name flex">
<span>def <span class="ident">CheckParseBack</span></span>(<span>self, message, parsed_message)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckParseBack(self, message, parsed_message):
  json_format.Parse(json_format.MessageToJson(message),
                    parsed_message)
  self.assertEqual(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatBase.FillAllFields"><code class="name flex">
<span>def <span class="ident">FillAllFields</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FillAllFields(self, message):
  message.int32_value = 20
  message.int64_value = -20
  message.uint32_value = 3120987654
  message.uint64_value = 12345678900
  message.float_value = float(&#39;-inf&#39;)
  message.double_value = 3.1415
  message.bool_value = True
  message.string_value = &#39;foo&#39;
  message.bytes_value = b&#39;bar&#39;
  message.message_value.value = 10
  message.enum_value = json_format_proto3_pb2.BAR
  # Repeated
  message.repeated_int32_value.append(0x7FFFFFFF)
  message.repeated_int32_value.append(-2147483648)
  message.repeated_int64_value.append(9007199254740992)
  message.repeated_int64_value.append(-9007199254740992)
  message.repeated_uint32_value.append(0xFFFFFFF)
  message.repeated_uint32_value.append(0x7FFFFFF)
  message.repeated_uint64_value.append(9007199254740992)
  message.repeated_uint64_value.append(9007199254740991)
  message.repeated_float_value.append(0)

  message.repeated_double_value.append(1E-15)
  message.repeated_double_value.append(float(&#39;inf&#39;))
  message.repeated_bool_value.append(True)
  message.repeated_bool_value.append(False)
  message.repeated_string_value.append(&#39;Few symbols!#$,;&#39;)
  message.repeated_string_value.append(&#39;bar&#39;)
  message.repeated_bytes_value.append(b&#39;foo&#39;)
  message.repeated_bytes_value.append(b&#39;bar&#39;)
  message.repeated_message_value.add().value = 10
  message.repeated_message_value.add().value = 11
  message.repeated_enum_value.append(json_format_proto3_pb2.FOO)
  message.repeated_enum_value.append(json_format_proto3_pb2.BAR)
  self.message = message</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest"><code class="flex name class">
<span>class <span class="ident">JsonFormatTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonFormatTest(JsonFormatBase):

  def testEmptyMessageToJson(self):
    message = json_format_proto3_pb2.TestMessage()
    self.assertEqual(json_format.MessageToJson(message),
                     &#39;{}&#39;)
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)

  def testPartialMessageToJson(self):
    message = json_format_proto3_pb2.TestMessage(
        string_value=&#39;test&#39;,
        repeated_int32_value=[89, 4])
    self.assertEqual(json.loads(json_format.MessageToJson(message)),
                     json.loads(&#39;{&#34;stringValue&#34;: &#34;test&#34;, &#39;
                                &#39;&#34;repeatedInt32Value&#34;: [89, 4]}&#39;))
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)

  def testAllFieldsToJson(self):
    message = json_format_proto3_pb2.TestMessage()
    text = (&#39;{&#34;int32Value&#34;: 20, &#39;
            &#39;&#34;int64Value&#34;: &#34;-20&#34;, &#39;
            &#39;&#34;uint32Value&#34;: 3120987654,&#39;
            &#39;&#34;uint64Value&#34;: &#34;12345678900&#34;,&#39;
            &#39;&#34;floatValue&#34;: &#34;-Infinity&#34;,&#39;
            &#39;&#34;doubleValue&#34;: 3.1415,&#39;
            &#39;&#34;boolValue&#34;: true,&#39;
            &#39;&#34;stringValue&#34;: &#34;foo&#34;,&#39;
            &#39;&#34;bytesValue&#34;: &#34;YmFy&#34;,&#39;
            &#39;&#34;messageValue&#34;: {&#34;value&#34;: 10},&#39;
            &#39;&#34;enumValue&#34;: &#34;BAR&#34;,&#39;
            &#39;&#34;repeatedInt32Value&#34;: [2147483647, -2147483648],&#39;
            &#39;&#34;repeatedInt64Value&#34;: [&#34;9007199254740992&#34;, &#34;-9007199254740992&#34;],&#39;
            &#39;&#34;repeatedUint32Value&#34;: [268435455, 134217727],&#39;
            &#39;&#34;repeatedUint64Value&#34;: [&#34;9007199254740992&#34;, &#34;9007199254740991&#34;],&#39;
            &#39;&#34;repeatedFloatValue&#34;: [0],&#39;
            &#39;&#34;repeatedDoubleValue&#34;: [1e-15, &#34;Infinity&#34;],&#39;
            &#39;&#34;repeatedBoolValue&#34;: [true, false],&#39;
            &#39;&#34;repeatedStringValue&#34;: [&#34;Few symbols!#$,;&#34;, &#34;bar&#34;],&#39;
            &#39;&#34;repeatedBytesValue&#34;: [&#34;Zm9v&#34;, &#34;YmFy&#34;],&#39;
            &#39;&#34;repeatedMessageValue&#34;: [{&#34;value&#34;: 10}, {&#34;value&#34;: 11}],&#39;
            &#39;&#34;repeatedEnumValue&#34;: [&#34;FOO&#34;, &#34;BAR&#34;]&#39;
            &#39;}&#39;)
    self.FillAllFields(message)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message)),
        json.loads(text))
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message)
    self.assertEqual(message, parsed_message)

  def testUnknownEnumToJsonAndBack(self):
    text = &#39;{\n  &#34;enumValue&#34;: 999\n}&#39;
    message = json_format_proto3_pb2.TestMessage()
    message.enum_value = 999
    self.assertEqual(json_format.MessageToJson(message),
                     text)
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message)
    self.assertEqual(message, parsed_message)

  def testExtensionToJsonAndBack(self):
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_text = json_format.MessageToJson(
        message
    )
    parsed_message = unittest_mset_pb2.TestMessageSetContainer()
    json_format.Parse(message_text, parsed_message)
    self.assertEqual(message, parsed_message)

  def testExtensionErrors(self):
    self.CheckError(&#39;{&#34;[extensionField]&#34;: {}}&#39;,
                    &#39;Message type proto3.TestMessage does not have extensions&#39;)

  def testExtensionToDictAndBack(self):
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    parsed_message = unittest_mset_pb2.TestMessageSetContainer()
    json_format.ParseDict(message_dict, parsed_message)
    self.assertEqual(message, parsed_message)

  def testExtensionToDictAndBackWithScalar(self):
    message = unittest_pb2.TestAllExtensions()
    ext1 = unittest_pb2.TestNestedExtension.test
    message.Extensions[ext1] = &#39;data&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    parsed_message = unittest_pb2.TestAllExtensions()
    json_format.ParseDict(message_dict, parsed_message)
    self.assertEqual(message, parsed_message)

  def testJsonParseDictToAnyDoesNotAlterInput(self):
    orig_dict = {
        &#39;int32Value&#39;: 20,
        &#39;@type&#39;: &#39;type.googleapis.com/proto3.TestMessage&#39;
    }
    copied_dict = json.loads(json.dumps(orig_dict))
    parsed_message = any_pb2.Any()
    json_format.ParseDict(copied_dict, parsed_message)
    self.assertEqual(copied_dict, orig_dict)

  def testExtensionSerializationDictMatchesProto3Spec(self):
    &#34;&#34;&#34;See go/proto3-json-spec for spec.
    &#34;&#34;&#34;
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    golden_dict = {
        &#39;messageSet&#39;: {
            &#39;[protobuf_unittest.&#39;
            &#39;TestMessageSetExtension1.messageSetExtension]&#39;: {
                &#39;i&#39;: 23,
            },
            &#39;[protobuf_unittest.&#39;
            &#39;TestMessageSetExtension2.messageSetExtension]&#39;: {
                &#39;str&#39;: u&#39;foo&#39;,
            },
        },
    }
    self.assertEqual(golden_dict, message_dict)

  def testExtensionSerializationDictMatchesProto3SpecMore(self):
    &#34;&#34;&#34;See go/proto3-json-spec for spec.
    &#34;&#34;&#34;
    message = json_format_pb2.TestMessageWithExtension()
    ext = json_format_pb2.TestExtension.ext
    message.Extensions[ext].value = &#39;stuff&#39;
    message_dict = json_format.MessageToDict(
        message
    )
    expected_dict = {
        &#39;[protobuf_unittest.TestExtension.ext]&#39;: {
            &#39;value&#39;: u&#39;stuff&#39;,
        },
    }
    self.assertEqual(expected_dict, message_dict)


  def testExtensionSerializationJsonMatchesProto3Spec(self):
    &#34;&#34;&#34;See go/proto3-json-spec for spec.
    &#34;&#34;&#34;
    message = unittest_mset_pb2.TestMessageSetContainer()
    ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
    ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
    message.message_set.Extensions[ext1].i = 23
    message.message_set.Extensions[ext2].str = &#39;foo&#39;
    message_text = json_format.MessageToJson(
        message
    )
    ext1_text = (&#39;protobuf_unittest.TestMessageSetExtension1.&#39;
                 &#39;messageSetExtension&#39;)
    ext2_text = (&#39;protobuf_unittest.TestMessageSetExtension2.&#39;
                 &#39;messageSetExtension&#39;)
    golden_text = (&#39;{&#34;messageSet&#34;: {&#39;
                   &#39;    &#34;[%s]&#34;: {&#39;
                   &#39;        &#34;i&#34;: 23&#39;
                   &#39;    },&#39;
                   &#39;    &#34;[%s]&#34;: {&#39;
                   &#39;        &#34;str&#34;: &#34;foo&#34;&#39;
                   &#39;    }&#39;
                   &#39;}}&#39;) % (ext1_text, ext2_text)
    self.assertEqual(json.loads(golden_text), json.loads(message_text))


  def testJsonEscapeString(self):
    message = json_format_proto3_pb2.TestMessage()
    if sys.version_info[0] &lt; 3:
      message.string_value = &#39;&amp;\n&lt;\&#34;\r&gt;\b\t\f\\\001/\xe2\x80\xa8\xe2\x80\xa9&#39;
    else:
      message.string_value = &#39;&amp;\n&lt;\&#34;\r&gt;\b\t\f\\\001/&#39;
      message.string_value += (b&#39;\xe2\x80\xa8\xe2\x80\xa9&#39;).decode(&#39;utf-8&#39;)
    self.assertEqual(
        json_format.MessageToJson(message),
        &#39;{\n  &#34;stringValue&#34;: &#39;
        &#39;&#34;&amp;\\n&lt;\\\&#34;\\r&gt;\\b\\t\\f\\\\\\u0001/\\u2028\\u2029&#34;\n}&#39;)
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)
    text = u&#39;{&#34;int32Value&#34;: &#34;\u0031&#34;}&#39;
    json_format.Parse(text, message)
    self.assertEqual(message.int32_value, 1)

  def testAlwaysSeriliaze(self):
    message = json_format_proto3_pb2.TestMessage(
        string_value=&#39;foo&#39;)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;repeatedStringValue&#34;: [],&#39;
                   &#39;&#34;stringValue&#34;: &#34;foo&#34;,&#39;
                   &#39;&#34;repeatedBoolValue&#34;: [],&#39;
                   &#39;&#34;repeatedUint32Value&#34;: [],&#39;
                   &#39;&#34;repeatedInt32Value&#34;: [],&#39;
                   &#39;&#34;enumValue&#34;: &#34;FOO&#34;,&#39;
                   &#39;&#34;int32Value&#34;: 0,&#39;
                   &#39;&#34;floatValue&#34;: 0,&#39;
                   &#39;&#34;int64Value&#34;: &#34;0&#34;,&#39;
                   &#39;&#34;uint32Value&#34;: 0,&#39;
                   &#39;&#34;repeatedBytesValue&#34;: [],&#39;
                   &#39;&#34;repeatedUint64Value&#34;: [],&#39;
                   &#39;&#34;repeatedDoubleValue&#34;: [],&#39;
                   &#39;&#34;bytesValue&#34;: &#34;&#34;,&#39;
                   &#39;&#34;boolValue&#34;: false,&#39;
                   &#39;&#34;repeatedEnumValue&#34;: [],&#39;
                   &#39;&#34;uint64Value&#34;: &#34;0&#34;,&#39;
                   &#39;&#34;doubleValue&#34;: 0,&#39;
                   &#39;&#34;repeatedFloatValue&#34;: [],&#39;
                   &#39;&#34;repeatedInt64Value&#34;: [],&#39;
                   &#39;&#34;repeatedMessageValue&#34;: []}&#39;))
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.CheckParseBack(message, parsed_message)

  def testIntegersRepresentedAsFloat(self):
    message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(&#39;{&#34;int32Value&#34;: -2.147483648e9}&#39;, message)
    self.assertEqual(message.int32_value, -2147483648)
    json_format.Parse(&#39;{&#34;int32Value&#34;: 1e5}&#39;, message)
    self.assertEqual(message.int32_value, 100000)
    json_format.Parse(&#39;{&#34;int32Value&#34;: 1.0}&#39;, message)
    self.assertEqual(message.int32_value, 1)

  def testMapFields(self):
    message = json_format_proto3_pb2.TestNestedMap()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;boolMap&#34;: {},&#39;
                   &#39;&#34;int32Map&#34;: {},&#39;
                   &#39;&#34;int64Map&#34;: {},&#39;
                   &#39;&#34;uint32Map&#34;: {},&#39;
                   &#39;&#34;uint64Map&#34;: {},&#39;
                   &#39;&#34;stringMap&#34;: {},&#39;
                   &#39;&#34;mapMap&#34;: {}&#39;
                   &#39;}&#39;))
    message.bool_map[True] = 1
    message.bool_map[False] = 2
    message.int32_map[1] = 2
    message.int32_map[2] = 3
    message.int64_map[1] = 2
    message.int64_map[2] = 3
    message.uint32_map[1] = 2
    message.uint32_map[2] = 3
    message.uint64_map[1] = 2
    message.uint64_map[2] = 3
    message.string_map[&#39;1&#39;] = 2
    message.string_map[&#39;null&#39;] = 3
    message.map_map[&#39;1&#39;].bool_map[True] = 3
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(&#39;{&#39;
                   &#39;&#34;boolMap&#34;: {&#34;false&#34;: 2, &#34;true&#34;: 1},&#39;
                   &#39;&#34;int32Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;int64Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;uint32Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;uint64Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                   &#39;&#34;stringMap&#34;: {&#34;1&#34;: 2, &#34;null&#34;: 3},&#39;
                   &#39;&#34;mapMap&#34;: {&#34;1&#34;: {&#34;boolMap&#34;: {&#34;true&#34;: 3}}}&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestNestedMap()
    self.CheckParseBack(message, parsed_message)

  def testOneofFields(self):
    message = json_format_proto3_pb2.TestOneof()
    # Always print does not affect oneof fields.
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{}&#39;)
    message.oneof_int32_value = 0
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{\n&#39;
        &#39;  &#34;oneofInt32Value&#34;: 0\n&#39;
        &#39;}&#39;)
    parsed_message = json_format_proto3_pb2.TestOneof()
    self.CheckParseBack(message, parsed_message)

  def testSurrogates(self):
    # Test correct surrogate handling.
    message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(&#39;{&#34;stringValue&#34;: &#34;\\uD83D\\uDE01&#34;}&#39;, message)
    self.assertEqual(message.string_value,
                     b&#39;\xF0\x9F\x98\x81&#39;.decode(&#39;utf-8&#39;, &#39;strict&#39;))

    # Error case: unpaired high surrogate.
    self.CheckError(
        &#39;{&#34;stringValue&#34;: &#34;\\uD83D&#34;}&#39;,
        r&#39;Invalid \\uXXXX escape|Unpaired.*surrogate&#39;)

    # Unpaired low surrogate.
    self.CheckError(
        &#39;{&#34;stringValue&#34;: &#34;\\uDE01&#34;}&#39;,
        r&#39;Invalid \\uXXXX escape|Unpaired.*surrogate&#39;)

  def testTimestampMessage(self):
    message = json_format_proto3_pb2.TestTimestamp()
    message.value.seconds = 0
    message.value.nanos = 0
    message.repeated_value.add().seconds = 20
    message.repeated_value[0].nanos = 1
    message.repeated_value.add().seconds = 0
    message.repeated_value[1].nanos = 10000
    message.repeated_value.add().seconds = 100000000
    message.repeated_value[2].nanos = 0
    # Maximum time
    message.repeated_value.add().seconds = 253402300799
    message.repeated_value[3].nanos = 999999999
    # Minimum time
    message.repeated_value.add().seconds = -62135596800
    message.repeated_value[4].nanos = 0
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;value&#34;: &#34;1970-01-01T00:00:00Z&#34;,&#39;
                   &#39;&#34;repeatedValue&#34;: [&#39;
                   &#39;  &#34;1970-01-01T00:00:20.000000001Z&#34;,&#39;
                   &#39;  &#34;1970-01-01T00:00:00.000010Z&#34;,&#39;
                   &#39;  &#34;1973-03-03T09:46:40Z&#34;,&#39;
                   &#39;  &#34;9999-12-31T23:59:59.999999999Z&#34;,&#39;
                   &#39;  &#34;0001-01-01T00:00:00Z&#34;&#39;
                   &#39;]&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestTimestamp()
    self.CheckParseBack(message, parsed_message)
    text = (r&#39;{&#34;value&#34;: &#34;1970-01-01T00:00:00.01+08:00&#34;,&#39;
            r&#39;&#34;repeatedValue&#34;:[&#39;
            r&#39;  &#34;1970-01-01T00:00:00.01+08:30&#34;,&#39;
            r&#39;  &#34;1970-01-01T00:00:00.01-01:23&#34;]}&#39;)
    json_format.Parse(text, parsed_message)
    self.assertEqual(parsed_message.value.seconds, -8 * 3600)
    self.assertEqual(parsed_message.value.nanos, 10000000)
    self.assertEqual(parsed_message.repeated_value[0].seconds, -8.5 * 3600)
    self.assertEqual(parsed_message.repeated_value[1].seconds, 3600 + 23 * 60)

  def testDurationMessage(self):
    message = json_format_proto3_pb2.TestDuration()
    message.value.seconds = 1
    message.repeated_value.add().seconds = 0
    message.repeated_value[0].nanos = 10
    message.repeated_value.add().seconds = -1
    message.repeated_value[1].nanos = -1000
    message.repeated_value.add().seconds = 10
    message.repeated_value[2].nanos = 11000000
    message.repeated_value.add().seconds = -315576000000
    message.repeated_value.add().seconds = 315576000000
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{&#39;
                   &#39;&#34;value&#34;: &#34;1s&#34;,&#39;
                   &#39;&#34;repeatedValue&#34;: [&#39;
                   &#39;  &#34;0.000000010s&#34;,&#39;
                   &#39;  &#34;-1.000001s&#34;,&#39;
                   &#39;  &#34;10.011s&#34;,&#39;
                   &#39;  &#34;-315576000000s&#34;,&#39;
                   &#39;  &#34;315576000000s&#34;&#39;
                   &#39;]&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestDuration()
    self.CheckParseBack(message, parsed_message)

  def testFieldMaskMessage(self):
    message = json_format_proto3_pb2.TestFieldMask()
    message.value.paths.append(&#39;foo.bar&#39;)
    message.value.paths.append(&#39;bar&#39;)
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{\n&#39;
        &#39;  &#34;value&#34;: &#34;foo.bar,bar&#34;\n&#39;
        &#39;}&#39;)
    parsed_message = json_format_proto3_pb2.TestFieldMask()
    self.CheckParseBack(message, parsed_message)

    message.value.Clear()
    self.assertEqual(
        json_format.MessageToJson(message, True),
        &#39;{\n&#39;
        &#39;  &#34;value&#34;: &#34;&#34;\n&#39;
        &#39;}&#39;)
    self.CheckParseBack(message, parsed_message)

  def testWrapperMessage(self):
    message = json_format_proto3_pb2.TestWrapper()
    message.bool_value.value = False
    message.int32_value.value = 0
    message.string_value.value = &#39;&#39;
    message.bytes_value.value = b&#39;&#39;
    message.repeated_bool_value.add().value = True
    message.repeated_bool_value.add().value = False
    message.repeated_int32_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(&#39;{\n&#39;
                   &#39;  &#34;int32Value&#34;: 0,&#39;
                   &#39;  &#34;boolValue&#34;: false,&#39;
                   &#39;  &#34;stringValue&#34;: &#34;&#34;,&#39;
                   &#39;  &#34;bytesValue&#34;: &#34;&#34;,&#39;
                   &#39;  &#34;repeatedBoolValue&#34;: [true, false],&#39;
                   &#39;  &#34;repeatedInt32Value&#34;: [0],&#39;
                   &#39;  &#34;repeatedUint32Value&#34;: [],&#39;
                   &#39;  &#34;repeatedFloatValue&#34;: [],&#39;
                   &#39;  &#34;repeatedDoubleValue&#34;: [],&#39;
                   &#39;  &#34;repeatedBytesValue&#34;: [],&#39;
                   &#39;  &#34;repeatedInt64Value&#34;: [],&#39;
                   &#39;  &#34;repeatedUint64Value&#34;: [],&#39;
                   &#39;  &#34;repeatedStringValue&#34;: []&#39;
                   &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestWrapper()
    self.CheckParseBack(message, parsed_message)

  def testStructMessage(self):
    message = json_format_proto3_pb2.TestStruct()
    message.value[&#39;name&#39;] = &#39;Jim&#39;
    message.value[&#39;age&#39;] = 10
    message.value[&#39;attend&#39;] = True
    message.value[&#39;email&#39;] = None
    message.value.get_or_create_struct(&#39;address&#39;)[&#39;city&#39;] = &#39;SFO&#39;
    message.value[&#39;address&#39;][&#39;house_number&#39;] = 1024
    message.value.get_or_create_struct(&#39;empty_struct&#39;)
    message.value.get_or_create_list(&#39;empty_list&#39;)
    struct_list = message.value.get_or_create_list(&#39;list&#39;)
    struct_list.extend([6, &#39;seven&#39;, True, False, None])
    struct_list.add_struct()[&#39;subkey2&#39;] = 9
    message.repeated_value.add()[&#39;age&#39;] = 11
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#39;
            &#39;  &#34;value&#34;: {&#39;
            &#39;    &#34;address&#34;: {&#39;
            &#39;      &#34;city&#34;: &#34;SFO&#34;, &#39;
            &#39;      &#34;house_number&#34;: 1024&#39;
            &#39;    }, &#39;
            &#39;    &#34;empty_struct&#34;: {}, &#39;
            &#39;    &#34;empty_list&#34;: [], &#39;
            &#39;    &#34;age&#34;: 10, &#39;
            &#39;    &#34;name&#34;: &#34;Jim&#34;, &#39;
            &#39;    &#34;attend&#34;: true, &#39;
            &#39;    &#34;email&#34;: null, &#39;
            &#39;    &#34;list&#34;: [6, &#34;seven&#34;, true, false, null, {&#34;subkey2&#34;: 9}]&#39;
            &#39;  },&#39;
            &#39;  &#34;repeatedValue&#34;: [{&#34;age&#34;: 11}, {}]&#39;
            &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestStruct()
    self.CheckParseBack(message, parsed_message)
    # check for regression; this used to raise
    parsed_message.value[&#39;empty_struct&#39;]
    parsed_message.value[&#39;empty_list&#39;]

  def testValueMessage(self):
    message = json_format_proto3_pb2.TestValue()
    message.value.string_value = &#39;hello&#39;
    message.repeated_value.add().number_value = 11.1
    message.repeated_value.add().bool_value = False
    message.repeated_value.add().null_value = 0
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#39;
            &#39;  &#34;value&#34;: &#34;hello&#34;,&#39;
            &#39;  &#34;repeatedValue&#34;: [11.1, false, null]&#39;
            &#39;}&#39;))
    parsed_message = json_format_proto3_pb2.TestValue()
    self.CheckParseBack(message, parsed_message)
    # Can&#39;t parse back if the Value message is not set.
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#39;
            &#39;  &#34;value&#34;: &#34;hello&#34;,&#39;
            &#39;  &#34;repeatedValue&#34;: [11.1, false, null, null]&#39;
            &#39;}&#39;))
    message.Clear()
    json_format.Parse(&#39;{&#34;value&#34;: null}&#39;, message)
    self.assertEqual(message.value.WhichOneof(&#39;kind&#39;), &#39;null_value&#39;)

  def testListValueMessage(self):
    message = json_format_proto3_pb2.TestListValue()
    message.value.values.add().number_value = 11.1
    message.value.values.add().null_value = 0
    message.value.values.add().bool_value = True
    message.value.values.add().string_value = &#39;hello&#39;
    message.value.values.add().struct_value[&#39;name&#39;] = &#39;Jim&#39;
    message.repeated_value.add().values.add().number_value = 1
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, False)),
        json.loads(
            &#39;{&#34;value&#34;: [11.1, null, true, &#34;hello&#34;, {&#34;name&#34;: &#34;Jim&#34;}]\n,&#39;
            &#39;&#34;repeatedValue&#34;: [[1], []]}&#39;))
    parsed_message = json_format_proto3_pb2.TestListValue()
    self.CheckParseBack(message, parsed_message)

  def testAnyMessage(self):
    message = json_format_proto3_pb2.TestAny()
    value1 = json_format_proto3_pb2.MessageType()
    value2 = json_format_proto3_pb2.MessageType()
    value1.value = 1234
    value2.value = 5678
    message.value.Pack(value1)
    message.repeated_value.add().Pack(value1)
    message.repeated_value.add().Pack(value2)
    message.repeated_value.add()
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;repeatedValue&#34;: [ {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;value&#34;: 1234\n&#39;
            &#39;  }, {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;value&#34;: 5678\n&#39;
            &#39;  },\n&#39;
            &#39;  {}],\n&#39;
            &#39;  &#34;value&#34;: {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;value&#34;: 1234\n&#39;
            &#39;  }\n&#39;
            &#39;}\n&#39;))
    parsed_message = json_format_proto3_pb2.TestAny()
    self.CheckParseBack(message, parsed_message)
    # Must print @type first
    test_message = json_format_proto3_pb2.TestMessage(
        bool_value=True,
        int32_value=20,
        int64_value=-20,
        uint32_value=20,
        uint64_value=20,
        double_value=3.14,
        string_value=&#39;foo&#39;)
    message.Clear()
    message.value.Pack(test_message)
    self.assertEqual(
        json_format.MessageToJson(message, False)[0:68],
        &#39;{\n&#39;
        &#39;  &#34;value&#34;: {\n&#39;
        &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.TestMessage&#34;&#39;)

  def testAnyMessageDescriptorPoolMissingType(self):
    packed_message = unittest_pb2.OneString()
    packed_message.data = &#39;string&#39;
    message = any_test_pb2.TestAny()
    message.any_value.Pack(packed_message)
    empty_pool = descriptor_pool.DescriptorPool()
    with self.assertRaises(TypeError) as cm:
      json_format.MessageToJson(message, True, descriptor_pool=empty_pool)
    self.assertEqual(
        &#39;Can not find message descriptor by type_url:&#39;
        &#39; type.googleapis.com/protobuf_unittest.OneString.&#39;,
        str(cm.exception))

  def testWellKnownInAnyMessage(self):
    message = any_pb2.Any()
    int32_value = wrappers_pb2.Int32Value()
    int32_value.value = 1234
    message.Pack(int32_value)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: \&#34;type.googleapis.com/google.protobuf.Int32Value\&#34;,\n&#39;
            &#39;  &#34;value&#34;: 1234\n&#39;
            &#39;}\n&#39;))
    parsed_message = any_pb2.Any()
    self.CheckParseBack(message, parsed_message)

    timestamp = timestamp_pb2.Timestamp()
    message.Pack(timestamp)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Timestamp&#34;,\n&#39;
            &#39;  &#34;value&#34;: &#34;1970-01-01T00:00:00Z&#34;\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    duration = duration_pb2.Duration()
    duration.seconds = 1
    message.Pack(duration)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Duration&#34;,\n&#39;
            &#39;  &#34;value&#34;: &#34;1s&#34;\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    field_mask = field_mask_pb2.FieldMask()
    field_mask.paths.append(&#39;foo.bar&#39;)
    field_mask.paths.append(&#39;bar&#39;)
    message.Pack(field_mask)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.FieldMask&#34;,\n&#39;
            &#39;  &#34;value&#34;: &#34;foo.bar,bar&#34;\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    struct_message = struct_pb2.Struct()
    struct_message[&#39;name&#39;] = &#39;Jim&#39;
    message.Pack(struct_message)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Struct&#34;,\n&#39;
            &#39;  &#34;value&#34;: {&#34;name&#34;: &#34;Jim&#34;}\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

    nested_any = any_pb2.Any()
    int32_value.value = 5678
    nested_any.Pack(int32_value)
    message.Pack(nested_any)
    self.assertEqual(
        json.loads(json_format.MessageToJson(message, True)),
        json.loads(
            &#39;{\n&#39;
            &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Any&#34;,\n&#39;
            &#39;  &#34;value&#34;: {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Int32Value&#34;,\n&#39;
            &#39;    &#34;value&#34;: 5678\n&#39;
            &#39;  }\n&#39;
            &#39;}\n&#39;))
    self.CheckParseBack(message, parsed_message)

  def testParseNull(self):
    message = json_format_proto3_pb2.TestMessage()
    parsed_message = json_format_proto3_pb2.TestMessage()
    self.FillAllFields(parsed_message)
    json_format.Parse(&#39;{&#34;int32Value&#34;: null, &#39;
                      &#39;&#34;int64Value&#34;: null, &#39;
                      &#39;&#34;uint32Value&#34;: null,&#39;
                      &#39;&#34;uint64Value&#34;: null,&#39;
                      &#39;&#34;floatValue&#34;: null,&#39;
                      &#39;&#34;doubleValue&#34;: null,&#39;
                      &#39;&#34;boolValue&#34;: null,&#39;
                      &#39;&#34;stringValue&#34;: null,&#39;
                      &#39;&#34;bytesValue&#34;: null,&#39;
                      &#39;&#34;messageValue&#34;: null,&#39;
                      &#39;&#34;enumValue&#34;: null,&#39;
                      &#39;&#34;repeatedInt32Value&#34;: null,&#39;
                      &#39;&#34;repeatedInt64Value&#34;: null,&#39;
                      &#39;&#34;repeatedUint32Value&#34;: null,&#39;
                      &#39;&#34;repeatedUint64Value&#34;: null,&#39;
                      &#39;&#34;repeatedFloatValue&#34;: null,&#39;
                      &#39;&#34;repeatedDoubleValue&#34;: null,&#39;
                      &#39;&#34;repeatedBoolValue&#34;: null,&#39;
                      &#39;&#34;repeatedStringValue&#34;: null,&#39;
                      &#39;&#34;repeatedBytesValue&#34;: null,&#39;
                      &#39;&#34;repeatedMessageValue&#34;: null,&#39;
                      &#39;&#34;repeatedEnumValue&#34;: null&#39;
                      &#39;}&#39;,
                      parsed_message)
    self.assertEqual(message, parsed_message)
    # Null and {} should have different behavior for sub message.
    self.assertFalse(parsed_message.HasField(&#39;message_value&#39;))
    json_format.Parse(&#39;{&#34;messageValue&#34;: {}}&#39;, parsed_message)
    self.assertTrue(parsed_message.HasField(&#39;message_value&#39;))
    # Null is not allowed to be used as an element in repeated field.
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse repeatedInt32Value field: &#39;
        &#39;null is not allowed to be used as an element in a repeated field.&#39;,
        json_format.Parse,
        &#39;{&#34;repeatedInt32Value&#34;:[1, null]}&#39;,
        parsed_message)
    self.CheckError(&#39;{&#34;repeatedMessageValue&#34;:[null]}&#39;,
                    &#39;Failed to parse repeatedMessageValue field: null is not&#39;
                    &#39; allowed to be used as an element in a repeated field.&#39;)

  def testNanFloat(self):
    message = json_format_proto3_pb2.TestMessage()
    message.float_value = float(&#39;nan&#39;)
    text = &#39;{\n  &#34;floatValue&#34;: &#34;NaN&#34;\n}&#39;
    self.assertEqual(json_format.MessageToJson(message), text)
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message)
    self.assertTrue(math.isnan(parsed_message.float_value))

  def testParseDoubleToFloat(self):
    message = json_format_proto3_pb2.TestMessage()
    text = (&#39;{&#34;repeatedFloatValue&#34;: [3.4028235e+39, 1.4028235e-39]\n}&#39;)
    json_format.Parse(text, message)
    self.assertEqual(message.repeated_float_value[0], float(&#39;inf&#39;))
    self.assertAlmostEqual(message.repeated_float_value[1], 1.4028235e-39)

  def testFloatPrecision(self):
    message = json_format_proto3_pb2.TestMessage()
    message.float_value = 1.123456789
    # Set to 7 valid digits.
    text = &#39;{\n  &#34;floatValue&#34;: 1.123457\n}&#39;
    self.assertEqual(
        json_format.MessageToJson(message, float_precision=7), text)

  def testParseEmptyText(self):
    self.CheckError(&#39;&#39;,
                    r&#39;Failed to load JSON: (Expecting value)|(No JSON).&#39;)

  def testParseEnumValue(self):
    message = json_format_proto3_pb2.TestMessage()
    text = &#39;{&#34;enumValue&#34;: 0}&#39;
    json_format.Parse(text, message)
    text = &#39;{&#34;enumValue&#34;: 1}&#39;
    json_format.Parse(text, message)
    self.CheckError(
        &#39;{&#34;enumValue&#34;: &#34;baz&#34;}&#39;,
        &#39;Failed to parse enumValue field: Invalid enum value baz &#39;
        &#39;for enum type proto3.EnumType.&#39;)
    # Proto3 accepts numeric unknown enums.
    text = &#39;{&#34;enumValue&#34;: 12345}&#39;
    json_format.Parse(text, message)
    # Proto2 does not accept unknown enums.
    message = unittest_pb2.TestAllTypes()
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse optionalNestedEnum field: Invalid enum value 12345 &#39;
        &#39;for enum type protobuf_unittest.TestAllTypes.NestedEnum.&#39;,
        json_format.Parse, &#39;{&#34;optionalNestedEnum&#34;: 12345}&#39;, message)

  def testParseBadIdentifer(self):
    self.CheckError(&#39;{int32Value: 1}&#39;,
                    (r&#39;Failed to load JSON: Expecting property name&#39;
                     r&#39;( enclosed in double quotes)?: line 1&#39;))
    self.CheckError(&#39;{&#34;unknownName&#34;: 1}&#39;,
                    &#39;Message type &#34;proto3.TestMessage&#34; has no field named &#39;
                    &#39;&#34;unknownName&#34;.&#39;)

  def testIgnoreUnknownField(self):
    text = &#39;{&#34;unknownName&#34;: 1}&#39;
    parsed_message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(text, parsed_message, ignore_unknown_fields=True)
    text = (&#39;{\n&#39;
            &#39;  &#34;repeatedValue&#34;: [ {\n&#39;
            &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
            &#39;    &#34;unknownName&#34;: 1\n&#39;
            &#39;  }]\n&#39;
            &#39;}\n&#39;)
    parsed_message = json_format_proto3_pb2.TestAny()
    json_format.Parse(text, parsed_message, ignore_unknown_fields=True)

  def testDuplicateField(self):
    self.CheckError(&#39;{&#34;int32Value&#34;: 1,\n&#34;int32Value&#34;:2}&#39;,
                    &#39;Failed to load JSON: duplicate key int32Value.&#39;)

  def testInvalidBoolValue(self):
    self.CheckError(&#39;{&#34;boolValue&#34;: 1}&#39;,
                    &#39;Failed to parse boolValue field: &#39;
                    &#39;Expected true or false without quotes.&#39;)
    self.CheckError(&#39;{&#34;boolValue&#34;: &#34;true&#34;}&#39;,
                    &#39;Failed to parse boolValue field: &#39;
                    &#39;Expected true or false without quotes.&#39;)

  def testInvalidIntegerValue(self):
    message = json_format_proto3_pb2.TestMessage()
    text = &#39;{&#34;int32Value&#34;: 0x12345}&#39;
    self.assertRaises(json_format.ParseError,
                      json_format.Parse, text, message)
    self.CheckError(&#39;{&#34;int32Value&#34;: 1.5}&#39;,
                    &#39;Failed to parse int32Value field: &#39;
                    &#39;Couldn\&#39;t parse integer: 1.5.&#39;)
    self.CheckError(&#39;{&#34;int32Value&#34;: 012345}&#39;,
                    (r&#39;Failed to load JSON: Expecting \&#39;?,\&#39;? delimiter: &#39;
                     r&#39;line 1.&#39;))
    self.CheckError(&#39;{&#34;int32Value&#34;: &#34; 1 &#34;}&#39;,
                    &#39;Failed to parse int32Value field: &#39;
                    &#39;Couldn\&#39;t parse integer: &#34; 1 &#34;.&#39;)
    self.CheckError(&#39;{&#34;int32Value&#34;: &#34;1 &#34;}&#39;,
                    &#39;Failed to parse int32Value field: &#39;
                    &#39;Couldn\&#39;t parse integer: &#34;1 &#34;.&#39;)
    self.CheckError(&#39;{&#34;int32Value&#34;: 12345678901234567890}&#39;,
                    &#39;Failed to parse int32Value field: Value out of range: &#39;
                    &#39;12345678901234567890.&#39;)
    self.CheckError(&#39;{&#34;uint32Value&#34;: -1}&#39;,
                    &#39;Failed to parse uint32Value field: &#39;
                    &#39;Value out of range: -1.&#39;)

  def testInvalidFloatValue(self):
    self.CheckError(&#39;{&#34;floatValue&#34;: &#34;nan&#34;}&#39;,
                    &#39;Failed to parse floatValue field: Couldn\&#39;t &#39;
                    &#39;parse float &#34;nan&#34;, use &#34;NaN&#34; instead.&#39;)

  def testInvalidBytesValue(self):
    self.CheckError(&#39;{&#34;bytesValue&#34;: &#34;AQI&#34;}&#39;,
                    &#39;Failed to parse bytesValue field: Incorrect padding.&#39;)
    self.CheckError(&#39;{&#34;bytesValue&#34;: &#34;AQI*&#34;}&#39;,
                    &#39;Failed to parse bytesValue field: Incorrect padding.&#39;)

  def testInvalidRepeated(self):
    self.CheckError(&#39;{&#34;repeatedInt32Value&#34;: 12345}&#39;,
                    (r&#39;Failed to parse repeatedInt32Value field: repeated field&#39;
                     r&#39; repeatedInt32Value must be in \[\] which is 12345.&#39;))

  def testInvalidMap(self):
    message = json_format_proto3_pb2.TestMap()
    text = &#39;{&#34;int32Map&#34;: {&#34;null&#34;: 2, &#34;2&#34;: 3}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse int32Map field: invalid literal&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;int32Map&#34;: {1: 2, &#34;2&#34;: 3}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        (r&#39;Failed to load JSON: Expecting property name&#39;
         r&#39;( enclosed in double quotes)?: line 1&#39;),
        json_format.Parse, text, message)
    text = &#39;{&#34;boolMap&#34;: {&#34;null&#34;: 1}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse boolMap field: Expected &#34;true&#34; or &#34;false&#34;, not null.&#39;,
        json_format.Parse, text, message)
    if sys.version_info &lt; (2, 7):
      return
    text = r&#39;{&#34;stringMap&#34;: {&#34;a&#34;: 3, &#34;\u0061&#34;: 2}}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to load JSON: duplicate key a&#39;,
        json_format.Parse, text, message)
    text = r&#39;{&#34;stringMap&#34;: 0}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse stringMap field: Map field string_map must be &#39;
        &#39;in a dict which is 0.&#39;,
        json_format.Parse, text, message)

  def testInvalidTimestamp(self):
    message = json_format_proto3_pb2.TestTimestamp()
    text = &#39;{&#34;value&#34;: &#34;10000-01-01T00:00:00.00Z&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse value field: &#39;
        &#39;time data \&#39;10000-01-01T00:00:00\&#39; does not match&#39;
        &#39; format \&#39;%Y-%m-%dT%H:%M:%S\&#39;.&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;value&#34;: &#34;1970-01-01T00:00:00.0123456789012Z&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;nanos 0123456789012 more than 9 fractional digits.&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;value&#34;: &#34;1972-01-01T01:00:00.01+08&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        (r&#39;Invalid timezone offset value: \+08.&#39;),
        json_format.Parse, text, message)
    # Time smaller than minimum time.
    text = &#39;{&#34;value&#34;: &#34;0000-01-01T00:00:00Z&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse value field: year (0 )?is out of range.&#39;,
        json_format.Parse, text, message)
    # Time bigger than maxinum time.
    message.value.seconds = 253402300800
    self.assertRaisesRegexp(
        OverflowError,
        &#39;date value out of range&#39;,
        json_format.MessageToJson, message)

  def testInvalidOneof(self):
    message = json_format_proto3_pb2.TestOneof()
    text = &#39;{&#34;oneofInt32Value&#34;: 1, &#34;oneofStringValue&#34;: &#34;2&#34;}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Message type &#34;proto3.TestOneof&#34;&#39;
        &#39; should not have multiple &#34;oneof_value&#34; oneof fields.&#39;,
        json_format.Parse, text, message)

  def testInvalidListValue(self):
    message = json_format_proto3_pb2.TestListValue()
    text = &#39;{&#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        r&#39;Failed to parse value field: ListValue must be in \[\] which is 1234&#39;,
        json_format.Parse, text, message)

  def testInvalidStruct(self):
    message = json_format_proto3_pb2.TestStruct()
    text = &#39;{&#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;Failed to parse value field: Struct must be in a dict which is 1234&#39;,
        json_format.Parse, text, message)

  def testInvalidAny(self):
    message = any_pb2.Any()
    text = &#39;{&#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Int32Value&#34;}&#39;
    self.assertRaisesRegexp(
        KeyError,
        &#39;value&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        json_format.ParseError,
        &#39;@type is missing when parsing any message.&#39;,
        json_format.Parse, text, message)
    text = &#39;{&#34;@type&#34;: &#34;type.googleapis.com/MessageNotExist&#34;, &#34;value&#34;: 1234}&#39;
    self.assertRaisesRegexp(
        TypeError,
        &#39;Can not find message descriptor by type_url: &#39;
        &#39;type.googleapis.com/MessageNotExist.&#39;,
        json_format.Parse, text, message)
    # Only last part is to be used: b/25630112
    text = (r&#39;{&#34;@type&#34;: &#34;incorrect.googleapis.com/google.protobuf.Int32Value&#34;,&#39;
            r&#39;&#34;value&#34;: 1234}&#39;)
    json_format.Parse(text, message)

  def testPreservingProtoFieldNames(self):
    message = json_format_proto3_pb2.TestMessage()
    message.int32_value = 12345
    self.assertEqual(&#39;{\n  &#34;int32Value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message))
    self.assertEqual(&#39;{\n  &#34;int32_value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message, False, True))
    # When including_default_value_fields is True.
    message = json_format_proto3_pb2.TestTimestamp()
    self.assertEqual(&#39;{\n  &#34;repeatedValue&#34;: []\n}&#39;,
                     json_format.MessageToJson(message, True, False))
    self.assertEqual(&#39;{\n  &#34;repeated_value&#34;: []\n}&#39;,
                     json_format.MessageToJson(message, True, True))

    # Parsers accept both original proto field names and lowerCamelCase names.
    message = json_format_proto3_pb2.TestMessage()
    json_format.Parse(&#39;{&#34;int32Value&#34;: 54321}&#39;, message)
    self.assertEqual(54321, message.int32_value)
    json_format.Parse(&#39;{&#34;int32_value&#34;: 12345}&#39;, message)
    self.assertEqual(12345, message.int32_value)

  def testIndent(self):
    message = json_format_proto3_pb2.TestMessage()
    message.int32_value = 12345
    self.assertEqual(&#39;{\n&#34;int32Value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message, indent=0))

  def testFormatEnumsAsInts(self):
    message = json_format_proto3_pb2.TestMessage()
    message.enum_value = json_format_proto3_pb2.BAR
    message.repeated_enum_value.append(json_format_proto3_pb2.FOO)
    message.repeated_enum_value.append(json_format_proto3_pb2.BAR)
    self.assertEqual(json.loads(&#39;{\n&#39;
                                &#39;  &#34;enumValue&#34;: 1,\n&#39;
                                &#39;  &#34;repeatedEnumValue&#34;: [0, 1]\n&#39;
                                &#39;}\n&#39;),
                     json.loads(json_format.MessageToJson(
                         message, use_integers_for_enums=True)))

  def testParseDict(self):
    expected = 12345
    js_dict = {&#39;int32Value&#39;: expected}
    message = json_format_proto3_pb2.TestMessage()
    json_format.ParseDict(js_dict, message)
    self.assertEqual(expected, message.int32_value)

  def testParseDictAnyDescriptorPoolMissingType(self):
    # Confirm that ParseDict does not raise ParseError with default pool
    js_dict = {
        &#39;any_value&#39;: {
            &#39;@type&#39;: &#39;type.googleapis.com/proto3.MessageType&#39;,
            &#39;value&#39;: 1234
        }
    }
    json_format.ParseDict(js_dict, any_test_pb2.TestAny())
    # Check ParseDict raises ParseError with empty pool
    js_dict = {
        &#39;any_value&#39;: {
            &#39;@type&#39;: &#39;type.googleapis.com/proto3.MessageType&#39;,
            &#39;value&#39;: 1234
        }
    }
    with self.assertRaises(json_format.ParseError) as cm:
      empty_pool = descriptor_pool.DescriptorPool()
      json_format.ParseDict(js_dict,
                            any_test_pb2.TestAny(),
                            descriptor_pool=empty_pool)
    self.assertEqual(
        str(cm.exception),
        &#39;Failed to parse any_value field: Can not find message descriptor by&#39;
        &#39; type_url: type.googleapis.com/proto3.MessageType..&#39;)

  def testMessageToDict(self):
    message = json_format_proto3_pb2.TestMessage()
    message.int32_value = 12345
    expected = {&#39;int32Value&#39;: 12345}
    self.assertEqual(expected,
                     json_format.MessageToDict(message))

  def testJsonName(self):
    message = json_format_proto3_pb2.TestCustomJsonName()
    message.value = 12345
    self.assertEqual(&#39;{\n  &#34;@value&#34;: 12345\n}&#39;,
                     json_format.MessageToJson(message))
    parsed_message = json_format_proto3_pb2.TestCustomJsonName()
    self.CheckParseBack(message, parsed_message)

  def testSortKeys(self):
    # Testing sort_keys is not perfectly working, as by random luck we could
    # get the output sorted. We just use a selection of names.
    message = json_format_proto3_pb2.TestMessage(bool_value=True,
                                                 int32_value=1,
                                                 int64_value=3,
                                                 uint32_value=4,
                                                 string_value=&#39;bla&#39;)
    self.assertEqual(
        json_format.MessageToJson(message, sort_keys=True),
        # We use json.dumps() instead of a hardcoded string due to differences
        # between Python 2 and Python 3.
        json.dumps({&#39;boolValue&#39;: True, &#39;int32Value&#39;: 1, &#39;int64Value&#39;: &#39;3&#39;,
                    &#39;uint32Value&#39;: 4, &#39;stringValue&#39;: &#39;bla&#39;},
                   indent=2, sort_keys=True))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.internal.json_format_test.JsonFormatBase" href="#google.protobuf.internal.json_format_test.JsonFormatBase">JsonFormatBase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testAllFieldsToJson"><code class="name flex">
<span>def <span class="ident">testAllFieldsToJson</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAllFieldsToJson(self):
  message = json_format_proto3_pb2.TestMessage()
  text = (&#39;{&#34;int32Value&#34;: 20, &#39;
          &#39;&#34;int64Value&#34;: &#34;-20&#34;, &#39;
          &#39;&#34;uint32Value&#34;: 3120987654,&#39;
          &#39;&#34;uint64Value&#34;: &#34;12345678900&#34;,&#39;
          &#39;&#34;floatValue&#34;: &#34;-Infinity&#34;,&#39;
          &#39;&#34;doubleValue&#34;: 3.1415,&#39;
          &#39;&#34;boolValue&#34;: true,&#39;
          &#39;&#34;stringValue&#34;: &#34;foo&#34;,&#39;
          &#39;&#34;bytesValue&#34;: &#34;YmFy&#34;,&#39;
          &#39;&#34;messageValue&#34;: {&#34;value&#34;: 10},&#39;
          &#39;&#34;enumValue&#34;: &#34;BAR&#34;,&#39;
          &#39;&#34;repeatedInt32Value&#34;: [2147483647, -2147483648],&#39;
          &#39;&#34;repeatedInt64Value&#34;: [&#34;9007199254740992&#34;, &#34;-9007199254740992&#34;],&#39;
          &#39;&#34;repeatedUint32Value&#34;: [268435455, 134217727],&#39;
          &#39;&#34;repeatedUint64Value&#34;: [&#34;9007199254740992&#34;, &#34;9007199254740991&#34;],&#39;
          &#39;&#34;repeatedFloatValue&#34;: [0],&#39;
          &#39;&#34;repeatedDoubleValue&#34;: [1e-15, &#34;Infinity&#34;],&#39;
          &#39;&#34;repeatedBoolValue&#34;: [true, false],&#39;
          &#39;&#34;repeatedStringValue&#34;: [&#34;Few symbols!#$,;&#34;, &#34;bar&#34;],&#39;
          &#39;&#34;repeatedBytesValue&#34;: [&#34;Zm9v&#34;, &#34;YmFy&#34;],&#39;
          &#39;&#34;repeatedMessageValue&#34;: [{&#34;value&#34;: 10}, {&#34;value&#34;: 11}],&#39;
          &#39;&#34;repeatedEnumValue&#34;: [&#34;FOO&#34;, &#34;BAR&#34;]&#39;
          &#39;}&#39;)
  self.FillAllFields(message)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message)),
      json.loads(text))
  parsed_message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(text, parsed_message)
  self.assertEqual(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testAlwaysSeriliaze"><code class="name flex">
<span>def <span class="ident">testAlwaysSeriliaze</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAlwaysSeriliaze(self):
  message = json_format_proto3_pb2.TestMessage(
      string_value=&#39;foo&#39;)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(&#39;{&#39;
                 &#39;&#34;repeatedStringValue&#34;: [],&#39;
                 &#39;&#34;stringValue&#34;: &#34;foo&#34;,&#39;
                 &#39;&#34;repeatedBoolValue&#34;: [],&#39;
                 &#39;&#34;repeatedUint32Value&#34;: [],&#39;
                 &#39;&#34;repeatedInt32Value&#34;: [],&#39;
                 &#39;&#34;enumValue&#34;: &#34;FOO&#34;,&#39;
                 &#39;&#34;int32Value&#34;: 0,&#39;
                 &#39;&#34;floatValue&#34;: 0,&#39;
                 &#39;&#34;int64Value&#34;: &#34;0&#34;,&#39;
                 &#39;&#34;uint32Value&#34;: 0,&#39;
                 &#39;&#34;repeatedBytesValue&#34;: [],&#39;
                 &#39;&#34;repeatedUint64Value&#34;: [],&#39;
                 &#39;&#34;repeatedDoubleValue&#34;: [],&#39;
                 &#39;&#34;bytesValue&#34;: &#34;&#34;,&#39;
                 &#39;&#34;boolValue&#34;: false,&#39;
                 &#39;&#34;repeatedEnumValue&#34;: [],&#39;
                 &#39;&#34;uint64Value&#34;: &#34;0&#34;,&#39;
                 &#39;&#34;doubleValue&#34;: 0,&#39;
                 &#39;&#34;repeatedFloatValue&#34;: [],&#39;
                 &#39;&#34;repeatedInt64Value&#34;: [],&#39;
                 &#39;&#34;repeatedMessageValue&#34;: []}&#39;))
  parsed_message = json_format_proto3_pb2.TestMessage()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testAnyMessage"><code class="name flex">
<span>def <span class="ident">testAnyMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAnyMessage(self):
  message = json_format_proto3_pb2.TestAny()
  value1 = json_format_proto3_pb2.MessageType()
  value2 = json_format_proto3_pb2.MessageType()
  value1.value = 1234
  value2.value = 5678
  message.value.Pack(value1)
  message.repeated_value.add().Pack(value1)
  message.repeated_value.add().Pack(value2)
  message.repeated_value.add()
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;repeatedValue&#34;: [ {\n&#39;
          &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
          &#39;    &#34;value&#34;: 1234\n&#39;
          &#39;  }, {\n&#39;
          &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
          &#39;    &#34;value&#34;: 5678\n&#39;
          &#39;  },\n&#39;
          &#39;  {}],\n&#39;
          &#39;  &#34;value&#34;: {\n&#39;
          &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
          &#39;    &#34;value&#34;: 1234\n&#39;
          &#39;  }\n&#39;
          &#39;}\n&#39;))
  parsed_message = json_format_proto3_pb2.TestAny()
  self.CheckParseBack(message, parsed_message)
  # Must print @type first
  test_message = json_format_proto3_pb2.TestMessage(
      bool_value=True,
      int32_value=20,
      int64_value=-20,
      uint32_value=20,
      uint64_value=20,
      double_value=3.14,
      string_value=&#39;foo&#39;)
  message.Clear()
  message.value.Pack(test_message)
  self.assertEqual(
      json_format.MessageToJson(message, False)[0:68],
      &#39;{\n&#39;
      &#39;  &#34;value&#34;: {\n&#39;
      &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.TestMessage&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testAnyMessageDescriptorPoolMissingType"><code class="name flex">
<span>def <span class="ident">testAnyMessageDescriptorPoolMissingType</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testAnyMessageDescriptorPoolMissingType(self):
  packed_message = unittest_pb2.OneString()
  packed_message.data = &#39;string&#39;
  message = any_test_pb2.TestAny()
  message.any_value.Pack(packed_message)
  empty_pool = descriptor_pool.DescriptorPool()
  with self.assertRaises(TypeError) as cm:
    json_format.MessageToJson(message, True, descriptor_pool=empty_pool)
  self.assertEqual(
      &#39;Can not find message descriptor by type_url:&#39;
      &#39; type.googleapis.com/protobuf_unittest.OneString.&#39;,
      str(cm.exception))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testDuplicateField"><code class="name flex">
<span>def <span class="ident">testDuplicateField</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testDuplicateField(self):
  self.CheckError(&#39;{&#34;int32Value&#34;: 1,\n&#34;int32Value&#34;:2}&#39;,
                  &#39;Failed to load JSON: duplicate key int32Value.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testDurationMessage"><code class="name flex">
<span>def <span class="ident">testDurationMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testDurationMessage(self):
  message = json_format_proto3_pb2.TestDuration()
  message.value.seconds = 1
  message.repeated_value.add().seconds = 0
  message.repeated_value[0].nanos = 10
  message.repeated_value.add().seconds = -1
  message.repeated_value[1].nanos = -1000
  message.repeated_value.add().seconds = 10
  message.repeated_value[2].nanos = 11000000
  message.repeated_value.add().seconds = -315576000000
  message.repeated_value.add().seconds = 315576000000
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(&#39;{&#39;
                 &#39;&#34;value&#34;: &#34;1s&#34;,&#39;
                 &#39;&#34;repeatedValue&#34;: [&#39;
                 &#39;  &#34;0.000000010s&#34;,&#39;
                 &#39;  &#34;-1.000001s&#34;,&#39;
                 &#39;  &#34;10.011s&#34;,&#39;
                 &#39;  &#34;-315576000000s&#34;,&#39;
                 &#39;  &#34;315576000000s&#34;&#39;
                 &#39;]&#39;
                 &#39;}&#39;))
  parsed_message = json_format_proto3_pb2.TestDuration()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testEmptyMessageToJson"><code class="name flex">
<span>def <span class="ident">testEmptyMessageToJson</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testEmptyMessageToJson(self):
  message = json_format_proto3_pb2.TestMessage()
  self.assertEqual(json_format.MessageToJson(message),
                   &#39;{}&#39;)
  parsed_message = json_format_proto3_pb2.TestMessage()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionErrors"><code class="name flex">
<span>def <span class="ident">testExtensionErrors</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionErrors(self):
  self.CheckError(&#39;{&#34;[extensionField]&#34;: {}}&#39;,
                  &#39;Message type proto3.TestMessage does not have extensions&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationDictMatchesProto3Spec"><code class="name flex">
<span>def <span class="ident">testExtensionSerializationDictMatchesProto3Spec</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>See go/proto3-json-spec for spec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionSerializationDictMatchesProto3Spec(self):
  &#34;&#34;&#34;See go/proto3-json-spec for spec.
  &#34;&#34;&#34;
  message = unittest_mset_pb2.TestMessageSetContainer()
  ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
  ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
  message.message_set.Extensions[ext1].i = 23
  message.message_set.Extensions[ext2].str = &#39;foo&#39;
  message_dict = json_format.MessageToDict(
      message
  )
  golden_dict = {
      &#39;messageSet&#39;: {
          &#39;[protobuf_unittest.&#39;
          &#39;TestMessageSetExtension1.messageSetExtension]&#39;: {
              &#39;i&#39;: 23,
          },
          &#39;[protobuf_unittest.&#39;
          &#39;TestMessageSetExtension2.messageSetExtension]&#39;: {
              &#39;str&#39;: u&#39;foo&#39;,
          },
      },
  }
  self.assertEqual(golden_dict, message_dict)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationDictMatchesProto3SpecMore"><code class="name flex">
<span>def <span class="ident">testExtensionSerializationDictMatchesProto3SpecMore</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>See go/proto3-json-spec for spec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionSerializationDictMatchesProto3SpecMore(self):
  &#34;&#34;&#34;See go/proto3-json-spec for spec.
  &#34;&#34;&#34;
  message = json_format_pb2.TestMessageWithExtension()
  ext = json_format_pb2.TestExtension.ext
  message.Extensions[ext].value = &#39;stuff&#39;
  message_dict = json_format.MessageToDict(
      message
  )
  expected_dict = {
      &#39;[protobuf_unittest.TestExtension.ext]&#39;: {
          &#39;value&#39;: u&#39;stuff&#39;,
      },
  }
  self.assertEqual(expected_dict, message_dict)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationJsonMatchesProto3Spec"><code class="name flex">
<span>def <span class="ident">testExtensionSerializationJsonMatchesProto3Spec</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>See go/proto3-json-spec for spec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionSerializationJsonMatchesProto3Spec(self):
  &#34;&#34;&#34;See go/proto3-json-spec for spec.
  &#34;&#34;&#34;
  message = unittest_mset_pb2.TestMessageSetContainer()
  ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
  ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
  message.message_set.Extensions[ext1].i = 23
  message.message_set.Extensions[ext2].str = &#39;foo&#39;
  message_text = json_format.MessageToJson(
      message
  )
  ext1_text = (&#39;protobuf_unittest.TestMessageSetExtension1.&#39;
               &#39;messageSetExtension&#39;)
  ext2_text = (&#39;protobuf_unittest.TestMessageSetExtension2.&#39;
               &#39;messageSetExtension&#39;)
  golden_text = (&#39;{&#34;messageSet&#34;: {&#39;
                 &#39;    &#34;[%s]&#34;: {&#39;
                 &#39;        &#34;i&#34;: 23&#39;
                 &#39;    },&#39;
                 &#39;    &#34;[%s]&#34;: {&#39;
                 &#39;        &#34;str&#34;: &#34;foo&#34;&#39;
                 &#39;    }&#39;
                 &#39;}}&#39;) % (ext1_text, ext2_text)
  self.assertEqual(json.loads(golden_text), json.loads(message_text))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToDictAndBack"><code class="name flex">
<span>def <span class="ident">testExtensionToDictAndBack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionToDictAndBack(self):
  message = unittest_mset_pb2.TestMessageSetContainer()
  ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
  ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
  message.message_set.Extensions[ext1].i = 23
  message.message_set.Extensions[ext2].str = &#39;foo&#39;
  message_dict = json_format.MessageToDict(
      message
  )
  parsed_message = unittest_mset_pb2.TestMessageSetContainer()
  json_format.ParseDict(message_dict, parsed_message)
  self.assertEqual(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToDictAndBackWithScalar"><code class="name flex">
<span>def <span class="ident">testExtensionToDictAndBackWithScalar</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionToDictAndBackWithScalar(self):
  message = unittest_pb2.TestAllExtensions()
  ext1 = unittest_pb2.TestNestedExtension.test
  message.Extensions[ext1] = &#39;data&#39;
  message_dict = json_format.MessageToDict(
      message
  )
  parsed_message = unittest_pb2.TestAllExtensions()
  json_format.ParseDict(message_dict, parsed_message)
  self.assertEqual(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToJsonAndBack"><code class="name flex">
<span>def <span class="ident">testExtensionToJsonAndBack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testExtensionToJsonAndBack(self):
  message = unittest_mset_pb2.TestMessageSetContainer()
  ext1 = unittest_mset_pb2.TestMessageSetExtension1.message_set_extension
  ext2 = unittest_mset_pb2.TestMessageSetExtension2.message_set_extension
  message.message_set.Extensions[ext1].i = 23
  message.message_set.Extensions[ext2].str = &#39;foo&#39;
  message_text = json_format.MessageToJson(
      message
  )
  parsed_message = unittest_mset_pb2.TestMessageSetContainer()
  json_format.Parse(message_text, parsed_message)
  self.assertEqual(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testFieldMaskMessage"><code class="name flex">
<span>def <span class="ident">testFieldMaskMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFieldMaskMessage(self):
  message = json_format_proto3_pb2.TestFieldMask()
  message.value.paths.append(&#39;foo.bar&#39;)
  message.value.paths.append(&#39;bar&#39;)
  self.assertEqual(
      json_format.MessageToJson(message, True),
      &#39;{\n&#39;
      &#39;  &#34;value&#34;: &#34;foo.bar,bar&#34;\n&#39;
      &#39;}&#39;)
  parsed_message = json_format_proto3_pb2.TestFieldMask()
  self.CheckParseBack(message, parsed_message)

  message.value.Clear()
  self.assertEqual(
      json_format.MessageToJson(message, True),
      &#39;{\n&#39;
      &#39;  &#34;value&#34;: &#34;&#34;\n&#39;
      &#39;}&#39;)
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testFloatPrecision"><code class="name flex">
<span>def <span class="ident">testFloatPrecision</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFloatPrecision(self):
  message = json_format_proto3_pb2.TestMessage()
  message.float_value = 1.123456789
  # Set to 7 valid digits.
  text = &#39;{\n  &#34;floatValue&#34;: 1.123457\n}&#39;
  self.assertEqual(
      json_format.MessageToJson(message, float_precision=7), text)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testFormatEnumsAsInts"><code class="name flex">
<span>def <span class="ident">testFormatEnumsAsInts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testFormatEnumsAsInts(self):
  message = json_format_proto3_pb2.TestMessage()
  message.enum_value = json_format_proto3_pb2.BAR
  message.repeated_enum_value.append(json_format_proto3_pb2.FOO)
  message.repeated_enum_value.append(json_format_proto3_pb2.BAR)
  self.assertEqual(json.loads(&#39;{\n&#39;
                              &#39;  &#34;enumValue&#34;: 1,\n&#39;
                              &#39;  &#34;repeatedEnumValue&#34;: [0, 1]\n&#39;
                              &#39;}\n&#39;),
                   json.loads(json_format.MessageToJson(
                       message, use_integers_for_enums=True)))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testIgnoreUnknownField"><code class="name flex">
<span>def <span class="ident">testIgnoreUnknownField</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testIgnoreUnknownField(self):
  text = &#39;{&#34;unknownName&#34;: 1}&#39;
  parsed_message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(text, parsed_message, ignore_unknown_fields=True)
  text = (&#39;{\n&#39;
          &#39;  &#34;repeatedValue&#34;: [ {\n&#39;
          &#39;    &#34;@type&#34;: &#34;type.googleapis.com/proto3.MessageType&#34;,\n&#39;
          &#39;    &#34;unknownName&#34;: 1\n&#39;
          &#39;  }]\n&#39;
          &#39;}\n&#39;)
  parsed_message = json_format_proto3_pb2.TestAny()
  json_format.Parse(text, parsed_message, ignore_unknown_fields=True)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testIndent"><code class="name flex">
<span>def <span class="ident">testIndent</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testIndent(self):
  message = json_format_proto3_pb2.TestMessage()
  message.int32_value = 12345
  self.assertEqual(&#39;{\n&#34;int32Value&#34;: 12345\n}&#39;,
                   json_format.MessageToJson(message, indent=0))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testIntegersRepresentedAsFloat"><code class="name flex">
<span>def <span class="ident">testIntegersRepresentedAsFloat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testIntegersRepresentedAsFloat(self):
  message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(&#39;{&#34;int32Value&#34;: -2.147483648e9}&#39;, message)
  self.assertEqual(message.int32_value, -2147483648)
  json_format.Parse(&#39;{&#34;int32Value&#34;: 1e5}&#39;, message)
  self.assertEqual(message.int32_value, 100000)
  json_format.Parse(&#39;{&#34;int32Value&#34;: 1.0}&#39;, message)
  self.assertEqual(message.int32_value, 1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidAny"><code class="name flex">
<span>def <span class="ident">testInvalidAny</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidAny(self):
  message = any_pb2.Any()
  text = &#39;{&#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Int32Value&#34;}&#39;
  self.assertRaisesRegexp(
      KeyError,
      &#39;value&#39;,
      json_format.Parse, text, message)
  text = &#39;{&#34;value&#34;: 1234}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;@type is missing when parsing any message.&#39;,
      json_format.Parse, text, message)
  text = &#39;{&#34;@type&#34;: &#34;type.googleapis.com/MessageNotExist&#34;, &#34;value&#34;: 1234}&#39;
  self.assertRaisesRegexp(
      TypeError,
      &#39;Can not find message descriptor by type_url: &#39;
      &#39;type.googleapis.com/MessageNotExist.&#39;,
      json_format.Parse, text, message)
  # Only last part is to be used: b/25630112
  text = (r&#39;{&#34;@type&#34;: &#34;incorrect.googleapis.com/google.protobuf.Int32Value&#34;,&#39;
          r&#39;&#34;value&#34;: 1234}&#39;)
  json_format.Parse(text, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidBoolValue"><code class="name flex">
<span>def <span class="ident">testInvalidBoolValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidBoolValue(self):
  self.CheckError(&#39;{&#34;boolValue&#34;: 1}&#39;,
                  &#39;Failed to parse boolValue field: &#39;
                  &#39;Expected true or false without quotes.&#39;)
  self.CheckError(&#39;{&#34;boolValue&#34;: &#34;true&#34;}&#39;,
                  &#39;Failed to parse boolValue field: &#39;
                  &#39;Expected true or false without quotes.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidBytesValue"><code class="name flex">
<span>def <span class="ident">testInvalidBytesValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidBytesValue(self):
  self.CheckError(&#39;{&#34;bytesValue&#34;: &#34;AQI&#34;}&#39;,
                  &#39;Failed to parse bytesValue field: Incorrect padding.&#39;)
  self.CheckError(&#39;{&#34;bytesValue&#34;: &#34;AQI*&#34;}&#39;,
                  &#39;Failed to parse bytesValue field: Incorrect padding.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidFloatValue"><code class="name flex">
<span>def <span class="ident">testInvalidFloatValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidFloatValue(self):
  self.CheckError(&#39;{&#34;floatValue&#34;: &#34;nan&#34;}&#39;,
                  &#39;Failed to parse floatValue field: Couldn\&#39;t &#39;
                  &#39;parse float &#34;nan&#34;, use &#34;NaN&#34; instead.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidIntegerValue"><code class="name flex">
<span>def <span class="ident">testInvalidIntegerValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidIntegerValue(self):
  message = json_format_proto3_pb2.TestMessage()
  text = &#39;{&#34;int32Value&#34;: 0x12345}&#39;
  self.assertRaises(json_format.ParseError,
                    json_format.Parse, text, message)
  self.CheckError(&#39;{&#34;int32Value&#34;: 1.5}&#39;,
                  &#39;Failed to parse int32Value field: &#39;
                  &#39;Couldn\&#39;t parse integer: 1.5.&#39;)
  self.CheckError(&#39;{&#34;int32Value&#34;: 012345}&#39;,
                  (r&#39;Failed to load JSON: Expecting \&#39;?,\&#39;? delimiter: &#39;
                   r&#39;line 1.&#39;))
  self.CheckError(&#39;{&#34;int32Value&#34;: &#34; 1 &#34;}&#39;,
                  &#39;Failed to parse int32Value field: &#39;
                  &#39;Couldn\&#39;t parse integer: &#34; 1 &#34;.&#39;)
  self.CheckError(&#39;{&#34;int32Value&#34;: &#34;1 &#34;}&#39;,
                  &#39;Failed to parse int32Value field: &#39;
                  &#39;Couldn\&#39;t parse integer: &#34;1 &#34;.&#39;)
  self.CheckError(&#39;{&#34;int32Value&#34;: 12345678901234567890}&#39;,
                  &#39;Failed to parse int32Value field: Value out of range: &#39;
                  &#39;12345678901234567890.&#39;)
  self.CheckError(&#39;{&#34;uint32Value&#34;: -1}&#39;,
                  &#39;Failed to parse uint32Value field: &#39;
                  &#39;Value out of range: -1.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidListValue"><code class="name flex">
<span>def <span class="ident">testInvalidListValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidListValue(self):
  message = json_format_proto3_pb2.TestListValue()
  text = &#39;{&#34;value&#34;: 1234}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      r&#39;Failed to parse value field: ListValue must be in \[\] which is 1234&#39;,
      json_format.Parse, text, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidMap"><code class="name flex">
<span>def <span class="ident">testInvalidMap</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidMap(self):
  message = json_format_proto3_pb2.TestMap()
  text = &#39;{&#34;int32Map&#34;: {&#34;null&#34;: 2, &#34;2&#34;: 3}}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse int32Map field: invalid literal&#39;,
      json_format.Parse, text, message)
  text = &#39;{&#34;int32Map&#34;: {1: 2, &#34;2&#34;: 3}}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      (r&#39;Failed to load JSON: Expecting property name&#39;
       r&#39;( enclosed in double quotes)?: line 1&#39;),
      json_format.Parse, text, message)
  text = &#39;{&#34;boolMap&#34;: {&#34;null&#34;: 1}}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse boolMap field: Expected &#34;true&#34; or &#34;false&#34;, not null.&#39;,
      json_format.Parse, text, message)
  if sys.version_info &lt; (2, 7):
    return
  text = r&#39;{&#34;stringMap&#34;: {&#34;a&#34;: 3, &#34;\u0061&#34;: 2}}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to load JSON: duplicate key a&#39;,
      json_format.Parse, text, message)
  text = r&#39;{&#34;stringMap&#34;: 0}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse stringMap field: Map field string_map must be &#39;
      &#39;in a dict which is 0.&#39;,
      json_format.Parse, text, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidOneof"><code class="name flex">
<span>def <span class="ident">testInvalidOneof</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidOneof(self):
  message = json_format_proto3_pb2.TestOneof()
  text = &#39;{&#34;oneofInt32Value&#34;: 1, &#34;oneofStringValue&#34;: &#34;2&#34;}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Message type &#34;proto3.TestOneof&#34;&#39;
      &#39; should not have multiple &#34;oneof_value&#34; oneof fields.&#39;,
      json_format.Parse, text, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidRepeated"><code class="name flex">
<span>def <span class="ident">testInvalidRepeated</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidRepeated(self):
  self.CheckError(&#39;{&#34;repeatedInt32Value&#34;: 12345}&#39;,
                  (r&#39;Failed to parse repeatedInt32Value field: repeated field&#39;
                   r&#39; repeatedInt32Value must be in \[\] which is 12345.&#39;))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidStruct"><code class="name flex">
<span>def <span class="ident">testInvalidStruct</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidStruct(self):
  message = json_format_proto3_pb2.TestStruct()
  text = &#39;{&#34;value&#34;: 1234}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse value field: Struct must be in a dict which is 1234&#39;,
      json_format.Parse, text, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidTimestamp"><code class="name flex">
<span>def <span class="ident">testInvalidTimestamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testInvalidTimestamp(self):
  message = json_format_proto3_pb2.TestTimestamp()
  text = &#39;{&#34;value&#34;: &#34;10000-01-01T00:00:00.00Z&#34;}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse value field: &#39;
      &#39;time data \&#39;10000-01-01T00:00:00\&#39; does not match&#39;
      &#39; format \&#39;%Y-%m-%dT%H:%M:%S\&#39;.&#39;,
      json_format.Parse, text, message)
  text = &#39;{&#34;value&#34;: &#34;1970-01-01T00:00:00.0123456789012Z&#34;}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;nanos 0123456789012 more than 9 fractional digits.&#39;,
      json_format.Parse, text, message)
  text = &#39;{&#34;value&#34;: &#34;1972-01-01T01:00:00.01+08&#34;}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      (r&#39;Invalid timezone offset value: \+08.&#39;),
      json_format.Parse, text, message)
  # Time smaller than minimum time.
  text = &#39;{&#34;value&#34;: &#34;0000-01-01T00:00:00Z&#34;}&#39;
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse value field: year (0 )?is out of range.&#39;,
      json_format.Parse, text, message)
  # Time bigger than maxinum time.
  message.value.seconds = 253402300800
  self.assertRaisesRegexp(
      OverflowError,
      &#39;date value out of range&#39;,
      json_format.MessageToJson, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testJsonEscapeString"><code class="name flex">
<span>def <span class="ident">testJsonEscapeString</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testJsonEscapeString(self):
  message = json_format_proto3_pb2.TestMessage()
  if sys.version_info[0] &lt; 3:
    message.string_value = &#39;&amp;\n&lt;\&#34;\r&gt;\b\t\f\\\001/\xe2\x80\xa8\xe2\x80\xa9&#39;
  else:
    message.string_value = &#39;&amp;\n&lt;\&#34;\r&gt;\b\t\f\\\001/&#39;
    message.string_value += (b&#39;\xe2\x80\xa8\xe2\x80\xa9&#39;).decode(&#39;utf-8&#39;)
  self.assertEqual(
      json_format.MessageToJson(message),
      &#39;{\n  &#34;stringValue&#34;: &#39;
      &#39;&#34;&amp;\\n&lt;\\\&#34;\\r&gt;\\b\\t\\f\\\\\\u0001/\\u2028\\u2029&#34;\n}&#39;)
  parsed_message = json_format_proto3_pb2.TestMessage()
  self.CheckParseBack(message, parsed_message)
  text = u&#39;{&#34;int32Value&#34;: &#34;\u0031&#34;}&#39;
  json_format.Parse(text, message)
  self.assertEqual(message.int32_value, 1)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testJsonName"><code class="name flex">
<span>def <span class="ident">testJsonName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testJsonName(self):
  message = json_format_proto3_pb2.TestCustomJsonName()
  message.value = 12345
  self.assertEqual(&#39;{\n  &#34;@value&#34;: 12345\n}&#39;,
                   json_format.MessageToJson(message))
  parsed_message = json_format_proto3_pb2.TestCustomJsonName()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testJsonParseDictToAnyDoesNotAlterInput"><code class="name flex">
<span>def <span class="ident">testJsonParseDictToAnyDoesNotAlterInput</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testJsonParseDictToAnyDoesNotAlterInput(self):
  orig_dict = {
      &#39;int32Value&#39;: 20,
      &#39;@type&#39;: &#39;type.googleapis.com/proto3.TestMessage&#39;
  }
  copied_dict = json.loads(json.dumps(orig_dict))
  parsed_message = any_pb2.Any()
  json_format.ParseDict(copied_dict, parsed_message)
  self.assertEqual(copied_dict, orig_dict)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testListValueMessage"><code class="name flex">
<span>def <span class="ident">testListValueMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testListValueMessage(self):
  message = json_format_proto3_pb2.TestListValue()
  message.value.values.add().number_value = 11.1
  message.value.values.add().null_value = 0
  message.value.values.add().bool_value = True
  message.value.values.add().string_value = &#39;hello&#39;
  message.value.values.add().struct_value[&#39;name&#39;] = &#39;Jim&#39;
  message.repeated_value.add().values.add().number_value = 1
  message.repeated_value.add()
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, False)),
      json.loads(
          &#39;{&#34;value&#34;: [11.1, null, true, &#34;hello&#34;, {&#34;name&#34;: &#34;Jim&#34;}]\n,&#39;
          &#39;&#34;repeatedValue&#34;: [[1], []]}&#39;))
  parsed_message = json_format_proto3_pb2.TestListValue()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testMapFields"><code class="name flex">
<span>def <span class="ident">testMapFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMapFields(self):
  message = json_format_proto3_pb2.TestNestedMap()
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(&#39;{&#39;
                 &#39;&#34;boolMap&#34;: {},&#39;
                 &#39;&#34;int32Map&#34;: {},&#39;
                 &#39;&#34;int64Map&#34;: {},&#39;
                 &#39;&#34;uint32Map&#34;: {},&#39;
                 &#39;&#34;uint64Map&#34;: {},&#39;
                 &#39;&#34;stringMap&#34;: {},&#39;
                 &#39;&#34;mapMap&#34;: {}&#39;
                 &#39;}&#39;))
  message.bool_map[True] = 1
  message.bool_map[False] = 2
  message.int32_map[1] = 2
  message.int32_map[2] = 3
  message.int64_map[1] = 2
  message.int64_map[2] = 3
  message.uint32_map[1] = 2
  message.uint32_map[2] = 3
  message.uint64_map[1] = 2
  message.uint64_map[2] = 3
  message.string_map[&#39;1&#39;] = 2
  message.string_map[&#39;null&#39;] = 3
  message.map_map[&#39;1&#39;].bool_map[True] = 3
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, False)),
      json.loads(&#39;{&#39;
                 &#39;&#34;boolMap&#34;: {&#34;false&#34;: 2, &#34;true&#34;: 1},&#39;
                 &#39;&#34;int32Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                 &#39;&#34;int64Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                 &#39;&#34;uint32Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                 &#39;&#34;uint64Map&#34;: {&#34;1&#34;: 2, &#34;2&#34;: 3},&#39;
                 &#39;&#34;stringMap&#34;: {&#34;1&#34;: 2, &#34;null&#34;: 3},&#39;
                 &#39;&#34;mapMap&#34;: {&#34;1&#34;: {&#34;boolMap&#34;: {&#34;true&#34;: 3}}}&#39;
                 &#39;}&#39;))
  parsed_message = json_format_proto3_pb2.TestNestedMap()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testMessageToDict"><code class="name flex">
<span>def <span class="ident">testMessageToDict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testMessageToDict(self):
  message = json_format_proto3_pb2.TestMessage()
  message.int32_value = 12345
  expected = {&#39;int32Value&#39;: 12345}
  self.assertEqual(expected,
                   json_format.MessageToDict(message))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testNanFloat"><code class="name flex">
<span>def <span class="ident">testNanFloat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testNanFloat(self):
  message = json_format_proto3_pb2.TestMessage()
  message.float_value = float(&#39;nan&#39;)
  text = &#39;{\n  &#34;floatValue&#34;: &#34;NaN&#34;\n}&#39;
  self.assertEqual(json_format.MessageToJson(message), text)
  parsed_message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(text, parsed_message)
  self.assertTrue(math.isnan(parsed_message.float_value))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testOneofFields"><code class="name flex">
<span>def <span class="ident">testOneofFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testOneofFields(self):
  message = json_format_proto3_pb2.TestOneof()
  # Always print does not affect oneof fields.
  self.assertEqual(
      json_format.MessageToJson(message, True),
      &#39;{}&#39;)
  message.oneof_int32_value = 0
  self.assertEqual(
      json_format.MessageToJson(message, True),
      &#39;{\n&#39;
      &#39;  &#34;oneofInt32Value&#34;: 0\n&#39;
      &#39;}&#39;)
  parsed_message = json_format_proto3_pb2.TestOneof()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseBadIdentifer"><code class="name flex">
<span>def <span class="ident">testParseBadIdentifer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseBadIdentifer(self):
  self.CheckError(&#39;{int32Value: 1}&#39;,
                  (r&#39;Failed to load JSON: Expecting property name&#39;
                   r&#39;( enclosed in double quotes)?: line 1&#39;))
  self.CheckError(&#39;{&#34;unknownName&#34;: 1}&#39;,
                  &#39;Message type &#34;proto3.TestMessage&#34; has no field named &#39;
                  &#39;&#34;unknownName&#34;.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseDict"><code class="name flex">
<span>def <span class="ident">testParseDict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseDict(self):
  expected = 12345
  js_dict = {&#39;int32Value&#39;: expected}
  message = json_format_proto3_pb2.TestMessage()
  json_format.ParseDict(js_dict, message)
  self.assertEqual(expected, message.int32_value)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseDictAnyDescriptorPoolMissingType"><code class="name flex">
<span>def <span class="ident">testParseDictAnyDescriptorPoolMissingType</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseDictAnyDescriptorPoolMissingType(self):
  # Confirm that ParseDict does not raise ParseError with default pool
  js_dict = {
      &#39;any_value&#39;: {
          &#39;@type&#39;: &#39;type.googleapis.com/proto3.MessageType&#39;,
          &#39;value&#39;: 1234
      }
  }
  json_format.ParseDict(js_dict, any_test_pb2.TestAny())
  # Check ParseDict raises ParseError with empty pool
  js_dict = {
      &#39;any_value&#39;: {
          &#39;@type&#39;: &#39;type.googleapis.com/proto3.MessageType&#39;,
          &#39;value&#39;: 1234
      }
  }
  with self.assertRaises(json_format.ParseError) as cm:
    empty_pool = descriptor_pool.DescriptorPool()
    json_format.ParseDict(js_dict,
                          any_test_pb2.TestAny(),
                          descriptor_pool=empty_pool)
  self.assertEqual(
      str(cm.exception),
      &#39;Failed to parse any_value field: Can not find message descriptor by&#39;
      &#39; type_url: type.googleapis.com/proto3.MessageType..&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseDoubleToFloat"><code class="name flex">
<span>def <span class="ident">testParseDoubleToFloat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseDoubleToFloat(self):
  message = json_format_proto3_pb2.TestMessage()
  text = (&#39;{&#34;repeatedFloatValue&#34;: [3.4028235e+39, 1.4028235e-39]\n}&#39;)
  json_format.Parse(text, message)
  self.assertEqual(message.repeated_float_value[0], float(&#39;inf&#39;))
  self.assertAlmostEqual(message.repeated_float_value[1], 1.4028235e-39)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseEmptyText"><code class="name flex">
<span>def <span class="ident">testParseEmptyText</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseEmptyText(self):
  self.CheckError(&#39;&#39;,
                  r&#39;Failed to load JSON: (Expecting value)|(No JSON).&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseEnumValue"><code class="name flex">
<span>def <span class="ident">testParseEnumValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseEnumValue(self):
  message = json_format_proto3_pb2.TestMessage()
  text = &#39;{&#34;enumValue&#34;: 0}&#39;
  json_format.Parse(text, message)
  text = &#39;{&#34;enumValue&#34;: 1}&#39;
  json_format.Parse(text, message)
  self.CheckError(
      &#39;{&#34;enumValue&#34;: &#34;baz&#34;}&#39;,
      &#39;Failed to parse enumValue field: Invalid enum value baz &#39;
      &#39;for enum type proto3.EnumType.&#39;)
  # Proto3 accepts numeric unknown enums.
  text = &#39;{&#34;enumValue&#34;: 12345}&#39;
  json_format.Parse(text, message)
  # Proto2 does not accept unknown enums.
  message = unittest_pb2.TestAllTypes()
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse optionalNestedEnum field: Invalid enum value 12345 &#39;
      &#39;for enum type protobuf_unittest.TestAllTypes.NestedEnum.&#39;,
      json_format.Parse, &#39;{&#34;optionalNestedEnum&#34;: 12345}&#39;, message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testParseNull"><code class="name flex">
<span>def <span class="ident">testParseNull</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testParseNull(self):
  message = json_format_proto3_pb2.TestMessage()
  parsed_message = json_format_proto3_pb2.TestMessage()
  self.FillAllFields(parsed_message)
  json_format.Parse(&#39;{&#34;int32Value&#34;: null, &#39;
                    &#39;&#34;int64Value&#34;: null, &#39;
                    &#39;&#34;uint32Value&#34;: null,&#39;
                    &#39;&#34;uint64Value&#34;: null,&#39;
                    &#39;&#34;floatValue&#34;: null,&#39;
                    &#39;&#34;doubleValue&#34;: null,&#39;
                    &#39;&#34;boolValue&#34;: null,&#39;
                    &#39;&#34;stringValue&#34;: null,&#39;
                    &#39;&#34;bytesValue&#34;: null,&#39;
                    &#39;&#34;messageValue&#34;: null,&#39;
                    &#39;&#34;enumValue&#34;: null,&#39;
                    &#39;&#34;repeatedInt32Value&#34;: null,&#39;
                    &#39;&#34;repeatedInt64Value&#34;: null,&#39;
                    &#39;&#34;repeatedUint32Value&#34;: null,&#39;
                    &#39;&#34;repeatedUint64Value&#34;: null,&#39;
                    &#39;&#34;repeatedFloatValue&#34;: null,&#39;
                    &#39;&#34;repeatedDoubleValue&#34;: null,&#39;
                    &#39;&#34;repeatedBoolValue&#34;: null,&#39;
                    &#39;&#34;repeatedStringValue&#34;: null,&#39;
                    &#39;&#34;repeatedBytesValue&#34;: null,&#39;
                    &#39;&#34;repeatedMessageValue&#34;: null,&#39;
                    &#39;&#34;repeatedEnumValue&#34;: null&#39;
                    &#39;}&#39;,
                    parsed_message)
  self.assertEqual(message, parsed_message)
  # Null and {} should have different behavior for sub message.
  self.assertFalse(parsed_message.HasField(&#39;message_value&#39;))
  json_format.Parse(&#39;{&#34;messageValue&#34;: {}}&#39;, parsed_message)
  self.assertTrue(parsed_message.HasField(&#39;message_value&#39;))
  # Null is not allowed to be used as an element in repeated field.
  self.assertRaisesRegexp(
      json_format.ParseError,
      &#39;Failed to parse repeatedInt32Value field: &#39;
      &#39;null is not allowed to be used as an element in a repeated field.&#39;,
      json_format.Parse,
      &#39;{&#34;repeatedInt32Value&#34;:[1, null]}&#39;,
      parsed_message)
  self.CheckError(&#39;{&#34;repeatedMessageValue&#34;:[null]}&#39;,
                  &#39;Failed to parse repeatedMessageValue field: null is not&#39;
                  &#39; allowed to be used as an element in a repeated field.&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testPartialMessageToJson"><code class="name flex">
<span>def <span class="ident">testPartialMessageToJson</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPartialMessageToJson(self):
  message = json_format_proto3_pb2.TestMessage(
      string_value=&#39;test&#39;,
      repeated_int32_value=[89, 4])
  self.assertEqual(json.loads(json_format.MessageToJson(message)),
                   json.loads(&#39;{&#34;stringValue&#34;: &#34;test&#34;, &#39;
                              &#39;&#34;repeatedInt32Value&#34;: [89, 4]}&#39;))
  parsed_message = json_format_proto3_pb2.TestMessage()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testPreservingProtoFieldNames"><code class="name flex">
<span>def <span class="ident">testPreservingProtoFieldNames</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testPreservingProtoFieldNames(self):
  message = json_format_proto3_pb2.TestMessage()
  message.int32_value = 12345
  self.assertEqual(&#39;{\n  &#34;int32Value&#34;: 12345\n}&#39;,
                   json_format.MessageToJson(message))
  self.assertEqual(&#39;{\n  &#34;int32_value&#34;: 12345\n}&#39;,
                   json_format.MessageToJson(message, False, True))
  # When including_default_value_fields is True.
  message = json_format_proto3_pb2.TestTimestamp()
  self.assertEqual(&#39;{\n  &#34;repeatedValue&#34;: []\n}&#39;,
                   json_format.MessageToJson(message, True, False))
  self.assertEqual(&#39;{\n  &#34;repeated_value&#34;: []\n}&#39;,
                   json_format.MessageToJson(message, True, True))

  # Parsers accept both original proto field names and lowerCamelCase names.
  message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(&#39;{&#34;int32Value&#34;: 54321}&#39;, message)
  self.assertEqual(54321, message.int32_value)
  json_format.Parse(&#39;{&#34;int32_value&#34;: 12345}&#39;, message)
  self.assertEqual(12345, message.int32_value)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testSortKeys"><code class="name flex">
<span>def <span class="ident">testSortKeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSortKeys(self):
  # Testing sort_keys is not perfectly working, as by random luck we could
  # get the output sorted. We just use a selection of names.
  message = json_format_proto3_pb2.TestMessage(bool_value=True,
                                               int32_value=1,
                                               int64_value=3,
                                               uint32_value=4,
                                               string_value=&#39;bla&#39;)
  self.assertEqual(
      json_format.MessageToJson(message, sort_keys=True),
      # We use json.dumps() instead of a hardcoded string due to differences
      # between Python 2 and Python 3.
      json.dumps({&#39;boolValue&#39;: True, &#39;int32Value&#39;: 1, &#39;int64Value&#39;: &#39;3&#39;,
                  &#39;uint32Value&#39;: 4, &#39;stringValue&#39;: &#39;bla&#39;},
                 indent=2, sort_keys=True))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testStructMessage"><code class="name flex">
<span>def <span class="ident">testStructMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testStructMessage(self):
  message = json_format_proto3_pb2.TestStruct()
  message.value[&#39;name&#39;] = &#39;Jim&#39;
  message.value[&#39;age&#39;] = 10
  message.value[&#39;attend&#39;] = True
  message.value[&#39;email&#39;] = None
  message.value.get_or_create_struct(&#39;address&#39;)[&#39;city&#39;] = &#39;SFO&#39;
  message.value[&#39;address&#39;][&#39;house_number&#39;] = 1024
  message.value.get_or_create_struct(&#39;empty_struct&#39;)
  message.value.get_or_create_list(&#39;empty_list&#39;)
  struct_list = message.value.get_or_create_list(&#39;list&#39;)
  struct_list.extend([6, &#39;seven&#39;, True, False, None])
  struct_list.add_struct()[&#39;subkey2&#39;] = 9
  message.repeated_value.add()[&#39;age&#39;] = 11
  message.repeated_value.add()
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, False)),
      json.loads(
          &#39;{&#39;
          &#39;  &#34;value&#34;: {&#39;
          &#39;    &#34;address&#34;: {&#39;
          &#39;      &#34;city&#34;: &#34;SFO&#34;, &#39;
          &#39;      &#34;house_number&#34;: 1024&#39;
          &#39;    }, &#39;
          &#39;    &#34;empty_struct&#34;: {}, &#39;
          &#39;    &#34;empty_list&#34;: [], &#39;
          &#39;    &#34;age&#34;: 10, &#39;
          &#39;    &#34;name&#34;: &#34;Jim&#34;, &#39;
          &#39;    &#34;attend&#34;: true, &#39;
          &#39;    &#34;email&#34;: null, &#39;
          &#39;    &#34;list&#34;: [6, &#34;seven&#34;, true, false, null, {&#34;subkey2&#34;: 9}]&#39;
          &#39;  },&#39;
          &#39;  &#34;repeatedValue&#34;: [{&#34;age&#34;: 11}, {}]&#39;
          &#39;}&#39;))
  parsed_message = json_format_proto3_pb2.TestStruct()
  self.CheckParseBack(message, parsed_message)
  # check for regression; this used to raise
  parsed_message.value[&#39;empty_struct&#39;]
  parsed_message.value[&#39;empty_list&#39;]</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testSurrogates"><code class="name flex">
<span>def <span class="ident">testSurrogates</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testSurrogates(self):
  # Test correct surrogate handling.
  message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(&#39;{&#34;stringValue&#34;: &#34;\\uD83D\\uDE01&#34;}&#39;, message)
  self.assertEqual(message.string_value,
                   b&#39;\xF0\x9F\x98\x81&#39;.decode(&#39;utf-8&#39;, &#39;strict&#39;))

  # Error case: unpaired high surrogate.
  self.CheckError(
      &#39;{&#34;stringValue&#34;: &#34;\\uD83D&#34;}&#39;,
      r&#39;Invalid \\uXXXX escape|Unpaired.*surrogate&#39;)

  # Unpaired low surrogate.
  self.CheckError(
      &#39;{&#34;stringValue&#34;: &#34;\\uDE01&#34;}&#39;,
      r&#39;Invalid \\uXXXX escape|Unpaired.*surrogate&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testTimestampMessage"><code class="name flex">
<span>def <span class="ident">testTimestampMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testTimestampMessage(self):
  message = json_format_proto3_pb2.TestTimestamp()
  message.value.seconds = 0
  message.value.nanos = 0
  message.repeated_value.add().seconds = 20
  message.repeated_value[0].nanos = 1
  message.repeated_value.add().seconds = 0
  message.repeated_value[1].nanos = 10000
  message.repeated_value.add().seconds = 100000000
  message.repeated_value[2].nanos = 0
  # Maximum time
  message.repeated_value.add().seconds = 253402300799
  message.repeated_value[3].nanos = 999999999
  # Minimum time
  message.repeated_value.add().seconds = -62135596800
  message.repeated_value[4].nanos = 0
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(&#39;{&#39;
                 &#39;&#34;value&#34;: &#34;1970-01-01T00:00:00Z&#34;,&#39;
                 &#39;&#34;repeatedValue&#34;: [&#39;
                 &#39;  &#34;1970-01-01T00:00:20.000000001Z&#34;,&#39;
                 &#39;  &#34;1970-01-01T00:00:00.000010Z&#34;,&#39;
                 &#39;  &#34;1973-03-03T09:46:40Z&#34;,&#39;
                 &#39;  &#34;9999-12-31T23:59:59.999999999Z&#34;,&#39;
                 &#39;  &#34;0001-01-01T00:00:00Z&#34;&#39;
                 &#39;]&#39;
                 &#39;}&#39;))
  parsed_message = json_format_proto3_pb2.TestTimestamp()
  self.CheckParseBack(message, parsed_message)
  text = (r&#39;{&#34;value&#34;: &#34;1970-01-01T00:00:00.01+08:00&#34;,&#39;
          r&#39;&#34;repeatedValue&#34;:[&#39;
          r&#39;  &#34;1970-01-01T00:00:00.01+08:30&#34;,&#39;
          r&#39;  &#34;1970-01-01T00:00:00.01-01:23&#34;]}&#39;)
  json_format.Parse(text, parsed_message)
  self.assertEqual(parsed_message.value.seconds, -8 * 3600)
  self.assertEqual(parsed_message.value.nanos, 10000000)
  self.assertEqual(parsed_message.repeated_value[0].seconds, -8.5 * 3600)
  self.assertEqual(parsed_message.repeated_value[1].seconds, 3600 + 23 * 60)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testUnknownEnumToJsonAndBack"><code class="name flex">
<span>def <span class="ident">testUnknownEnumToJsonAndBack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testUnknownEnumToJsonAndBack(self):
  text = &#39;{\n  &#34;enumValue&#34;: 999\n}&#39;
  message = json_format_proto3_pb2.TestMessage()
  message.enum_value = 999
  self.assertEqual(json_format.MessageToJson(message),
                   text)
  parsed_message = json_format_proto3_pb2.TestMessage()
  json_format.Parse(text, parsed_message)
  self.assertEqual(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testValueMessage"><code class="name flex">
<span>def <span class="ident">testValueMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testValueMessage(self):
  message = json_format_proto3_pb2.TestValue()
  message.value.string_value = &#39;hello&#39;
  message.repeated_value.add().number_value = 11.1
  message.repeated_value.add().bool_value = False
  message.repeated_value.add().null_value = 0
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, False)),
      json.loads(
          &#39;{&#39;
          &#39;  &#34;value&#34;: &#34;hello&#34;,&#39;
          &#39;  &#34;repeatedValue&#34;: [11.1, false, null]&#39;
          &#39;}&#39;))
  parsed_message = json_format_proto3_pb2.TestValue()
  self.CheckParseBack(message, parsed_message)
  # Can&#39;t parse back if the Value message is not set.
  message.repeated_value.add()
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, False)),
      json.loads(
          &#39;{&#39;
          &#39;  &#34;value&#34;: &#34;hello&#34;,&#39;
          &#39;  &#34;repeatedValue&#34;: [11.1, false, null, null]&#39;
          &#39;}&#39;))
  message.Clear()
  json_format.Parse(&#39;{&#34;value&#34;: null}&#39;, message)
  self.assertEqual(message.value.WhichOneof(&#39;kind&#39;), &#39;null_value&#39;)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testWellKnownInAnyMessage"><code class="name flex">
<span>def <span class="ident">testWellKnownInAnyMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testWellKnownInAnyMessage(self):
  message = any_pb2.Any()
  int32_value = wrappers_pb2.Int32Value()
  int32_value.value = 1234
  message.Pack(int32_value)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;@type&#34;: \&#34;type.googleapis.com/google.protobuf.Int32Value\&#34;,\n&#39;
          &#39;  &#34;value&#34;: 1234\n&#39;
          &#39;}\n&#39;))
  parsed_message = any_pb2.Any()
  self.CheckParseBack(message, parsed_message)

  timestamp = timestamp_pb2.Timestamp()
  message.Pack(timestamp)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Timestamp&#34;,\n&#39;
          &#39;  &#34;value&#34;: &#34;1970-01-01T00:00:00Z&#34;\n&#39;
          &#39;}\n&#39;))
  self.CheckParseBack(message, parsed_message)

  duration = duration_pb2.Duration()
  duration.seconds = 1
  message.Pack(duration)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Duration&#34;,\n&#39;
          &#39;  &#34;value&#34;: &#34;1s&#34;\n&#39;
          &#39;}\n&#39;))
  self.CheckParseBack(message, parsed_message)

  field_mask = field_mask_pb2.FieldMask()
  field_mask.paths.append(&#39;foo.bar&#39;)
  field_mask.paths.append(&#39;bar&#39;)
  message.Pack(field_mask)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.FieldMask&#34;,\n&#39;
          &#39;  &#34;value&#34;: &#34;foo.bar,bar&#34;\n&#39;
          &#39;}\n&#39;))
  self.CheckParseBack(message, parsed_message)

  struct_message = struct_pb2.Struct()
  struct_message[&#39;name&#39;] = &#39;Jim&#39;
  message.Pack(struct_message)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Struct&#34;,\n&#39;
          &#39;  &#34;value&#34;: {&#34;name&#34;: &#34;Jim&#34;}\n&#39;
          &#39;}\n&#39;))
  self.CheckParseBack(message, parsed_message)

  nested_any = any_pb2.Any()
  int32_value.value = 5678
  nested_any.Pack(int32_value)
  message.Pack(nested_any)
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(
          &#39;{\n&#39;
          &#39;  &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Any&#34;,\n&#39;
          &#39;  &#34;value&#34;: {\n&#39;
          &#39;    &#34;@type&#34;: &#34;type.googleapis.com/google.protobuf.Int32Value&#34;,\n&#39;
          &#39;    &#34;value&#34;: 5678\n&#39;
          &#39;  }\n&#39;
          &#39;}\n&#39;))
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.json_format_test.JsonFormatTest.testWrapperMessage"><code class="name flex">
<span>def <span class="ident">testWrapperMessage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testWrapperMessage(self):
  message = json_format_proto3_pb2.TestWrapper()
  message.bool_value.value = False
  message.int32_value.value = 0
  message.string_value.value = &#39;&#39;
  message.bytes_value.value = b&#39;&#39;
  message.repeated_bool_value.add().value = True
  message.repeated_bool_value.add().value = False
  message.repeated_int32_value.add()
  self.assertEqual(
      json.loads(json_format.MessageToJson(message, True)),
      json.loads(&#39;{\n&#39;
                 &#39;  &#34;int32Value&#34;: 0,&#39;
                 &#39;  &#34;boolValue&#34;: false,&#39;
                 &#39;  &#34;stringValue&#34;: &#34;&#34;,&#39;
                 &#39;  &#34;bytesValue&#34;: &#34;&#34;,&#39;
                 &#39;  &#34;repeatedBoolValue&#34;: [true, false],&#39;
                 &#39;  &#34;repeatedInt32Value&#34;: [0],&#39;
                 &#39;  &#34;repeatedUint32Value&#34;: [],&#39;
                 &#39;  &#34;repeatedFloatValue&#34;: [],&#39;
                 &#39;  &#34;repeatedDoubleValue&#34;: [],&#39;
                 &#39;  &#34;repeatedBytesValue&#34;: [],&#39;
                 &#39;  &#34;repeatedInt64Value&#34;: [],&#39;
                 &#39;  &#34;repeatedUint64Value&#34;: [],&#39;
                 &#39;  &#34;repeatedStringValue&#34;: []&#39;
                 &#39;}&#39;))
  parsed_message = json_format_proto3_pb2.TestWrapper()
  self.CheckParseBack(message, parsed_message)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.protobuf.internal" href="index.html">google.protobuf.internal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.protobuf.internal.json_format_test.JsonFormatBase" href="#google.protobuf.internal.json_format_test.JsonFormatBase">JsonFormatBase</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatBase.CheckError" href="#google.protobuf.internal.json_format_test.JsonFormatBase.CheckError">CheckError</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatBase.CheckParseBack" href="#google.protobuf.internal.json_format_test.JsonFormatBase.CheckParseBack">CheckParseBack</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatBase.FillAllFields" href="#google.protobuf.internal.json_format_test.JsonFormatBase.FillAllFields">FillAllFields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest" href="#google.protobuf.internal.json_format_test.JsonFormatTest">JsonFormatTest</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testAllFieldsToJson" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testAllFieldsToJson">testAllFieldsToJson</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testAlwaysSeriliaze" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testAlwaysSeriliaze">testAlwaysSeriliaze</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testAnyMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testAnyMessage">testAnyMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testAnyMessageDescriptorPoolMissingType" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testAnyMessageDescriptorPoolMissingType">testAnyMessageDescriptorPoolMissingType</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testDuplicateField" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testDuplicateField">testDuplicateField</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testDurationMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testDurationMessage">testDurationMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testEmptyMessageToJson" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testEmptyMessageToJson">testEmptyMessageToJson</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionErrors" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionErrors">testExtensionErrors</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationDictMatchesProto3Spec" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationDictMatchesProto3Spec">testExtensionSerializationDictMatchesProto3Spec</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationDictMatchesProto3SpecMore" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationDictMatchesProto3SpecMore">testExtensionSerializationDictMatchesProto3SpecMore</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationJsonMatchesProto3Spec" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionSerializationJsonMatchesProto3Spec">testExtensionSerializationJsonMatchesProto3Spec</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToDictAndBack" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToDictAndBack">testExtensionToDictAndBack</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToDictAndBackWithScalar" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToDictAndBackWithScalar">testExtensionToDictAndBackWithScalar</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToJsonAndBack" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testExtensionToJsonAndBack">testExtensionToJsonAndBack</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testFieldMaskMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testFieldMaskMessage">testFieldMaskMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testFloatPrecision" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testFloatPrecision">testFloatPrecision</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testFormatEnumsAsInts" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testFormatEnumsAsInts">testFormatEnumsAsInts</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testIgnoreUnknownField" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testIgnoreUnknownField">testIgnoreUnknownField</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testIndent" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testIndent">testIndent</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testIntegersRepresentedAsFloat" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testIntegersRepresentedAsFloat">testIntegersRepresentedAsFloat</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidAny" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidAny">testInvalidAny</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidBoolValue" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidBoolValue">testInvalidBoolValue</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidBytesValue" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidBytesValue">testInvalidBytesValue</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidFloatValue" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidFloatValue">testInvalidFloatValue</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidIntegerValue" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidIntegerValue">testInvalidIntegerValue</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidListValue" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidListValue">testInvalidListValue</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidMap" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidMap">testInvalidMap</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidOneof" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidOneof">testInvalidOneof</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidRepeated" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidRepeated">testInvalidRepeated</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidStruct" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidStruct">testInvalidStruct</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidTimestamp" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testInvalidTimestamp">testInvalidTimestamp</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testJsonEscapeString" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testJsonEscapeString">testJsonEscapeString</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testJsonName" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testJsonName">testJsonName</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testJsonParseDictToAnyDoesNotAlterInput" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testJsonParseDictToAnyDoesNotAlterInput">testJsonParseDictToAnyDoesNotAlterInput</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testListValueMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testListValueMessage">testListValueMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testMapFields" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testMapFields">testMapFields</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testMessageToDict" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testMessageToDict">testMessageToDict</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testNanFloat" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testNanFloat">testNanFloat</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testOneofFields" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testOneofFields">testOneofFields</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseBadIdentifer" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseBadIdentifer">testParseBadIdentifer</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseDict" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseDict">testParseDict</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseDictAnyDescriptorPoolMissingType" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseDictAnyDescriptorPoolMissingType">testParseDictAnyDescriptorPoolMissingType</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseDoubleToFloat" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseDoubleToFloat">testParseDoubleToFloat</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseEmptyText" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseEmptyText">testParseEmptyText</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseEnumValue" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseEnumValue">testParseEnumValue</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testParseNull" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testParseNull">testParseNull</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testPartialMessageToJson" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testPartialMessageToJson">testPartialMessageToJson</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testPreservingProtoFieldNames" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testPreservingProtoFieldNames">testPreservingProtoFieldNames</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testSortKeys" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testSortKeys">testSortKeys</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testStructMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testStructMessage">testStructMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testSurrogates" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testSurrogates">testSurrogates</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testTimestampMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testTimestampMessage">testTimestampMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testUnknownEnumToJsonAndBack" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testUnknownEnumToJsonAndBack">testUnknownEnumToJsonAndBack</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testValueMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testValueMessage">testValueMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testWellKnownInAnyMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testWellKnownInAnyMessage">testWellKnownInAnyMessage</a></code></li>
<li><code><a title="google.protobuf.internal.json_format_test.JsonFormatTest.testWrapperMessage" href="#google.protobuf.internal.json_format_test.JsonFormatTest.testWrapperMessage">testWrapperMessage</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>