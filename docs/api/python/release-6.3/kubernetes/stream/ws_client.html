<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>kubernetes.stream.ws_client API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kubernetes.stream.ws_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

# Copyright 2018 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from kubernetes.client.rest import ApiException

import select
import certifi
import time
import collections
from websocket import WebSocket, ABNF, enableTrace
import six
import ssl
from six.moves.urllib.parse import urlencode, quote_plus, urlparse, urlunparse

STDIN_CHANNEL = 0
STDOUT_CHANNEL = 1
STDERR_CHANNEL = 2
ERROR_CHANNEL = 3
RESIZE_CHANNEL = 4


class WSClient:
    def __init__(self, configuration, url, headers):
        &#34;&#34;&#34;A websocket client with support for channels.

            Exec command uses different channels for different streams. for
        example, 0 is stdin, 1 is stdout and 2 is stderr. Some other API calls
        like port forwarding can forward different pods&#39; streams to different
        channels.
        &#34;&#34;&#34;
        enableTrace(False)
        header = []
        self._connected = False
        self._channels = {}
        self._all = &#34;&#34;

        # We just need to pass the Authorization, ignore all the other
        # http headers we get from the generated code
        if headers and &#39;authorization&#39; in headers:
            header.append(&#34;authorization: %s&#34; % headers[&#39;authorization&#39;])

        if headers and &#39;sec-websocket-protocol&#39; in headers:
            header.append(&#34;sec-websocket-protocol: %s&#34; %
                          headers[&#39;sec-websocket-protocol&#39;])
        else:
            header.append(&#34;sec-websocket-protocol: v4.channel.k8s.io&#34;)

        if url.startswith(&#39;wss://&#39;) and configuration.verify_ssl:
            ssl_opts = {
                &#39;cert_reqs&#39;: ssl.CERT_REQUIRED,
                &#39;ca_certs&#39;: configuration.ssl_ca_cert or certifi.where(),
            }
            if configuration.assert_hostname is not None:
                ssl_opts[&#39;check_hostname&#39;] = configuration.assert_hostname
        else:
            ssl_opts = {&#39;cert_reqs&#39;: ssl.CERT_NONE}

        if configuration.cert_file:
            ssl_opts[&#39;certfile&#39;] = configuration.cert_file
        if configuration.key_file:
            ssl_opts[&#39;keyfile&#39;] = configuration.key_file

        self.sock = WebSocket(sslopt=ssl_opts, skip_utf8_validation=False)
        self.sock.connect(url, header=header)
        self._connected = True

    def peek_channel(self, channel, timeout=0):
        &#34;&#34;&#34;Peek a channel and return part of the input,
        empty string otherwise.&#34;&#34;&#34;
        self.update(timeout=timeout)
        if channel in self._channels:
            return self._channels[channel]
        return &#34;&#34;

    def read_channel(self, channel, timeout=0):
        &#34;&#34;&#34;Read data from a channel.&#34;&#34;&#34;
        if channel not in self._channels:
            ret = self.peek_channel(channel, timeout)
        else:
            ret = self._channels[channel]
        if channel in self._channels:
            del self._channels[channel]
        return ret

    def readline_channel(self, channel, timeout=None):
        &#34;&#34;&#34;Read a line from a channel.&#34;&#34;&#34;
        if timeout is None:
            timeout = float(&#34;inf&#34;)
        start = time.time()
        while self.is_open() and time.time() - start &lt; timeout:
            if channel in self._channels:
                data = self._channels[channel]
                if &#34;\n&#34; in data:
                    index = data.find(&#34;\n&#34;)
                    ret = data[:index]
                    data = data[index+1:]
                    if data:
                        self._channels[channel] = data
                    else:
                        del self._channels[channel]
                    return ret
            self.update(timeout=(timeout - time.time() + start))

    def write_channel(self, channel, data):
        &#34;&#34;&#34;Write data to a channel.&#34;&#34;&#34;
        self.sock.send(chr(channel) + data)

    def peek_stdout(self, timeout=0):
        &#34;&#34;&#34;Same as peek_channel with channel=1.&#34;&#34;&#34;
        return self.peek_channel(STDOUT_CHANNEL, timeout=timeout)

    def read_stdout(self, timeout=None):
        &#34;&#34;&#34;Same as read_channel with channel=1.&#34;&#34;&#34;
        return self.read_channel(STDOUT_CHANNEL, timeout=timeout)

    def readline_stdout(self, timeout=None):
        &#34;&#34;&#34;Same as readline_channel with channel=1.&#34;&#34;&#34;
        return self.readline_channel(STDOUT_CHANNEL, timeout=timeout)

    def peek_stderr(self, timeout=0):
        &#34;&#34;&#34;Same as peek_channel with channel=2.&#34;&#34;&#34;
        return self.peek_channel(STDERR_CHANNEL, timeout=timeout)

    def read_stderr(self, timeout=None):
        &#34;&#34;&#34;Same as read_channel with channel=2.&#34;&#34;&#34;
        return self.read_channel(STDERR_CHANNEL, timeout=timeout)

    def readline_stderr(self, timeout=None):
        &#34;&#34;&#34;Same as readline_channel with channel=2.&#34;&#34;&#34;
        return self.readline_channel(STDERR_CHANNEL, timeout=timeout)

    def read_all(self):
        &#34;&#34;&#34;Return buffered data received on stdout and stderr channels.
        This is useful for non-interactive call where a set of command passed
        to the API call and their result is needed after the call is concluded.
        Should be called after run_forever() or update()

        TODO: Maybe we can process this and return a more meaningful map with
        channels mapped for each input.
        &#34;&#34;&#34;
        out = self._all
        self._all = &#34;&#34;
        self._channels = {}
        return out

    def is_open(self):
        &#34;&#34;&#34;True if the connection is still alive.&#34;&#34;&#34;
        return self._connected

    def write_stdin(self, data):
        &#34;&#34;&#34;The same as write_channel with channel=0.&#34;&#34;&#34;
        self.write_channel(STDIN_CHANNEL, data)

    def update(self, timeout=0):
        &#34;&#34;&#34;Update channel buffers with at most one complete frame of input.&#34;&#34;&#34;
        if not self.is_open():
            return
        if not self.sock.connected:
            self._connected = False
            return
        r, _, _ = select.select(
            (self.sock.sock, ), (), (), timeout)
        if r:
            op_code, frame = self.sock.recv_data_frame(True)
            if op_code == ABNF.OPCODE_CLOSE:
                self._connected = False
                return
            elif op_code == ABNF.OPCODE_BINARY or op_code == ABNF.OPCODE_TEXT:
                data = frame.data
                if six.PY3:
                    data = data.decode(&#34;utf-8&#34;, &#34;replace&#34;)
                if len(data) &gt; 1:
                    channel = ord(data[0])
                    data = data[1:]
                    if data:
                        if channel in [STDOUT_CHANNEL, STDERR_CHANNEL]:
                            # keeping all messages in the order they received
                            # for non-blocking call.
                            self._all += data
                        if channel not in self._channels:
                            self._channels[channel] = data
                        else:
                            self._channels[channel] += data

    def run_forever(self, timeout=None):
        &#34;&#34;&#34;Wait till connection is closed or timeout reached. Buffer any input
        received during this time.&#34;&#34;&#34;
        if timeout:
            start = time.time()
            while self.is_open() and time.time() - start &lt; timeout:
                self.update(timeout=(timeout - time.time() + start))
        else:
            while self.is_open():
                self.update(timeout=None)

    def close(self, **kwargs):
        &#34;&#34;&#34;
        close websocket connection.
        &#34;&#34;&#34;
        self._connected = False
        if self.sock:
            self.sock.close(**kwargs)


WSResponse = collections.namedtuple(&#39;WSResponse&#39;, [&#39;data&#39;])


def get_websocket_url(url):
    parsed_url = urlparse(url)
    parts = list(parsed_url)
    if parsed_url.scheme == &#39;http&#39;:
        parts[0] = &#39;ws&#39;
    elif parsed_url.scheme == &#39;https&#39;:
        parts[0] = &#39;wss&#39;
    return urlunparse(parts)


def websocket_call(configuration, *args, **kwargs):
    &#34;&#34;&#34;An internal function to be called in api-client when a websocket
    connection is required. args and kwargs are the parameters of
    apiClient.request method.&#34;&#34;&#34;

    url = args[1]
    _request_timeout = kwargs.get(&#34;_request_timeout&#34;, 60)
    _preload_content = kwargs.get(&#34;_preload_content&#34;, True)
    headers = kwargs.get(&#34;headers&#34;)

    # Expand command parameter list to indivitual command params
    query_params = []
    for key, value in kwargs.get(&#34;query_params&#34;, {}):
        if key == &#39;command&#39; and isinstance(value, list):
            for command in value:
                query_params.append((key, command))
        else:
            query_params.append((key, value))

    if query_params:
        url += &#39;?&#39; + urlencode(query_params)

    try:
        client = WSClient(configuration, get_websocket_url(url), headers)
        if not _preload_content:
            return client
        client.run_forever(timeout=_request_timeout)
        return WSResponse(&#39;%s&#39; % &#39;&#39;.join(client.read_all()))
    except (Exception, KeyboardInterrupt, SystemExit) as e:
        raise ApiException(status=0, reason=str(e))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kubernetes.stream.ws_client.get_websocket_url"><code class="name flex">
<span>def <span class="ident">get_websocket_url</span></span>(<span>url)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_websocket_url(url):
    parsed_url = urlparse(url)
    parts = list(parsed_url)
    if parsed_url.scheme == &#39;http&#39;:
        parts[0] = &#39;ws&#39;
    elif parsed_url.scheme == &#39;https&#39;:
        parts[0] = &#39;wss&#39;
    return urlunparse(parts)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.websocket_call"><code class="name flex">
<span>def <span class="ident">websocket_call</span></span>(<span>configuration, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>An internal function to be called in api-client when a websocket
connection is required. args and kwargs are the parameters of
apiClient.request method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def websocket_call(configuration, *args, **kwargs):
    &#34;&#34;&#34;An internal function to be called in api-client when a websocket
    connection is required. args and kwargs are the parameters of
    apiClient.request method.&#34;&#34;&#34;

    url = args[1]
    _request_timeout = kwargs.get(&#34;_request_timeout&#34;, 60)
    _preload_content = kwargs.get(&#34;_preload_content&#34;, True)
    headers = kwargs.get(&#34;headers&#34;)

    # Expand command parameter list to indivitual command params
    query_params = []
    for key, value in kwargs.get(&#34;query_params&#34;, {}):
        if key == &#39;command&#39; and isinstance(value, list):
            for command in value:
                query_params.append((key, command))
        else:
            query_params.append((key, value))

    if query_params:
        url += &#39;?&#39; + urlencode(query_params)

    try:
        client = WSClient(configuration, get_websocket_url(url), headers)
        if not _preload_content:
            return client
        client.run_forever(timeout=_request_timeout)
        return WSResponse(&#39;%s&#39; % &#39;&#39;.join(client.read_all()))
    except (Exception, KeyboardInterrupt, SystemExit) as e:
        raise ApiException(status=0, reason=str(e))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kubernetes.stream.ws_client.WSClient"><code class="flex name class">
<span>class <span class="ident">WSClient</span></span>
<span>(</span><span>configuration, url, headers)</span>
</code></dt>
<dd>
<section class="desc"><p>A websocket client with support for channels.</p>
<pre><code>Exec command uses different channels for different streams. for
</code></pre>
<p>example, 0 is stdin, 1 is stdout and 2 is stderr. Some other API calls
like port forwarding can forward different pods' streams to different
channels.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WSClient:
    def __init__(self, configuration, url, headers):
        &#34;&#34;&#34;A websocket client with support for channels.

            Exec command uses different channels for different streams. for
        example, 0 is stdin, 1 is stdout and 2 is stderr. Some other API calls
        like port forwarding can forward different pods&#39; streams to different
        channels.
        &#34;&#34;&#34;
        enableTrace(False)
        header = []
        self._connected = False
        self._channels = {}
        self._all = &#34;&#34;

        # We just need to pass the Authorization, ignore all the other
        # http headers we get from the generated code
        if headers and &#39;authorization&#39; in headers:
            header.append(&#34;authorization: %s&#34; % headers[&#39;authorization&#39;])

        if headers and &#39;sec-websocket-protocol&#39; in headers:
            header.append(&#34;sec-websocket-protocol: %s&#34; %
                          headers[&#39;sec-websocket-protocol&#39;])
        else:
            header.append(&#34;sec-websocket-protocol: v4.channel.k8s.io&#34;)

        if url.startswith(&#39;wss://&#39;) and configuration.verify_ssl:
            ssl_opts = {
                &#39;cert_reqs&#39;: ssl.CERT_REQUIRED,
                &#39;ca_certs&#39;: configuration.ssl_ca_cert or certifi.where(),
            }
            if configuration.assert_hostname is not None:
                ssl_opts[&#39;check_hostname&#39;] = configuration.assert_hostname
        else:
            ssl_opts = {&#39;cert_reqs&#39;: ssl.CERT_NONE}

        if configuration.cert_file:
            ssl_opts[&#39;certfile&#39;] = configuration.cert_file
        if configuration.key_file:
            ssl_opts[&#39;keyfile&#39;] = configuration.key_file

        self.sock = WebSocket(sslopt=ssl_opts, skip_utf8_validation=False)
        self.sock.connect(url, header=header)
        self._connected = True

    def peek_channel(self, channel, timeout=0):
        &#34;&#34;&#34;Peek a channel and return part of the input,
        empty string otherwise.&#34;&#34;&#34;
        self.update(timeout=timeout)
        if channel in self._channels:
            return self._channels[channel]
        return &#34;&#34;

    def read_channel(self, channel, timeout=0):
        &#34;&#34;&#34;Read data from a channel.&#34;&#34;&#34;
        if channel not in self._channels:
            ret = self.peek_channel(channel, timeout)
        else:
            ret = self._channels[channel]
        if channel in self._channels:
            del self._channels[channel]
        return ret

    def readline_channel(self, channel, timeout=None):
        &#34;&#34;&#34;Read a line from a channel.&#34;&#34;&#34;
        if timeout is None:
            timeout = float(&#34;inf&#34;)
        start = time.time()
        while self.is_open() and time.time() - start &lt; timeout:
            if channel in self._channels:
                data = self._channels[channel]
                if &#34;\n&#34; in data:
                    index = data.find(&#34;\n&#34;)
                    ret = data[:index]
                    data = data[index+1:]
                    if data:
                        self._channels[channel] = data
                    else:
                        del self._channels[channel]
                    return ret
            self.update(timeout=(timeout - time.time() + start))

    def write_channel(self, channel, data):
        &#34;&#34;&#34;Write data to a channel.&#34;&#34;&#34;
        self.sock.send(chr(channel) + data)

    def peek_stdout(self, timeout=0):
        &#34;&#34;&#34;Same as peek_channel with channel=1.&#34;&#34;&#34;
        return self.peek_channel(STDOUT_CHANNEL, timeout=timeout)

    def read_stdout(self, timeout=None):
        &#34;&#34;&#34;Same as read_channel with channel=1.&#34;&#34;&#34;
        return self.read_channel(STDOUT_CHANNEL, timeout=timeout)

    def readline_stdout(self, timeout=None):
        &#34;&#34;&#34;Same as readline_channel with channel=1.&#34;&#34;&#34;
        return self.readline_channel(STDOUT_CHANNEL, timeout=timeout)

    def peek_stderr(self, timeout=0):
        &#34;&#34;&#34;Same as peek_channel with channel=2.&#34;&#34;&#34;
        return self.peek_channel(STDERR_CHANNEL, timeout=timeout)

    def read_stderr(self, timeout=None):
        &#34;&#34;&#34;Same as read_channel with channel=2.&#34;&#34;&#34;
        return self.read_channel(STDERR_CHANNEL, timeout=timeout)

    def readline_stderr(self, timeout=None):
        &#34;&#34;&#34;Same as readline_channel with channel=2.&#34;&#34;&#34;
        return self.readline_channel(STDERR_CHANNEL, timeout=timeout)

    def read_all(self):
        &#34;&#34;&#34;Return buffered data received on stdout and stderr channels.
        This is useful for non-interactive call where a set of command passed
        to the API call and their result is needed after the call is concluded.
        Should be called after run_forever() or update()

        TODO: Maybe we can process this and return a more meaningful map with
        channels mapped for each input.
        &#34;&#34;&#34;
        out = self._all
        self._all = &#34;&#34;
        self._channels = {}
        return out

    def is_open(self):
        &#34;&#34;&#34;True if the connection is still alive.&#34;&#34;&#34;
        return self._connected

    def write_stdin(self, data):
        &#34;&#34;&#34;The same as write_channel with channel=0.&#34;&#34;&#34;
        self.write_channel(STDIN_CHANNEL, data)

    def update(self, timeout=0):
        &#34;&#34;&#34;Update channel buffers with at most one complete frame of input.&#34;&#34;&#34;
        if not self.is_open():
            return
        if not self.sock.connected:
            self._connected = False
            return
        r, _, _ = select.select(
            (self.sock.sock, ), (), (), timeout)
        if r:
            op_code, frame = self.sock.recv_data_frame(True)
            if op_code == ABNF.OPCODE_CLOSE:
                self._connected = False
                return
            elif op_code == ABNF.OPCODE_BINARY or op_code == ABNF.OPCODE_TEXT:
                data = frame.data
                if six.PY3:
                    data = data.decode(&#34;utf-8&#34;, &#34;replace&#34;)
                if len(data) &gt; 1:
                    channel = ord(data[0])
                    data = data[1:]
                    if data:
                        if channel in [STDOUT_CHANNEL, STDERR_CHANNEL]:
                            # keeping all messages in the order they received
                            # for non-blocking call.
                            self._all += data
                        if channel not in self._channels:
                            self._channels[channel] = data
                        else:
                            self._channels[channel] += data

    def run_forever(self, timeout=None):
        &#34;&#34;&#34;Wait till connection is closed or timeout reached. Buffer any input
        received during this time.&#34;&#34;&#34;
        if timeout:
            start = time.time()
            while self.is_open() and time.time() - start &lt; timeout:
                self.update(timeout=(timeout - time.time() + start))
        else:
            while self.is_open():
                self.update(timeout=None)

    def close(self, **kwargs):
        &#34;&#34;&#34;
        close websocket connection.
        &#34;&#34;&#34;
        self._connected = False
        if self.sock:
            self.sock.close(**kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.stream.ws_client.WSClient.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>close websocket connection.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, **kwargs):
    &#34;&#34;&#34;
    close websocket connection.
    &#34;&#34;&#34;
    self._connected = False
    if self.sock:
        self.sock.close(**kwargs)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.is_open"><code class="name flex">
<span>def <span class="ident">is_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>True if the connection is still alive.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_open(self):
    &#34;&#34;&#34;True if the connection is still alive.&#34;&#34;&#34;
    return self._connected</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.peek_channel"><code class="name flex">
<span>def <span class="ident">peek_channel</span></span>(<span>self, channel, timeout=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Peek a channel and return part of the input,
empty string otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek_channel(self, channel, timeout=0):
    &#34;&#34;&#34;Peek a channel and return part of the input,
    empty string otherwise.&#34;&#34;&#34;
    self.update(timeout=timeout)
    if channel in self._channels:
        return self._channels[channel]
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.peek_stderr"><code class="name flex">
<span>def <span class="ident">peek_stderr</span></span>(<span>self, timeout=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as peek_channel with channel=2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek_stderr(self, timeout=0):
    &#34;&#34;&#34;Same as peek_channel with channel=2.&#34;&#34;&#34;
    return self.peek_channel(STDERR_CHANNEL, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.peek_stdout"><code class="name flex">
<span>def <span class="ident">peek_stdout</span></span>(<span>self, timeout=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as peek_channel with channel=1.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek_stdout(self, timeout=0):
    &#34;&#34;&#34;Same as peek_channel with channel=1.&#34;&#34;&#34;
    return self.peek_channel(STDOUT_CHANNEL, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.read_all"><code class="name flex">
<span>def <span class="ident">read_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return buffered data received on stdout and stderr channels.
This is useful for non-interactive call where a set of command passed
to the API call and their result is needed after the call is concluded.
Should be called after run_forever() or update()</p>
<p>TODO: Maybe we can process this and return a more meaningful map with
channels mapped for each input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_all(self):
    &#34;&#34;&#34;Return buffered data received on stdout and stderr channels.
    This is useful for non-interactive call where a set of command passed
    to the API call and their result is needed after the call is concluded.
    Should be called after run_forever() or update()

    TODO: Maybe we can process this and return a more meaningful map with
    channels mapped for each input.
    &#34;&#34;&#34;
    out = self._all
    self._all = &#34;&#34;
    self._channels = {}
    return out</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.read_channel"><code class="name flex">
<span>def <span class="ident">read_channel</span></span>(<span>self, channel, timeout=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from a channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_channel(self, channel, timeout=0):
    &#34;&#34;&#34;Read data from a channel.&#34;&#34;&#34;
    if channel not in self._channels:
        ret = self.peek_channel(channel, timeout)
    else:
        ret = self._channels[channel]
    if channel in self._channels:
        del self._channels[channel]
    return ret</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.read_stderr"><code class="name flex">
<span>def <span class="ident">read_stderr</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as read_channel with channel=2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_stderr(self, timeout=None):
    &#34;&#34;&#34;Same as read_channel with channel=2.&#34;&#34;&#34;
    return self.read_channel(STDERR_CHANNEL, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.read_stdout"><code class="name flex">
<span>def <span class="ident">read_stdout</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as read_channel with channel=1.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_stdout(self, timeout=None):
    &#34;&#34;&#34;Same as read_channel with channel=1.&#34;&#34;&#34;
    return self.read_channel(STDOUT_CHANNEL, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.readline_channel"><code class="name flex">
<span>def <span class="ident">readline_channel</span></span>(<span>self, channel, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read a line from a channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readline_channel(self, channel, timeout=None):
    &#34;&#34;&#34;Read a line from a channel.&#34;&#34;&#34;
    if timeout is None:
        timeout = float(&#34;inf&#34;)
    start = time.time()
    while self.is_open() and time.time() - start &lt; timeout:
        if channel in self._channels:
            data = self._channels[channel]
            if &#34;\n&#34; in data:
                index = data.find(&#34;\n&#34;)
                ret = data[:index]
                data = data[index+1:]
                if data:
                    self._channels[channel] = data
                else:
                    del self._channels[channel]
                return ret
        self.update(timeout=(timeout - time.time() + start))</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.readline_stderr"><code class="name flex">
<span>def <span class="ident">readline_stderr</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as readline_channel with channel=2.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readline_stderr(self, timeout=None):
    &#34;&#34;&#34;Same as readline_channel with channel=2.&#34;&#34;&#34;
    return self.readline_channel(STDERR_CHANNEL, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.readline_stdout"><code class="name flex">
<span>def <span class="ident">readline_stdout</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as readline_channel with channel=1.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readline_stdout(self, timeout=None):
    &#34;&#34;&#34;Same as readline_channel with channel=1.&#34;&#34;&#34;
    return self.readline_channel(STDOUT_CHANNEL, timeout=timeout)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.run_forever"><code class="name flex">
<span>def <span class="ident">run_forever</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Wait till connection is closed or timeout reached. Buffer any input
received during this time.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_forever(self, timeout=None):
    &#34;&#34;&#34;Wait till connection is closed or timeout reached. Buffer any input
    received during this time.&#34;&#34;&#34;
    if timeout:
        start = time.time()
        while self.is_open() and time.time() - start &lt; timeout:
            self.update(timeout=(timeout - time.time() + start))
    else:
        while self.is_open():
            self.update(timeout=None)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, timeout=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Update channel buffers with at most one complete frame of input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, timeout=0):
    &#34;&#34;&#34;Update channel buffers with at most one complete frame of input.&#34;&#34;&#34;
    if not self.is_open():
        return
    if not self.sock.connected:
        self._connected = False
        return
    r, _, _ = select.select(
        (self.sock.sock, ), (), (), timeout)
    if r:
        op_code, frame = self.sock.recv_data_frame(True)
        if op_code == ABNF.OPCODE_CLOSE:
            self._connected = False
            return
        elif op_code == ABNF.OPCODE_BINARY or op_code == ABNF.OPCODE_TEXT:
            data = frame.data
            if six.PY3:
                data = data.decode(&#34;utf-8&#34;, &#34;replace&#34;)
            if len(data) &gt; 1:
                channel = ord(data[0])
                data = data[1:]
                if data:
                    if channel in [STDOUT_CHANNEL, STDERR_CHANNEL]:
                        # keeping all messages in the order they received
                        # for non-blocking call.
                        self._all += data
                    if channel not in self._channels:
                        self._channels[channel] = data
                    else:
                        self._channels[channel] += data</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.write_channel"><code class="name flex">
<span>def <span class="ident">write_channel</span></span>(<span>self, channel, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Write data to a channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_channel(self, channel, data):
    &#34;&#34;&#34;Write data to a channel.&#34;&#34;&#34;
    self.sock.send(chr(channel) + data)</code></pre>
</details>
</dd>
<dt id="kubernetes.stream.ws_client.WSClient.write_stdin"><code class="name flex">
<span>def <span class="ident">write_stdin</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>The same as write_channel with channel=0.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_stdin(self, data):
    &#34;&#34;&#34;The same as write_channel with channel=0.&#34;&#34;&#34;
    self.write_channel(STDIN_CHANNEL, data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="kubernetes.stream.ws_client.WSResponse"><code class="flex name class">
<span>class <span class="ident">WSResponse</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>WSResponse(data,)</p></section>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="kubernetes.stream.ws_client.WSResponse.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kubernetes.stream" href="index.html">kubernetes.stream</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kubernetes.stream.ws_client.get_websocket_url" href="#kubernetes.stream.ws_client.get_websocket_url">get_websocket_url</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.websocket_call" href="#kubernetes.stream.ws_client.websocket_call">websocket_call</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kubernetes.stream.ws_client.WSClient" href="#kubernetes.stream.ws_client.WSClient">WSClient</a></code></h4>
<ul class="two-column">
<li><code><a title="kubernetes.stream.ws_client.WSClient.close" href="#kubernetes.stream.ws_client.WSClient.close">close</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.is_open" href="#kubernetes.stream.ws_client.WSClient.is_open">is_open</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.peek_channel" href="#kubernetes.stream.ws_client.WSClient.peek_channel">peek_channel</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.peek_stderr" href="#kubernetes.stream.ws_client.WSClient.peek_stderr">peek_stderr</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.peek_stdout" href="#kubernetes.stream.ws_client.WSClient.peek_stdout">peek_stdout</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.read_all" href="#kubernetes.stream.ws_client.WSClient.read_all">read_all</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.read_channel" href="#kubernetes.stream.ws_client.WSClient.read_channel">read_channel</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.read_stderr" href="#kubernetes.stream.ws_client.WSClient.read_stderr">read_stderr</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.read_stdout" href="#kubernetes.stream.ws_client.WSClient.read_stdout">read_stdout</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.readline_channel" href="#kubernetes.stream.ws_client.WSClient.readline_channel">readline_channel</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.readline_stderr" href="#kubernetes.stream.ws_client.WSClient.readline_stderr">readline_stderr</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.readline_stdout" href="#kubernetes.stream.ws_client.WSClient.readline_stdout">readline_stdout</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.run_forever" href="#kubernetes.stream.ws_client.WSClient.run_forever">run_forever</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.update" href="#kubernetes.stream.ws_client.WSClient.update">update</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.write_channel" href="#kubernetes.stream.ws_client.WSClient.write_channel">write_channel</a></code></li>
<li><code><a title="kubernetes.stream.ws_client.WSClient.write_stdin" href="#kubernetes.stream.ws_client.WSClient.write_stdin">write_stdin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.stream.ws_client.WSResponse" href="#kubernetes.stream.ws_client.WSResponse">WSResponse</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.stream.ws_client.WSResponse.data" href="#kubernetes.stream.ws_client.WSResponse.data">data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>