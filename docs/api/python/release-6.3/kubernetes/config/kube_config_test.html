<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>kubernetes.config.kube_config_test API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kubernetes.config.kube_config_test</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

# Copyright 2018 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import base64
import datetime
import json
import os
import shutil
import tempfile
import unittest

import mock
import yaml
from six import PY3, next

from kubernetes.client import Configuration

from .config_exception import ConfigException
from .kube_config import (ENV_KUBECONFIG_PATH_SEPARATOR, ConfigNode,
                          FileOrData, KubeConfigLoader, KubeConfigMerger,
                          _cleanup_temp_files, _create_temp_file_with_content,
                          list_kube_config_contexts, load_kube_config,
                          new_client_from_config)

BEARER_TOKEN_FORMAT = &#34;Bearer %s&#34;

EXPIRY_DATETIME_FORMAT = &#34;%Y-%m-%dT%H:%M:%SZ&#34;
# should be less than kube_config.EXPIRY_SKEW_PREVENTION_DELAY
PAST_EXPIRY_TIMEDELTA = 2
# should be more than kube_config.EXPIRY_SKEW_PREVENTION_DELAY
FUTURE_EXPIRY_TIMEDELTA = 60

NON_EXISTING_FILE = &#34;zz_non_existing_file_472398324&#34;


def _base64(string):
    return base64.standard_b64encode(string.encode()).decode()


def _urlsafe_unpadded_b64encode(string):
    return base64.urlsafe_b64encode(string.encode()).decode().rstrip(&#39;=&#39;)


def _format_expiry_datetime(dt):
    return dt.strftime(EXPIRY_DATETIME_FORMAT)


def _get_expiry(loader, active_context):
    expired_gcp_conf = (item for item in loader._config.value.get(&#34;users&#34;)
                        if item.get(&#34;name&#34;) == active_context)
    return next(expired_gcp_conf).get(&#34;user&#34;).get(&#34;auth-provider&#34;) \
        .get(&#34;config&#34;).get(&#34;expiry&#34;)


def _raise_exception(st):
    raise Exception(st)


TEST_FILE_KEY = &#34;file&#34;
TEST_DATA_KEY = &#34;data&#34;
TEST_FILENAME = &#34;test-filename&#34;

TEST_DATA = &#34;test-data&#34;
TEST_DATA_BASE64 = _base64(TEST_DATA)

TEST_ANOTHER_DATA = &#34;another-test-data&#34;
TEST_ANOTHER_DATA_BASE64 = _base64(TEST_ANOTHER_DATA)

TEST_HOST = &#34;test-host&#34;
TEST_USERNAME = &#34;me&#34;
TEST_PASSWORD = &#34;pass&#34;
# token for me:pass
TEST_BASIC_TOKEN = &#34;Basic bWU6cGFzcw==&#34;
DATETIME_EXPIRY_PAST = datetime.datetime.utcnow(
) - datetime.timedelta(minutes=PAST_EXPIRY_TIMEDELTA)
DATETIME_EXPIRY_FUTURE = datetime.datetime.utcnow(
) + datetime.timedelta(minutes=FUTURE_EXPIRY_TIMEDELTA)
TEST_TOKEN_EXPIRY_PAST = _format_expiry_datetime(DATETIME_EXPIRY_PAST)

TEST_SSL_HOST = &#34;https://test-host&#34;
TEST_CERTIFICATE_AUTH = &#34;cert-auth&#34;
TEST_CERTIFICATE_AUTH_BASE64 = _base64(TEST_CERTIFICATE_AUTH)
TEST_CLIENT_KEY = &#34;client-key&#34;
TEST_CLIENT_KEY_BASE64 = _base64(TEST_CLIENT_KEY)
TEST_CLIENT_CERT = &#34;client-cert&#34;
TEST_CLIENT_CERT_BASE64 = _base64(TEST_CLIENT_CERT)


TEST_OIDC_TOKEN = &#34;test-oidc-token&#34;
TEST_OIDC_INFO = &#34;{\&#34;name\&#34;: \&#34;test\&#34;}&#34;
TEST_OIDC_BASE = &#34;.&#34;.join([
    _urlsafe_unpadded_b64encode(TEST_OIDC_TOKEN),
    _urlsafe_unpadded_b64encode(TEST_OIDC_INFO)
])
TEST_OIDC_LOGIN = &#34;.&#34;.join([
    TEST_OIDC_BASE,
    _urlsafe_unpadded_b64encode(TEST_CLIENT_CERT_BASE64)
])
TEST_OIDC_TOKEN = &#34;Bearer %s&#34; % TEST_OIDC_LOGIN
TEST_OIDC_EXP = &#34;{\&#34;name\&#34;: \&#34;test\&#34;,\&#34;exp\&#34;: 536457600}&#34;
TEST_OIDC_EXP_BASE = _urlsafe_unpadded_b64encode(
    TEST_OIDC_TOKEN) + &#34;.&#34; + _urlsafe_unpadded_b64encode(TEST_OIDC_EXP)
TEST_OIDC_EXPIRED_LOGIN = &#34;.&#34;.join([
    TEST_OIDC_EXP_BASE,
    _urlsafe_unpadded_b64encode(TEST_CLIENT_CERT)
])
TEST_OIDC_CONTAINS_RESERVED_CHARACTERS = &#34;.&#34;.join([
    _urlsafe_unpadded_b64encode(TEST_OIDC_TOKEN),
    _urlsafe_unpadded_b64encode(TEST_OIDC_INFO).replace(&#34;a&#34;, &#34;+&#34;),
    _urlsafe_unpadded_b64encode(TEST_CLIENT_CERT)
])
TEST_OIDC_INVALID_PADDING_LENGTH = &#34;.&#34;.join([
    _urlsafe_unpadded_b64encode(TEST_OIDC_TOKEN),
    &#34;aaaaa&#34;,
    _urlsafe_unpadded_b64encode(TEST_CLIENT_CERT)
])

TEST_OIDC_CA = _base64(TEST_CERTIFICATE_AUTH)


class BaseTestCase(unittest.TestCase):

    def setUp(self):
        self._temp_files = []

    def tearDown(self):
        for f in self._temp_files:
            os.remove(f)

    def _create_temp_file(self, content=&#34;&#34;):
        handler, name = tempfile.mkstemp()
        self._temp_files.append(name)
        os.write(handler, str.encode(content))
        os.close(handler)
        return name

    def expect_exception(self, func, message_part, *args, **kwargs):
        with self.assertRaises(ConfigException) as context:
            func(*args, **kwargs)
        self.assertIn(message_part, str(context.exception))


class TestFileOrData(BaseTestCase):

    @staticmethod
    def get_file_content(filename):
        with open(filename) as f:
            return f.read()

    def test_file_given_file(self):
        temp_filename = _create_temp_file_with_content(TEST_DATA)
        obj = {TEST_FILE_KEY: temp_filename}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_given_non_existing_file(self):
        temp_filename = NON_EXISTING_FILE
        obj = {TEST_FILE_KEY: temp_filename}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
        self.expect_exception(t.as_file, &#34;does not exists&#34;)

    def test_file_given_data(self):
        obj = {TEST_DATA_KEY: TEST_DATA_BASE64}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_given_data_no_base64(self):
        obj = {TEST_DATA_KEY: TEST_DATA}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY, base64_file_content=False)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_data_given_data(self):
        obj = {TEST_DATA_KEY: TEST_DATA_BASE64}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA_BASE64, t.as_data())

    def test_data_given_file(self):
        obj = {
            TEST_FILE_KEY: self._create_temp_file(content=TEST_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
        self.assertEqual(TEST_DATA_BASE64, t.as_data())

    def test_data_given_file_no_base64(self):
        obj = {
            TEST_FILE_KEY: self._create_temp_file(content=TEST_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       base64_file_content=False)
        self.assertEqual(TEST_DATA, t.as_data())

    def test_data_given_file_and_data(self):
        obj = {
            TEST_DATA_KEY: TEST_DATA_BASE64,
            TEST_FILE_KEY: self._create_temp_file(
                content=TEST_ANOTHER_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA_BASE64, t.as_data())

    def test_file_given_file_and_data(self):
        obj = {
            TEST_DATA_KEY: TEST_DATA_BASE64,
            TEST_FILE_KEY: self._create_temp_file(
                content=TEST_ANOTHER_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_with_custom_dirname(self):
        tempfile = self._create_temp_file(content=TEST_DATA)
        tempfile_dir = os.path.dirname(tempfile)
        tempfile_basename = os.path.basename(tempfile)
        obj = {TEST_FILE_KEY: tempfile_basename}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       file_base_path=tempfile_dir)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_create_temp_file_with_content(self):
        self.assertEqual(TEST_DATA,
                         self.get_file_content(
                             _create_temp_file_with_content(TEST_DATA)))
        _cleanup_temp_files()

    def test_file_given_data_bytes(self):
        obj = {TEST_DATA_KEY: TEST_DATA_BASE64.encode()}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_given_data_bytes_no_base64(self):
        obj = {TEST_DATA_KEY: TEST_DATA.encode()}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY, base64_file_content=False)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))


class TestConfigNode(BaseTestCase):

    test_obj = {&#34;key1&#34;: &#34;test&#34;, &#34;key2&#34;: [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;],
                &#34;key3&#34;: {&#34;inner_key&#34;: &#34;inner_value&#34;},
                &#34;with_names&#34;: [{&#34;name&#34;: &#34;test_name&#34;, &#34;value&#34;: &#34;test_value&#34;},
                               {&#34;name&#34;: &#34;test_name2&#34;,
                                &#34;value&#34;: {&#34;key1&#34;, &#34;test&#34;}},
                               {&#34;name&#34;: &#34;test_name3&#34;, &#34;value&#34;: [1, 2, 3]}],
                &#34;with_names_dup&#34;: [
                    {&#34;name&#34;: &#34;test_name&#34;, &#34;value&#34;: &#34;test_value&#34;},
                    {&#34;name&#34;: &#34;test_name&#34;,
                     &#34;value&#34;: {&#34;key1&#34;, &#34;test&#34;}},
                    {&#34;name&#34;: &#34;test_name3&#34;, &#34;value&#34;: [1, 2, 3]}
    ]}

    def setUp(self):
        super(TestConfigNode, self).setUp()
        self.node = ConfigNode(&#34;test_obj&#34;, self.test_obj)

    def test_normal_map_array_operations(self):
        self.assertEqual(&#34;test&#34;, self.node[&#39;key1&#39;])
        self.assertEqual(5, len(self.node))

        self.assertEqual(&#34;test_obj/key2&#34;, self.node[&#39;key2&#39;].name)
        self.assertEqual([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;], self.node[&#39;key2&#39;].value)
        self.assertEqual(&#34;b&#34;, self.node[&#39;key2&#39;][1])
        self.assertEqual(3, len(self.node[&#39;key2&#39;]))

        self.assertEqual(&#34;test_obj/key3&#34;, self.node[&#39;key3&#39;].name)
        self.assertEqual({&#34;inner_key&#34;: &#34;inner_value&#34;},
                         self.node[&#39;key3&#39;].value)
        self.assertEqual(&#34;inner_value&#34;, self.node[&#39;key3&#39;][&#34;inner_key&#34;])
        self.assertEqual(1, len(self.node[&#39;key3&#39;]))

    def test_get_with_name(self):
        node = self.node[&#34;with_names&#34;]
        self.assertEqual(
            &#34;test_value&#34;,
            node.get_with_name(&#34;test_name&#34;)[&#34;value&#34;])
        self.assertTrue(
            isinstance(node.get_with_name(&#34;test_name2&#34;), ConfigNode))
        self.assertTrue(
            isinstance(node.get_with_name(&#34;test_name3&#34;), ConfigNode))
        self.assertEqual(&#34;test_obj/with_names[name=test_name2]&#34;,
                         node.get_with_name(&#34;test_name2&#34;).name)
        self.assertEqual(&#34;test_obj/with_names[name=test_name3]&#34;,
                         node.get_with_name(&#34;test_name3&#34;).name)

    def test_key_does_not_exists(self):
        self.expect_exception(lambda: self.node[&#39;not-exists-key&#39;],
                              &#34;Expected key not-exists-key in test_obj&#34;)
        self.expect_exception(lambda: self.node[&#39;key3&#39;][&#39;not-exists-key&#39;],
                              &#34;Expected key not-exists-key in test_obj/key3&#34;)

    def test_get_with_name_on_invalid_object(self):
        self.expect_exception(
            lambda: self.node[&#39;key2&#39;].get_with_name(&#39;no-name&#39;),
            &#34;Expected all values in test_obj/key2 list to have \&#39;name\&#39; key&#34;)

    def test_get_with_name_on_non_list_object(self):
        self.expect_exception(
            lambda: self.node[&#39;key3&#39;].get_with_name(&#39;no-name&#39;),
            &#34;Expected test_obj/key3 to be a list&#34;)

    def test_get_with_name_on_name_does_not_exists(self):
        self.expect_exception(
            lambda: self.node[&#39;with_names&#39;].get_with_name(&#39;no-name&#39;),
            &#34;Expected object with name no-name in test_obj/with_names list&#34;)

    def test_get_with_name_on_duplicate_name(self):
        self.expect_exception(
            lambda: self.node[&#39;with_names_dup&#39;].get_with_name(&#39;test_name&#39;),
            &#34;Expected only one object with name test_name in &#34;
            &#34;test_obj/with_names_dup list&#34;)


class FakeConfig:

    FILE_KEYS = [&#34;ssl_ca_cert&#34;, &#34;key_file&#34;, &#34;cert_file&#34;]

    def __init__(self, token=None, **kwargs):
        self.api_key = {}
        if token:
            self.api_key[&#39;authorization&#39;] = token

        self.__dict__.update(kwargs)

    def __eq__(self, other):
        if len(self.__dict__) != len(other.__dict__):
            return
        for k, v in self.__dict__.items():
            if k not in other.__dict__:
                return
            if k in self.FILE_KEYS:
                if v and other.__dict__[k]:
                    try:
                        with open(v) as f1, open(other.__dict__[k]) as f2:
                            if f1.read() != f2.read():
                                return
                    except IOError:
                        # fall back to only compare filenames in case we are
                        # testing the passing of filenames to the config
                        if other.__dict__[k] != v:
                            return
                else:
                    if other.__dict__[k] != v:
                        return
            else:
                if other.__dict__[k] != v:
                    return
        return True

    def __repr__(self):
        rep = &#34;\n&#34;
        for k, v in self.__dict__.items():
            val = v
            if k in self.FILE_KEYS:
                try:
                    with open(v) as f:
                        val = &#34;FILE: %s&#34; % str.decode(f.read())
                except IOError as e:
                    val = &#34;ERROR: %s&#34; % str(e)
            rep += &#34;\t%s: %s\n&#34; % (k, val)
        return &#34;Config(%s\n)&#34; % rep


class TestKubeConfigLoader(BaseTestCase):
    TEST_KUBE_CONFIG = {
        &#34;current-context&#34;: &#34;no_user&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;no_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;
                }
            },
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;simple_token&#34;
                }
            },
            {
                &#34;name&#34;: &#34;gcp&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;gcp&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_gcp&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_gcp&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_gcp_refresh&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_gcp_refresh&#34;
                }
            },
            {
                &#34;name&#34;: &#34;oidc&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;oidc&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_oidc&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc_nocert&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_oidc_nocert&#34;
                }
            },
            {
                &#34;name&#34;: &#34;oidc_contains_reserved_character&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;oidc_contains_reserved_character&#34;

                }
            },
            {
                &#34;name&#34;: &#34;oidc_invalid_padding_length&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;oidc_invalid_padding_length&#34;

                }
            },
            {
                &#34;name&#34;: &#34;user_pass&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;user_pass&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl&#34;,
                    &#34;user&#34;: &#34;ssl&#34;
                }
            },
            {
                &#34;name&#34;: &#34;no_ssl_verification&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;no_ssl_verification&#34;,
                    &#34;user&#34;: &#34;ssl&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl-no_file&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl-no_file&#34;,
                    &#34;user&#34;: &#34;ssl-no_file&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl-local-file&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl-local-file&#34;,
                    &#34;user&#34;: &#34;ssl-local-file&#34;
                }
            },
            {
                &#34;name&#34;: &#34;non_existing_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;non_existing_user&#34;
                }
            },
            {
                &#34;name&#34;: &#34;exec_cred_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;exec_cred_user&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
            {
                &#34;name&#34;: &#34;default&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_HOST
                }
            },
            {
                &#34;name&#34;: &#34;ssl-no_file&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority&#34;: TEST_CERTIFICATE_AUTH,
                }
            },
            {
                &#34;name&#34;: &#34;ssl-local-file&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority&#34;: &#34;cert_test&#34;,
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority-data&#34;:
                        TEST_CERTIFICATE_AUTH_BASE64,
                }
            },
            {
                &#34;name&#34;: &#34;no_ssl_verification&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;insecure-skip-tls-verify&#34;: &#34;true&#34;,
                }
            },
        ],
        &#34;users&#34;: [
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;gcp&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;gcp&#34;,
                        &#34;config&#34;: {
                            &#34;access-token&#34;: TEST_DATA_BASE64,
                        }
                    },
                    &#34;token&#34;: TEST_DATA_BASE64,  # should be ignored
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;expired_gcp&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;gcp&#34;,
                        &#34;config&#34;: {
                            &#34;access-token&#34;: TEST_DATA_BASE64,
                            &#34;expiry&#34;: TEST_TOKEN_EXPIRY_PAST,  # always in past
                        }
                    },
                    &#34;token&#34;: TEST_DATA_BASE64,  # should be ignored
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            # Duplicated from &#34;expired_gcp&#34; so test_load_gcp_token_with_refresh
            # is isolated from test_gcp_get_api_key_with_prefix.
            {
                &#34;name&#34;: &#34;expired_gcp_refresh&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;gcp&#34;,
                        &#34;config&#34;: {
                            &#34;access-token&#34;: TEST_DATA_BASE64,
                            &#34;expiry&#34;: TEST_TOKEN_EXPIRY_PAST,  # always in past
                        }
                    },
                    &#34;token&#34;: TEST_DATA_BASE64,  # should be ignored
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;oidc&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;id-token&#34;: TEST_OIDC_LOGIN
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_EXPIRED_LOGIN,
                            &#34;idp-certificate-authority-data&#34;: TEST_OIDC_CA,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc_nocert&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_EXPIRED_LOGIN,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;oidc_contains_reserved_character&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_CONTAINS_RESERVED_CHARACTERS,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;oidc_invalid_padding_length&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_INVALID_PADDING_LENGTH,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;user_pass&#34;,
                &#34;user&#34;: {
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;ssl-no_file&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;client-certificate&#34;: TEST_CLIENT_CERT,
                    &#34;client-key&#34;: TEST_CLIENT_KEY,
                }
            },
            {
                &#34;name&#34;: &#34;ssl-local-file&#34;,
                &#34;user&#34;: {
                    &#34;tokenFile&#34;: &#34;token_file&#34;,
                    &#34;client-certificate&#34;: &#34;client_cert&#34;,
                    &#34;client-key&#34;: &#34;client_key&#34;,
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;client-certificate-data&#34;: TEST_CLIENT_CERT_BASE64,
                    &#34;client-key-data&#34;: TEST_CLIENT_KEY_BASE64,
                }
            },
            {
                &#34;name&#34;: &#34;exec_cred_user&#34;,
                &#34;user&#34;: {
                    &#34;exec&#34;: {
                        &#34;apiVersion&#34;: &#34;client.authentication.k8s.io/v1beta1&#34;,
                        &#34;command&#34;: &#34;aws-iam-authenticator&#34;,
                        &#34;args&#34;: [&#34;token&#34;, &#34;-i&#34;, &#34;dummy-cluster&#34;]
                    }
                }
            },
        ]
    }

    def test_no_user_context(self):
        expected = FakeConfig(host=TEST_HOST)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;no_user&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_simple_token(self):
        expected = FakeConfig(host=TEST_HOST,
                              token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;simple_token&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_load_user_token(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;simple_token&#34;)
        self.assertTrue(loader._load_user_token())
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64, loader.token)

    def test_gcp_no_refresh(self):
        fake_config = FakeConfig()
        # swagger-generated config has this, but FakeConfig does not.
        self.assertFalse(hasattr(fake_config, &#39;get_api_key_with_prefix&#39;))
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;gcp&#34;,
            get_google_credentials=lambda: _raise_exception(
                &#34;SHOULD NOT BE CALLED&#34;)).load_and_set(fake_config)
        # Should now be populated with a gcp token fetcher.
        self.assertIsNotNone(fake_config.get_api_key_with_prefix)
        self.assertEqual(TEST_HOST, fake_config.host)
        # For backwards compatibility, authorization field should still be set.
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         fake_config.api_key[&#39;authorization&#39;])

    def test_load_gcp_token_no_refresh(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;gcp&#34;,
            get_google_credentials=lambda: _raise_exception(
                &#34;SHOULD NOT BE CALLED&#34;))
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         loader.token)

    def test_load_gcp_token_with_refresh(self):
        def cred(): return None
        cred.token = TEST_ANOTHER_DATA_BASE64
        cred.expiry = datetime.datetime.utcnow()

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_gcp&#34;,
            get_google_credentials=lambda: cred)
        original_expiry = _get_expiry(loader, &#34;expired_gcp&#34;)
        self.assertTrue(loader._load_auth_provider_token())
        new_expiry = _get_expiry(loader, &#34;expired_gcp&#34;)
        # assert that the configs expiry actually updates
        self.assertTrue(new_expiry &gt; original_expiry)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                         loader.token)

    def test_gcp_get_api_key_with_prefix(self):
        class cred_old:
            token = TEST_DATA_BASE64
            expiry = DATETIME_EXPIRY_PAST

        class cred_new:
            token = TEST_ANOTHER_DATA_BASE64
            expiry = DATETIME_EXPIRY_FUTURE
        fake_config = FakeConfig()
        _get_google_credentials = mock.Mock()
        _get_google_credentials.side_effect = [cred_old, cred_new]

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_gcp_refresh&#34;,
            get_google_credentials=_get_google_credentials)
        loader.load_and_set(fake_config)
        original_expiry = _get_expiry(loader, &#34;expired_gcp_refresh&#34;)
        # Call GCP token fetcher.
        token = fake_config.get_api_key_with_prefix()
        new_expiry = _get_expiry(loader, &#34;expired_gcp_refresh&#34;)

        self.assertTrue(new_expiry &gt; original_expiry)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                         loader.token)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                         token)

    def test_oidc_no_refresh(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;oidc&#34;,
        )
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(TEST_OIDC_TOKEN, loader.token)

    @mock.patch(&#39;kubernetes.config.kube_config.OAuth2Session.refresh_token&#39;)
    @mock.patch(&#39;kubernetes.config.kube_config.ApiClient.request&#39;)
    def test_oidc_with_refresh(self, mock_ApiClient, mock_OAuth2Session):
        mock_response = mock.MagicMock()
        type(mock_response).status = mock.PropertyMock(
            return_value=200
        )
        type(mock_response).data = mock.PropertyMock(
            return_value=json.dumps({
                &#34;token_endpoint&#34;: &#34;https://example.org/identity/token&#34;
            })
        )

        mock_ApiClient.return_value = mock_response

        mock_OAuth2Session.return_value = {&#34;id_token&#34;: &#34;abc123&#34;,
                                           &#34;refresh_token&#34;: &#34;newtoken123&#34;}

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_oidc&#34;,
        )
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(&#34;Bearer abc123&#34;, loader.token)

    @mock.patch(&#39;kubernetes.config.kube_config.OAuth2Session.refresh_token&#39;)
    @mock.patch(&#39;kubernetes.config.kube_config.ApiClient.request&#39;)
    def test_oidc_with_refresh_nocert(
            self, mock_ApiClient, mock_OAuth2Session):
        mock_response = mock.MagicMock()
        type(mock_response).status = mock.PropertyMock(
            return_value=200
        )
        type(mock_response).data = mock.PropertyMock(
            return_value=json.dumps({
                &#34;token_endpoint&#34;: &#34;https://example.org/identity/token&#34;
            })
        )

        mock_ApiClient.return_value = mock_response

        mock_OAuth2Session.return_value = {&#34;id_token&#34;: &#34;abc123&#34;,
                                           &#34;refresh_token&#34;: &#34;newtoken123&#34;}

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_oidc_nocert&#34;,
        )
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(&#34;Bearer abc123&#34;, loader.token)

    def test_oidc_fails_if_contains_reserved_chars(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;oidc_contains_reserved_character&#34;,
        )
        self.assertEqual(
            loader._load_oid_token(&#34;oidc_contains_reserved_character&#34;),
            None,
        )

    def test_oidc_fails_if_invalid_padding_length(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;oidc_invalid_padding_length&#34;,
        )
        self.assertEqual(
            loader._load_oid_token(&#34;oidc_invalid_padding_length&#34;),
            None,
        )

    def test_user_pass(self):
        expected = FakeConfig(host=TEST_HOST, token=TEST_BASIC_TOKEN)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;user_pass&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_load_user_pass_token(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;user_pass&#34;)
        self.assertTrue(loader._load_user_pass_token())
        self.assertEqual(TEST_BASIC_TOKEN, loader.token)

    def test_ssl_no_cert_files(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;ssl-no_file&#34;)
        self.expect_exception(
            loader.load_and_set,
            &#34;does not exists&#34;,
            FakeConfig())

    def test_ssl(self):
        expected = FakeConfig(
            host=TEST_SSL_HOST,
            token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
            cert_file=self._create_temp_file(TEST_CLIENT_CERT),
            key_file=self._create_temp_file(TEST_CLIENT_KEY),
            ssl_ca_cert=self._create_temp_file(TEST_CERTIFICATE_AUTH)
        )
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;ssl&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_ssl_no_verification(self):
        expected = FakeConfig(
            host=TEST_SSL_HOST,
            token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
            cert_file=self._create_temp_file(TEST_CLIENT_CERT),
            key_file=self._create_temp_file(TEST_CLIENT_KEY),
            verify_ssl=False,
            ssl_ca_cert=None,
        )
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;no_ssl_verification&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_list_contexts(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;no_user&#34;)
        actual_contexts = loader.list_contexts()
        expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
        for actual in actual_contexts:
            expected = expected_contexts.get_with_name(actual[&#39;name&#39;])
            self.assertEqual(expected.value, actual)

    def test_current_context(self):
        loader = KubeConfigLoader(config_dict=self.TEST_KUBE_CONFIG)
        expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
        self.assertEqual(expected_contexts.get_with_name(&#34;no_user&#34;).value,
                         loader.current_context)

    def test_set_active_context(self):
        loader = KubeConfigLoader(config_dict=self.TEST_KUBE_CONFIG)
        loader.set_active_context(&#34;ssl&#34;)
        expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
        self.assertEqual(expected_contexts.get_with_name(&#34;ssl&#34;).value,
                         loader.current_context)

    def test_ssl_with_relative_ssl_files(self):
        expected = FakeConfig(
            host=TEST_SSL_HOST,
            token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
            cert_file=self._create_temp_file(TEST_CLIENT_CERT),
            key_file=self._create_temp_file(TEST_CLIENT_KEY),
            ssl_ca_cert=self._create_temp_file(TEST_CERTIFICATE_AUTH)
        )
        try:
            temp_dir = tempfile.mkdtemp()
            actual = FakeConfig()
            with open(os.path.join(temp_dir, &#34;cert_test&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_CERTIFICATE_AUTH.encode())
            with open(os.path.join(temp_dir, &#34;client_cert&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_CLIENT_CERT.encode())
            with open(os.path.join(temp_dir, &#34;client_key&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_CLIENT_KEY.encode())
            with open(os.path.join(temp_dir, &#34;token_file&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_DATA_BASE64.encode())
            KubeConfigLoader(
                config_dict=self.TEST_KUBE_CONFIG,
                active_context=&#34;ssl-local-file&#34;,
                config_base_path=temp_dir).load_and_set(actual)
            self.assertEqual(expected, actual)
        finally:
            shutil.rmtree(temp_dir)

    def test_load_kube_config(self):
        expected = FakeConfig(host=TEST_HOST,
                              token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64)
        config_file = self._create_temp_file(
            yaml.safe_dump(self.TEST_KUBE_CONFIG))
        actual = FakeConfig()
        load_kube_config(config_file=config_file, context=&#34;simple_token&#34;,
                         client_configuration=actual)
        self.assertEqual(expected, actual)

    def test_list_kube_config_contexts(self):
        config_file = self._create_temp_file(
            yaml.safe_dump(self.TEST_KUBE_CONFIG))
        contexts, active_context = list_kube_config_contexts(
            config_file=config_file)
        self.assertDictEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;][0],
                             active_context)
        if PY3:
            self.assertCountEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;],
                                  contexts)
        else:
            self.assertItemsEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;],
                                  contexts)

    def test_new_client_from_config(self):
        config_file = self._create_temp_file(
            yaml.safe_dump(self.TEST_KUBE_CONFIG))
        client = new_client_from_config(
            config_file=config_file, context=&#34;simple_token&#34;)
        self.assertEqual(TEST_HOST, client.configuration.host)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         client.configuration.api_key[&#39;authorization&#39;])

    def test_no_users_section(self):
        expected = FakeConfig(host=TEST_HOST)
        actual = FakeConfig()
        test_kube_config = self.TEST_KUBE_CONFIG.copy()
        del test_kube_config[&#39;users&#39;]
        KubeConfigLoader(
            config_dict=test_kube_config,
            active_context=&#34;gcp&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_non_existing_user(self):
        expected = FakeConfig(host=TEST_HOST)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;non_existing_user&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    @mock.patch(&#39;kubernetes.config.kube_config.ExecProvider.run&#39;)
    def test_user_exec_auth(self, mock):
        token = &#34;dummy&#34;
        mock.return_value = {
            &#34;token&#34;: token
        }
        expected = FakeConfig(host=TEST_HOST, api_key={
                              &#34;authorization&#34;: BEARER_TOKEN_FORMAT % token})
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;exec_cred_user&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)


class TestKubernetesClientConfiguration(BaseTestCase):
    # Verifies properties of kubernetes.client.Configuration.
    # These tests guard against changes to the upstream configuration class,
    # since GCP authorization overrides get_api_key_with_prefix to refresh its
    # token regularly.

    def test_get_api_key_with_prefix_exists(self):
        self.assertTrue(hasattr(Configuration, &#39;get_api_key_with_prefix&#39;))

    def test_get_api_key_with_prefix_returns_token(self):
        expected_token = &#39;expected_token&#39;
        config = Configuration()
        config.api_key[&#39;authorization&#39;] = expected_token
        self.assertEqual(expected_token,
                         config.get_api_key_with_prefix(&#39;authorization&#39;))

    def test_auth_settings_calls_get_api_key_with_prefix(self):
        expected_token = &#39;expected_token&#39;

        def fake_get_api_key_with_prefix(identifier):
            self.assertEqual(&#39;authorization&#39;, identifier)
            return expected_token
        config = Configuration()
        config.get_api_key_with_prefix = fake_get_api_key_with_prefix
        self.assertEqual(expected_token,
                         config.auth_settings()[&#39;BearerToken&#39;][&#39;value&#39;])


class TestKubeConfigMerger(BaseTestCase):
    TEST_KUBE_CONFIG_PART1 = {
        &#34;current-context&#34;: &#34;no_user&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;no_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
            {
                &#34;name&#34;: &#34;default&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_HOST
                }
            },
        ],
        &#34;users&#34;: []
    }

    TEST_KUBE_CONFIG_PART2 = {
        &#34;current-context&#34;: &#34;&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl&#34;,
                    &#34;user&#34;: &#34;ssl&#34;
                }
            },
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;simple_token&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority-data&#34;:
                        TEST_CERTIFICATE_AUTH_BASE64,
                }
            },
        ],
        &#34;users&#34;: [
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;client-certificate-data&#34;: TEST_CLIENT_CERT_BASE64,
                    &#34;client-key-data&#34;: TEST_CLIENT_KEY_BASE64,
                }
            },
        ]
    }

    TEST_KUBE_CONFIG_PART3 = {
        &#34;current-context&#34;: &#34;no_user&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_oidc&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;skipped-part2-defined-this-context&#34;,
                    &#34;user&#34;: &#34;skipped&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
        ],
        &#34;users&#34;: [
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_EXPIRED_LOGIN,
                            &#34;idp-certificate-authority-data&#34;: TEST_OIDC_CA,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
        ]
    }

    def _create_multi_config(self):
        files = []
        for part in (
                self.TEST_KUBE_CONFIG_PART1,
                self.TEST_KUBE_CONFIG_PART2,
                self.TEST_KUBE_CONFIG_PART3):
            files.append(self._create_temp_file(yaml.safe_dump(part)))
        return ENV_KUBECONFIG_PATH_SEPARATOR.join(files)

    def test_list_kube_config_contexts(self):
        kubeconfigs = self._create_multi_config()
        expected_contexts = [
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;}, &#39;name&#39;: &#39;no_user&#39;},
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;ssl&#39;, &#39;user&#39;: &#39;ssl&#39;}, &#39;name&#39;: &#39;ssl&#39;},
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;, &#39;user&#39;: &#39;simple_token&#39;},
             &#39;name&#39;: &#39;simple_token&#39;},
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;, &#39;user&#39;: &#39;expired_oidc&#39;}, &#39;name&#39;: &#39;expired_oidc&#39;}]

        contexts, active_context = list_kube_config_contexts(
            config_file=kubeconfigs)

        self.assertEqual(contexts, expected_contexts)
        self.assertEqual(active_context, expected_contexts[0])

    def test_new_client_from_config(self):
        kubeconfigs = self._create_multi_config()
        client = new_client_from_config(
            config_file=kubeconfigs, context=&#34;simple_token&#34;)
        self.assertEqual(TEST_HOST, client.configuration.host)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         client.configuration.api_key[&#39;authorization&#39;])

    def test_save_changes(self):
        kubeconfigs = self._create_multi_config()

        # load configuration, update token, save config
        kconf = KubeConfigMerger(kubeconfigs)
        user = kconf.config[&#39;users&#39;].get_with_name(&#39;expired_oidc&#39;)[&#39;user&#39;]
        provider = user[&#39;auth-provider&#39;][&#39;config&#39;]
        provider.value[&#39;id-token&#39;] = &#34;token-changed&#34;
        kconf.save_changes()

        # re-read configuration
        kconf = KubeConfigMerger(kubeconfigs)
        user = kconf.config[&#39;users&#39;].get_with_name(&#39;expired_oidc&#39;)[&#39;user&#39;]
        provider = user[&#39;auth-provider&#39;][&#39;config&#39;]

        # new token
        self.assertEqual(provider.value[&#39;id-token&#39;], &#34;token-changed&#34;)


if __name__ == &#39;__main__&#39;:
    unittest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kubernetes.config.kube_config_test.BaseTestCase"><code class="flex name class">
<span>class <span class="ident">BaseTestCase</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseTestCase(unittest.TestCase):

    def setUp(self):
        self._temp_files = []

    def tearDown(self):
        for f in self._temp_files:
            os.remove(f)

    def _create_temp_file(self, content=&#34;&#34;):
        handler, name = tempfile.mkstemp()
        self._temp_files.append(name)
        os.write(handler, str.encode(content))
        os.close(handler)
        return name

    def expect_exception(self, func, message_part, *args, **kwargs):
        with self.assertRaises(ConfigException) as context:
            func(*args, **kwargs)
        self.assertIn(message_part, str(context.exception))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="kubernetes.config.kube_config_test.TestConfigNode" href="#kubernetes.config.kube_config_test.TestConfigNode">TestConfigNode</a></li>
<li><a title="kubernetes.config.kube_config_test.TestFileOrData" href="#kubernetes.config.kube_config_test.TestFileOrData">TestFileOrData</a></li>
<li><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader">TestKubeConfigLoader</a></li>
<li><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger">TestKubeConfigMerger</a></li>
<li><a title="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration" href="#kubernetes.config.kube_config_test.TestKubernetesClientConfiguration">TestKubernetesClientConfiguration</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.BaseTestCase.expect_exception"><code class="name flex">
<span>def <span class="ident">expect_exception</span></span>(<span>self, func, message_part, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_exception(self, func, message_part, *args, **kwargs):
    with self.assertRaises(ConfigException) as context:
        func(*args, **kwargs)
    self.assertIn(message_part, str(context.exception))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.BaseTestCase.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    self._temp_files = []</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.BaseTestCase.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self):
    for f in self._temp_files:
        os.remove(f)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="kubernetes.config.kube_config_test.FakeConfig"><code class="flex name class">
<span>class <span class="ident">FakeConfig</span></span>
<span>(</span><span>token=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FakeConfig:

    FILE_KEYS = [&#34;ssl_ca_cert&#34;, &#34;key_file&#34;, &#34;cert_file&#34;]

    def __init__(self, token=None, **kwargs):
        self.api_key = {}
        if token:
            self.api_key[&#39;authorization&#39;] = token

        self.__dict__.update(kwargs)

    def __eq__(self, other):
        if len(self.__dict__) != len(other.__dict__):
            return
        for k, v in self.__dict__.items():
            if k not in other.__dict__:
                return
            if k in self.FILE_KEYS:
                if v and other.__dict__[k]:
                    try:
                        with open(v) as f1, open(other.__dict__[k]) as f2:
                            if f1.read() != f2.read():
                                return
                    except IOError:
                        # fall back to only compare filenames in case we are
                        # testing the passing of filenames to the config
                        if other.__dict__[k] != v:
                            return
                else:
                    if other.__dict__[k] != v:
                        return
            else:
                if other.__dict__[k] != v:
                    return
        return True

    def __repr__(self):
        rep = &#34;\n&#34;
        for k, v in self.__dict__.items():
            val = v
            if k in self.FILE_KEYS:
                try:
                    with open(v) as f:
                        val = &#34;FILE: %s&#34; % str.decode(f.read())
                except IOError as e:
                    val = &#34;ERROR: %s&#34; % str(e)
            rep += &#34;\t%s: %s\n&#34; % (k, val)
        return &#34;Config(%s\n)&#34; % rep</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.FakeConfig.FILE_KEYS"><code class="name">var <span class="ident">FILE_KEYS</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
</dl>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode"><code class="flex name class">
<span>class <span class="ident">TestConfigNode</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestConfigNode(BaseTestCase):

    test_obj = {&#34;key1&#34;: &#34;test&#34;, &#34;key2&#34;: [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;],
                &#34;key3&#34;: {&#34;inner_key&#34;: &#34;inner_value&#34;},
                &#34;with_names&#34;: [{&#34;name&#34;: &#34;test_name&#34;, &#34;value&#34;: &#34;test_value&#34;},
                               {&#34;name&#34;: &#34;test_name2&#34;,
                                &#34;value&#34;: {&#34;key1&#34;, &#34;test&#34;}},
                               {&#34;name&#34;: &#34;test_name3&#34;, &#34;value&#34;: [1, 2, 3]}],
                &#34;with_names_dup&#34;: [
                    {&#34;name&#34;: &#34;test_name&#34;, &#34;value&#34;: &#34;test_value&#34;},
                    {&#34;name&#34;: &#34;test_name&#34;,
                     &#34;value&#34;: {&#34;key1&#34;, &#34;test&#34;}},
                    {&#34;name&#34;: &#34;test_name3&#34;, &#34;value&#34;: [1, 2, 3]}
    ]}

    def setUp(self):
        super(TestConfigNode, self).setUp()
        self.node = ConfigNode(&#34;test_obj&#34;, self.test_obj)

    def test_normal_map_array_operations(self):
        self.assertEqual(&#34;test&#34;, self.node[&#39;key1&#39;])
        self.assertEqual(5, len(self.node))

        self.assertEqual(&#34;test_obj/key2&#34;, self.node[&#39;key2&#39;].name)
        self.assertEqual([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;], self.node[&#39;key2&#39;].value)
        self.assertEqual(&#34;b&#34;, self.node[&#39;key2&#39;][1])
        self.assertEqual(3, len(self.node[&#39;key2&#39;]))

        self.assertEqual(&#34;test_obj/key3&#34;, self.node[&#39;key3&#39;].name)
        self.assertEqual({&#34;inner_key&#34;: &#34;inner_value&#34;},
                         self.node[&#39;key3&#39;].value)
        self.assertEqual(&#34;inner_value&#34;, self.node[&#39;key3&#39;][&#34;inner_key&#34;])
        self.assertEqual(1, len(self.node[&#39;key3&#39;]))

    def test_get_with_name(self):
        node = self.node[&#34;with_names&#34;]
        self.assertEqual(
            &#34;test_value&#34;,
            node.get_with_name(&#34;test_name&#34;)[&#34;value&#34;])
        self.assertTrue(
            isinstance(node.get_with_name(&#34;test_name2&#34;), ConfigNode))
        self.assertTrue(
            isinstance(node.get_with_name(&#34;test_name3&#34;), ConfigNode))
        self.assertEqual(&#34;test_obj/with_names[name=test_name2]&#34;,
                         node.get_with_name(&#34;test_name2&#34;).name)
        self.assertEqual(&#34;test_obj/with_names[name=test_name3]&#34;,
                         node.get_with_name(&#34;test_name3&#34;).name)

    def test_key_does_not_exists(self):
        self.expect_exception(lambda: self.node[&#39;not-exists-key&#39;],
                              &#34;Expected key not-exists-key in test_obj&#34;)
        self.expect_exception(lambda: self.node[&#39;key3&#39;][&#39;not-exists-key&#39;],
                              &#34;Expected key not-exists-key in test_obj/key3&#34;)

    def test_get_with_name_on_invalid_object(self):
        self.expect_exception(
            lambda: self.node[&#39;key2&#39;].get_with_name(&#39;no-name&#39;),
            &#34;Expected all values in test_obj/key2 list to have \&#39;name\&#39; key&#34;)

    def test_get_with_name_on_non_list_object(self):
        self.expect_exception(
            lambda: self.node[&#39;key3&#39;].get_with_name(&#39;no-name&#39;),
            &#34;Expected test_obj/key3 to be a list&#34;)

    def test_get_with_name_on_name_does_not_exists(self):
        self.expect_exception(
            lambda: self.node[&#39;with_names&#39;].get_with_name(&#39;no-name&#39;),
            &#34;Expected object with name no-name in test_obj/with_names list&#34;)

    def test_get_with_name_on_duplicate_name(self):
        self.expect_exception(
            lambda: self.node[&#39;with_names_dup&#39;].get_with_name(&#39;test_name&#39;),
            &#34;Expected only one object with name test_name in &#34;
            &#34;test_obj/with_names_dup list&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_obj"><code class="name">var <span class="ident">test_obj</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name"><code class="name flex">
<span>def <span class="ident">test_get_with_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_with_name(self):
    node = self.node[&#34;with_names&#34;]
    self.assertEqual(
        &#34;test_value&#34;,
        node.get_with_name(&#34;test_name&#34;)[&#34;value&#34;])
    self.assertTrue(
        isinstance(node.get_with_name(&#34;test_name2&#34;), ConfigNode))
    self.assertTrue(
        isinstance(node.get_with_name(&#34;test_name3&#34;), ConfigNode))
    self.assertEqual(&#34;test_obj/with_names[name=test_name2]&#34;,
                     node.get_with_name(&#34;test_name2&#34;).name)
    self.assertEqual(&#34;test_obj/with_names[name=test_name3]&#34;,
                     node.get_with_name(&#34;test_name3&#34;).name)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_duplicate_name"><code class="name flex">
<span>def <span class="ident">test_get_with_name_on_duplicate_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_with_name_on_duplicate_name(self):
    self.expect_exception(
        lambda: self.node[&#39;with_names_dup&#39;].get_with_name(&#39;test_name&#39;),
        &#34;Expected only one object with name test_name in &#34;
        &#34;test_obj/with_names_dup list&#34;)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_invalid_object"><code class="name flex">
<span>def <span class="ident">test_get_with_name_on_invalid_object</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_with_name_on_invalid_object(self):
    self.expect_exception(
        lambda: self.node[&#39;key2&#39;].get_with_name(&#39;no-name&#39;),
        &#34;Expected all values in test_obj/key2 list to have \&#39;name\&#39; key&#34;)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_name_does_not_exists"><code class="name flex">
<span>def <span class="ident">test_get_with_name_on_name_does_not_exists</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_with_name_on_name_does_not_exists(self):
    self.expect_exception(
        lambda: self.node[&#39;with_names&#39;].get_with_name(&#39;no-name&#39;),
        &#34;Expected object with name no-name in test_obj/with_names list&#34;)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_non_list_object"><code class="name flex">
<span>def <span class="ident">test_get_with_name_on_non_list_object</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_with_name_on_non_list_object(self):
    self.expect_exception(
        lambda: self.node[&#39;key3&#39;].get_with_name(&#39;no-name&#39;),
        &#34;Expected test_obj/key3 to be a list&#34;)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_key_does_not_exists"><code class="name flex">
<span>def <span class="ident">test_key_does_not_exists</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_key_does_not_exists(self):
    self.expect_exception(lambda: self.node[&#39;not-exists-key&#39;],
                          &#34;Expected key not-exists-key in test_obj&#34;)
    self.expect_exception(lambda: self.node[&#39;key3&#39;][&#39;not-exists-key&#39;],
                          &#34;Expected key not-exists-key in test_obj/key3&#34;)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestConfigNode.test_normal_map_array_operations"><code class="name flex">
<span>def <span class="ident">test_normal_map_array_operations</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_normal_map_array_operations(self):
    self.assertEqual(&#34;test&#34;, self.node[&#39;key1&#39;])
    self.assertEqual(5, len(self.node))

    self.assertEqual(&#34;test_obj/key2&#34;, self.node[&#39;key2&#39;].name)
    self.assertEqual([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;], self.node[&#39;key2&#39;].value)
    self.assertEqual(&#34;b&#34;, self.node[&#39;key2&#39;][1])
    self.assertEqual(3, len(self.node[&#39;key2&#39;]))

    self.assertEqual(&#34;test_obj/key3&#34;, self.node[&#39;key3&#39;].name)
    self.assertEqual({&#34;inner_key&#34;: &#34;inner_value&#34;},
                     self.node[&#39;key3&#39;].value)
    self.assertEqual(&#34;inner_value&#34;, self.node[&#39;key3&#39;][&#34;inner_key&#34;])
    self.assertEqual(1, len(self.node[&#39;key3&#39;]))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.setUp" href="#kubernetes.config.kube_config_test.BaseTestCase.setUp">setUp</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.tearDown" href="#kubernetes.config.kube_config_test.BaseTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData"><code class="flex name class">
<span>class <span class="ident">TestFileOrData</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestFileOrData(BaseTestCase):

    @staticmethod
    def get_file_content(filename):
        with open(filename) as f:
            return f.read()

    def test_file_given_file(self):
        temp_filename = _create_temp_file_with_content(TEST_DATA)
        obj = {TEST_FILE_KEY: temp_filename}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_given_non_existing_file(self):
        temp_filename = NON_EXISTING_FILE
        obj = {TEST_FILE_KEY: temp_filename}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
        self.expect_exception(t.as_file, &#34;does not exists&#34;)

    def test_file_given_data(self):
        obj = {TEST_DATA_KEY: TEST_DATA_BASE64}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_given_data_no_base64(self):
        obj = {TEST_DATA_KEY: TEST_DATA}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY, base64_file_content=False)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_data_given_data(self):
        obj = {TEST_DATA_KEY: TEST_DATA_BASE64}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA_BASE64, t.as_data())

    def test_data_given_file(self):
        obj = {
            TEST_FILE_KEY: self._create_temp_file(content=TEST_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
        self.assertEqual(TEST_DATA_BASE64, t.as_data())

    def test_data_given_file_no_base64(self):
        obj = {
            TEST_FILE_KEY: self._create_temp_file(content=TEST_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       base64_file_content=False)
        self.assertEqual(TEST_DATA, t.as_data())

    def test_data_given_file_and_data(self):
        obj = {
            TEST_DATA_KEY: TEST_DATA_BASE64,
            TEST_FILE_KEY: self._create_temp_file(
                content=TEST_ANOTHER_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA_BASE64, t.as_data())

    def test_file_given_file_and_data(self):
        obj = {
            TEST_DATA_KEY: TEST_DATA_BASE64,
            TEST_FILE_KEY: self._create_temp_file(
                content=TEST_ANOTHER_DATA)}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_with_custom_dirname(self):
        tempfile = self._create_temp_file(content=TEST_DATA)
        tempfile_dir = os.path.dirname(tempfile)
        tempfile_basename = os.path.basename(tempfile)
        obj = {TEST_FILE_KEY: tempfile_basename}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       file_base_path=tempfile_dir)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_create_temp_file_with_content(self):
        self.assertEqual(TEST_DATA,
                         self.get_file_content(
                             _create_temp_file_with_content(TEST_DATA)))
        _cleanup_temp_files()

    def test_file_given_data_bytes(self):
        obj = {TEST_DATA_KEY: TEST_DATA_BASE64.encode()}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))

    def test_file_given_data_bytes_no_base64(self):
        obj = {TEST_DATA_KEY: TEST_DATA.encode()}
        t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                       data_key_name=TEST_DATA_KEY, base64_file_content=False)
        self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.get_file_content"><code class="name flex">
<span>def <span class="ident">get_file_content</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_file_content(filename):
    with open(filename) as f:
        return f.read()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_create_temp_file_with_content"><code class="name flex">
<span>def <span class="ident">test_create_temp_file_with_content</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_create_temp_file_with_content(self):
    self.assertEqual(TEST_DATA,
                     self.get_file_content(
                         _create_temp_file_with_content(TEST_DATA)))
    _cleanup_temp_files()</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_data"><code class="name flex">
<span>def <span class="ident">test_data_given_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_data_given_data(self):
    obj = {TEST_DATA_KEY: TEST_DATA_BASE64}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY)
    self.assertEqual(TEST_DATA_BASE64, t.as_data())</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file"><code class="name flex">
<span>def <span class="ident">test_data_given_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_data_given_file(self):
    obj = {
        TEST_FILE_KEY: self._create_temp_file(content=TEST_DATA)}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
    self.assertEqual(TEST_DATA_BASE64, t.as_data())</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file_and_data"><code class="name flex">
<span>def <span class="ident">test_data_given_file_and_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_data_given_file_and_data(self):
    obj = {
        TEST_DATA_KEY: TEST_DATA_BASE64,
        TEST_FILE_KEY: self._create_temp_file(
            content=TEST_ANOTHER_DATA)}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY)
    self.assertEqual(TEST_DATA_BASE64, t.as_data())</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file_no_base64"><code class="name flex">
<span>def <span class="ident">test_data_given_file_no_base64</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_data_given_file_no_base64(self):
    obj = {
        TEST_FILE_KEY: self._create_temp_file(content=TEST_DATA)}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   base64_file_content=False)
    self.assertEqual(TEST_DATA, t.as_data())</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data"><code class="name flex">
<span>def <span class="ident">test_file_given_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_data(self):
    obj = {TEST_DATA_KEY: TEST_DATA_BASE64}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_bytes"><code class="name flex">
<span>def <span class="ident">test_file_given_data_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_data_bytes(self):
    obj = {TEST_DATA_KEY: TEST_DATA_BASE64.encode()}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_bytes_no_base64"><code class="name flex">
<span>def <span class="ident">test_file_given_data_bytes_no_base64</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_data_bytes_no_base64(self):
    obj = {TEST_DATA_KEY: TEST_DATA.encode()}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY, base64_file_content=False)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_no_base64"><code class="name flex">
<span>def <span class="ident">test_file_given_data_no_base64</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_data_no_base64(self):
    obj = {TEST_DATA_KEY: TEST_DATA}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY, base64_file_content=False)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_file"><code class="name flex">
<span>def <span class="ident">test_file_given_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_file(self):
    temp_filename = _create_temp_file_with_content(TEST_DATA)
    obj = {TEST_FILE_KEY: temp_filename}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_file_and_data"><code class="name flex">
<span>def <span class="ident">test_file_given_file_and_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_file_and_data(self):
    obj = {
        TEST_DATA_KEY: TEST_DATA_BASE64,
        TEST_FILE_KEY: self._create_temp_file(
            content=TEST_ANOTHER_DATA)}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   data_key_name=TEST_DATA_KEY)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_non_existing_file"><code class="name flex">
<span>def <span class="ident">test_file_given_non_existing_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_given_non_existing_file(self):
    temp_filename = NON_EXISTING_FILE
    obj = {TEST_FILE_KEY: temp_filename}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY)
    self.expect_exception(t.as_file, &#34;does not exists&#34;)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestFileOrData.test_file_with_custom_dirname"><code class="name flex">
<span>def <span class="ident">test_file_with_custom_dirname</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_file_with_custom_dirname(self):
    tempfile = self._create_temp_file(content=TEST_DATA)
    tempfile_dir = os.path.dirname(tempfile)
    tempfile_basename = os.path.basename(tempfile)
    obj = {TEST_FILE_KEY: tempfile_basename}
    t = FileOrData(obj=obj, file_key_name=TEST_FILE_KEY,
                   file_base_path=tempfile_dir)
    self.assertEqual(TEST_DATA, self.get_file_content(t.as_file()))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.setUp" href="#kubernetes.config.kube_config_test.BaseTestCase.setUp">setUp</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.tearDown" href="#kubernetes.config.kube_config_test.BaseTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader"><code class="flex name class">
<span>class <span class="ident">TestKubeConfigLoader</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestKubeConfigLoader(BaseTestCase):
    TEST_KUBE_CONFIG = {
        &#34;current-context&#34;: &#34;no_user&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;no_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;
                }
            },
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;simple_token&#34;
                }
            },
            {
                &#34;name&#34;: &#34;gcp&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;gcp&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_gcp&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_gcp&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_gcp_refresh&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_gcp_refresh&#34;
                }
            },
            {
                &#34;name&#34;: &#34;oidc&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;oidc&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_oidc&#34;
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc_nocert&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_oidc_nocert&#34;
                }
            },
            {
                &#34;name&#34;: &#34;oidc_contains_reserved_character&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;oidc_contains_reserved_character&#34;

                }
            },
            {
                &#34;name&#34;: &#34;oidc_invalid_padding_length&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;oidc_invalid_padding_length&#34;

                }
            },
            {
                &#34;name&#34;: &#34;user_pass&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;user_pass&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl&#34;,
                    &#34;user&#34;: &#34;ssl&#34;
                }
            },
            {
                &#34;name&#34;: &#34;no_ssl_verification&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;no_ssl_verification&#34;,
                    &#34;user&#34;: &#34;ssl&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl-no_file&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl-no_file&#34;,
                    &#34;user&#34;: &#34;ssl-no_file&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl-local-file&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl-local-file&#34;,
                    &#34;user&#34;: &#34;ssl-local-file&#34;
                }
            },
            {
                &#34;name&#34;: &#34;non_existing_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;non_existing_user&#34;
                }
            },
            {
                &#34;name&#34;: &#34;exec_cred_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;exec_cred_user&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
            {
                &#34;name&#34;: &#34;default&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_HOST
                }
            },
            {
                &#34;name&#34;: &#34;ssl-no_file&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority&#34;: TEST_CERTIFICATE_AUTH,
                }
            },
            {
                &#34;name&#34;: &#34;ssl-local-file&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority&#34;: &#34;cert_test&#34;,
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority-data&#34;:
                        TEST_CERTIFICATE_AUTH_BASE64,
                }
            },
            {
                &#34;name&#34;: &#34;no_ssl_verification&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;insecure-skip-tls-verify&#34;: &#34;true&#34;,
                }
            },
        ],
        &#34;users&#34;: [
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;gcp&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;gcp&#34;,
                        &#34;config&#34;: {
                            &#34;access-token&#34;: TEST_DATA_BASE64,
                        }
                    },
                    &#34;token&#34;: TEST_DATA_BASE64,  # should be ignored
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;expired_gcp&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;gcp&#34;,
                        &#34;config&#34;: {
                            &#34;access-token&#34;: TEST_DATA_BASE64,
                            &#34;expiry&#34;: TEST_TOKEN_EXPIRY_PAST,  # always in past
                        }
                    },
                    &#34;token&#34;: TEST_DATA_BASE64,  # should be ignored
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            # Duplicated from &#34;expired_gcp&#34; so test_load_gcp_token_with_refresh
            # is isolated from test_gcp_get_api_key_with_prefix.
            {
                &#34;name&#34;: &#34;expired_gcp_refresh&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;gcp&#34;,
                        &#34;config&#34;: {
                            &#34;access-token&#34;: TEST_DATA_BASE64,
                            &#34;expiry&#34;: TEST_TOKEN_EXPIRY_PAST,  # always in past
                        }
                    },
                    &#34;token&#34;: TEST_DATA_BASE64,  # should be ignored
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;oidc&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;id-token&#34;: TEST_OIDC_LOGIN
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_EXPIRED_LOGIN,
                            &#34;idp-certificate-authority-data&#34;: TEST_OIDC_CA,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;expired_oidc_nocert&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_EXPIRED_LOGIN,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;oidc_contains_reserved_character&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_CONTAINS_RESERVED_CHARACTERS,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;oidc_invalid_padding_length&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_INVALID_PADDING_LENGTH,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;user_pass&#34;,
                &#34;user&#34;: {
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
            {
                &#34;name&#34;: &#34;ssl-no_file&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;client-certificate&#34;: TEST_CLIENT_CERT,
                    &#34;client-key&#34;: TEST_CLIENT_KEY,
                }
            },
            {
                &#34;name&#34;: &#34;ssl-local-file&#34;,
                &#34;user&#34;: {
                    &#34;tokenFile&#34;: &#34;token_file&#34;,
                    &#34;client-certificate&#34;: &#34;client_cert&#34;,
                    &#34;client-key&#34;: &#34;client_key&#34;,
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;client-certificate-data&#34;: TEST_CLIENT_CERT_BASE64,
                    &#34;client-key-data&#34;: TEST_CLIENT_KEY_BASE64,
                }
            },
            {
                &#34;name&#34;: &#34;exec_cred_user&#34;,
                &#34;user&#34;: {
                    &#34;exec&#34;: {
                        &#34;apiVersion&#34;: &#34;client.authentication.k8s.io/v1beta1&#34;,
                        &#34;command&#34;: &#34;aws-iam-authenticator&#34;,
                        &#34;args&#34;: [&#34;token&#34;, &#34;-i&#34;, &#34;dummy-cluster&#34;]
                    }
                }
            },
        ]
    }

    def test_no_user_context(self):
        expected = FakeConfig(host=TEST_HOST)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;no_user&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_simple_token(self):
        expected = FakeConfig(host=TEST_HOST,
                              token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;simple_token&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_load_user_token(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;simple_token&#34;)
        self.assertTrue(loader._load_user_token())
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64, loader.token)

    def test_gcp_no_refresh(self):
        fake_config = FakeConfig()
        # swagger-generated config has this, but FakeConfig does not.
        self.assertFalse(hasattr(fake_config, &#39;get_api_key_with_prefix&#39;))
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;gcp&#34;,
            get_google_credentials=lambda: _raise_exception(
                &#34;SHOULD NOT BE CALLED&#34;)).load_and_set(fake_config)
        # Should now be populated with a gcp token fetcher.
        self.assertIsNotNone(fake_config.get_api_key_with_prefix)
        self.assertEqual(TEST_HOST, fake_config.host)
        # For backwards compatibility, authorization field should still be set.
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         fake_config.api_key[&#39;authorization&#39;])

    def test_load_gcp_token_no_refresh(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;gcp&#34;,
            get_google_credentials=lambda: _raise_exception(
                &#34;SHOULD NOT BE CALLED&#34;))
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         loader.token)

    def test_load_gcp_token_with_refresh(self):
        def cred(): return None
        cred.token = TEST_ANOTHER_DATA_BASE64
        cred.expiry = datetime.datetime.utcnow()

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_gcp&#34;,
            get_google_credentials=lambda: cred)
        original_expiry = _get_expiry(loader, &#34;expired_gcp&#34;)
        self.assertTrue(loader._load_auth_provider_token())
        new_expiry = _get_expiry(loader, &#34;expired_gcp&#34;)
        # assert that the configs expiry actually updates
        self.assertTrue(new_expiry &gt; original_expiry)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                         loader.token)

    def test_gcp_get_api_key_with_prefix(self):
        class cred_old:
            token = TEST_DATA_BASE64
            expiry = DATETIME_EXPIRY_PAST

        class cred_new:
            token = TEST_ANOTHER_DATA_BASE64
            expiry = DATETIME_EXPIRY_FUTURE
        fake_config = FakeConfig()
        _get_google_credentials = mock.Mock()
        _get_google_credentials.side_effect = [cred_old, cred_new]

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_gcp_refresh&#34;,
            get_google_credentials=_get_google_credentials)
        loader.load_and_set(fake_config)
        original_expiry = _get_expiry(loader, &#34;expired_gcp_refresh&#34;)
        # Call GCP token fetcher.
        token = fake_config.get_api_key_with_prefix()
        new_expiry = _get_expiry(loader, &#34;expired_gcp_refresh&#34;)

        self.assertTrue(new_expiry &gt; original_expiry)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                         loader.token)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                         token)

    def test_oidc_no_refresh(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;oidc&#34;,
        )
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(TEST_OIDC_TOKEN, loader.token)

    @mock.patch(&#39;kubernetes.config.kube_config.OAuth2Session.refresh_token&#39;)
    @mock.patch(&#39;kubernetes.config.kube_config.ApiClient.request&#39;)
    def test_oidc_with_refresh(self, mock_ApiClient, mock_OAuth2Session):
        mock_response = mock.MagicMock()
        type(mock_response).status = mock.PropertyMock(
            return_value=200
        )
        type(mock_response).data = mock.PropertyMock(
            return_value=json.dumps({
                &#34;token_endpoint&#34;: &#34;https://example.org/identity/token&#34;
            })
        )

        mock_ApiClient.return_value = mock_response

        mock_OAuth2Session.return_value = {&#34;id_token&#34;: &#34;abc123&#34;,
                                           &#34;refresh_token&#34;: &#34;newtoken123&#34;}

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_oidc&#34;,
        )
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(&#34;Bearer abc123&#34;, loader.token)

    @mock.patch(&#39;kubernetes.config.kube_config.OAuth2Session.refresh_token&#39;)
    @mock.patch(&#39;kubernetes.config.kube_config.ApiClient.request&#39;)
    def test_oidc_with_refresh_nocert(
            self, mock_ApiClient, mock_OAuth2Session):
        mock_response = mock.MagicMock()
        type(mock_response).status = mock.PropertyMock(
            return_value=200
        )
        type(mock_response).data = mock.PropertyMock(
            return_value=json.dumps({
                &#34;token_endpoint&#34;: &#34;https://example.org/identity/token&#34;
            })
        )

        mock_ApiClient.return_value = mock_response

        mock_OAuth2Session.return_value = {&#34;id_token&#34;: &#34;abc123&#34;,
                                           &#34;refresh_token&#34;: &#34;newtoken123&#34;}

        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;expired_oidc_nocert&#34;,
        )
        self.assertTrue(loader._load_auth_provider_token())
        self.assertEqual(&#34;Bearer abc123&#34;, loader.token)

    def test_oidc_fails_if_contains_reserved_chars(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;oidc_contains_reserved_character&#34;,
        )
        self.assertEqual(
            loader._load_oid_token(&#34;oidc_contains_reserved_character&#34;),
            None,
        )

    def test_oidc_fails_if_invalid_padding_length(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;oidc_invalid_padding_length&#34;,
        )
        self.assertEqual(
            loader._load_oid_token(&#34;oidc_invalid_padding_length&#34;),
            None,
        )

    def test_user_pass(self):
        expected = FakeConfig(host=TEST_HOST, token=TEST_BASIC_TOKEN)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;user_pass&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_load_user_pass_token(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;user_pass&#34;)
        self.assertTrue(loader._load_user_pass_token())
        self.assertEqual(TEST_BASIC_TOKEN, loader.token)

    def test_ssl_no_cert_files(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;ssl-no_file&#34;)
        self.expect_exception(
            loader.load_and_set,
            &#34;does not exists&#34;,
            FakeConfig())

    def test_ssl(self):
        expected = FakeConfig(
            host=TEST_SSL_HOST,
            token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
            cert_file=self._create_temp_file(TEST_CLIENT_CERT),
            key_file=self._create_temp_file(TEST_CLIENT_KEY),
            ssl_ca_cert=self._create_temp_file(TEST_CERTIFICATE_AUTH)
        )
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;ssl&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_ssl_no_verification(self):
        expected = FakeConfig(
            host=TEST_SSL_HOST,
            token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
            cert_file=self._create_temp_file(TEST_CLIENT_CERT),
            key_file=self._create_temp_file(TEST_CLIENT_KEY),
            verify_ssl=False,
            ssl_ca_cert=None,
        )
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;no_ssl_verification&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_list_contexts(self):
        loader = KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;no_user&#34;)
        actual_contexts = loader.list_contexts()
        expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
        for actual in actual_contexts:
            expected = expected_contexts.get_with_name(actual[&#39;name&#39;])
            self.assertEqual(expected.value, actual)

    def test_current_context(self):
        loader = KubeConfigLoader(config_dict=self.TEST_KUBE_CONFIG)
        expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
        self.assertEqual(expected_contexts.get_with_name(&#34;no_user&#34;).value,
                         loader.current_context)

    def test_set_active_context(self):
        loader = KubeConfigLoader(config_dict=self.TEST_KUBE_CONFIG)
        loader.set_active_context(&#34;ssl&#34;)
        expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
        self.assertEqual(expected_contexts.get_with_name(&#34;ssl&#34;).value,
                         loader.current_context)

    def test_ssl_with_relative_ssl_files(self):
        expected = FakeConfig(
            host=TEST_SSL_HOST,
            token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
            cert_file=self._create_temp_file(TEST_CLIENT_CERT),
            key_file=self._create_temp_file(TEST_CLIENT_KEY),
            ssl_ca_cert=self._create_temp_file(TEST_CERTIFICATE_AUTH)
        )
        try:
            temp_dir = tempfile.mkdtemp()
            actual = FakeConfig()
            with open(os.path.join(temp_dir, &#34;cert_test&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_CERTIFICATE_AUTH.encode())
            with open(os.path.join(temp_dir, &#34;client_cert&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_CLIENT_CERT.encode())
            with open(os.path.join(temp_dir, &#34;client_key&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_CLIENT_KEY.encode())
            with open(os.path.join(temp_dir, &#34;token_file&#34;), &#34;wb&#34;) as fd:
                fd.write(TEST_DATA_BASE64.encode())
            KubeConfigLoader(
                config_dict=self.TEST_KUBE_CONFIG,
                active_context=&#34;ssl-local-file&#34;,
                config_base_path=temp_dir).load_and_set(actual)
            self.assertEqual(expected, actual)
        finally:
            shutil.rmtree(temp_dir)

    def test_load_kube_config(self):
        expected = FakeConfig(host=TEST_HOST,
                              token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64)
        config_file = self._create_temp_file(
            yaml.safe_dump(self.TEST_KUBE_CONFIG))
        actual = FakeConfig()
        load_kube_config(config_file=config_file, context=&#34;simple_token&#34;,
                         client_configuration=actual)
        self.assertEqual(expected, actual)

    def test_list_kube_config_contexts(self):
        config_file = self._create_temp_file(
            yaml.safe_dump(self.TEST_KUBE_CONFIG))
        contexts, active_context = list_kube_config_contexts(
            config_file=config_file)
        self.assertDictEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;][0],
                             active_context)
        if PY3:
            self.assertCountEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;],
                                  contexts)
        else:
            self.assertItemsEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;],
                                  contexts)

    def test_new_client_from_config(self):
        config_file = self._create_temp_file(
            yaml.safe_dump(self.TEST_KUBE_CONFIG))
        client = new_client_from_config(
            config_file=config_file, context=&#34;simple_token&#34;)
        self.assertEqual(TEST_HOST, client.configuration.host)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         client.configuration.api_key[&#39;authorization&#39;])

    def test_no_users_section(self):
        expected = FakeConfig(host=TEST_HOST)
        actual = FakeConfig()
        test_kube_config = self.TEST_KUBE_CONFIG.copy()
        del test_kube_config[&#39;users&#39;]
        KubeConfigLoader(
            config_dict=test_kube_config,
            active_context=&#34;gcp&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    def test_non_existing_user(self):
        expected = FakeConfig(host=TEST_HOST)
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;non_existing_user&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)

    @mock.patch(&#39;kubernetes.config.kube_config.ExecProvider.run&#39;)
    def test_user_exec_auth(self, mock):
        token = &#34;dummy&#34;
        mock.return_value = {
            &#34;token&#34;: token
        }
        expected = FakeConfig(host=TEST_HOST, api_key={
                              &#34;authorization&#34;: BEARER_TOKEN_FORMAT % token})
        actual = FakeConfig()
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;exec_cred_user&#34;).load_and_set(actual)
        self.assertEqual(expected, actual)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.TEST_KUBE_CONFIG"><code class="name">var <span class="ident">TEST_KUBE_CONFIG</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_current_context"><code class="name flex">
<span>def <span class="ident">test_current_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_current_context(self):
    loader = KubeConfigLoader(config_dict=self.TEST_KUBE_CONFIG)
    expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
    self.assertEqual(expected_contexts.get_with_name(&#34;no_user&#34;).value,
                     loader.current_context)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_gcp_get_api_key_with_prefix"><code class="name flex">
<span>def <span class="ident">test_gcp_get_api_key_with_prefix</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_gcp_get_api_key_with_prefix(self):
    class cred_old:
        token = TEST_DATA_BASE64
        expiry = DATETIME_EXPIRY_PAST

    class cred_new:
        token = TEST_ANOTHER_DATA_BASE64
        expiry = DATETIME_EXPIRY_FUTURE
    fake_config = FakeConfig()
    _get_google_credentials = mock.Mock()
    _get_google_credentials.side_effect = [cred_old, cred_new]

    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;expired_gcp_refresh&#34;,
        get_google_credentials=_get_google_credentials)
    loader.load_and_set(fake_config)
    original_expiry = _get_expiry(loader, &#34;expired_gcp_refresh&#34;)
    # Call GCP token fetcher.
    token = fake_config.get_api_key_with_prefix()
    new_expiry = _get_expiry(loader, &#34;expired_gcp_refresh&#34;)

    self.assertTrue(new_expiry &gt; original_expiry)
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                     loader.token)
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                     token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_gcp_no_refresh"><code class="name flex">
<span>def <span class="ident">test_gcp_no_refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_gcp_no_refresh(self):
    fake_config = FakeConfig()
    # swagger-generated config has this, but FakeConfig does not.
    self.assertFalse(hasattr(fake_config, &#39;get_api_key_with_prefix&#39;))
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;gcp&#34;,
        get_google_credentials=lambda: _raise_exception(
            &#34;SHOULD NOT BE CALLED&#34;)).load_and_set(fake_config)
    # Should now be populated with a gcp token fetcher.
    self.assertIsNotNone(fake_config.get_api_key_with_prefix)
    self.assertEqual(TEST_HOST, fake_config.host)
    # For backwards compatibility, authorization field should still be set.
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                     fake_config.api_key[&#39;authorization&#39;])</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_list_contexts"><code class="name flex">
<span>def <span class="ident">test_list_contexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_contexts(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;no_user&#34;)
    actual_contexts = loader.list_contexts()
    expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
    for actual in actual_contexts:
        expected = expected_contexts.get_with_name(actual[&#39;name&#39;])
        self.assertEqual(expected.value, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_list_kube_config_contexts"><code class="name flex">
<span>def <span class="ident">test_list_kube_config_contexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_kube_config_contexts(self):
    config_file = self._create_temp_file(
        yaml.safe_dump(self.TEST_KUBE_CONFIG))
    contexts, active_context = list_kube_config_contexts(
        config_file=config_file)
    self.assertDictEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;][0],
                         active_context)
    if PY3:
        self.assertCountEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;],
                              contexts)
    else:
        self.assertItemsEqual(self.TEST_KUBE_CONFIG[&#39;contexts&#39;],
                              contexts)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_gcp_token_no_refresh"><code class="name flex">
<span>def <span class="ident">test_load_gcp_token_no_refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_load_gcp_token_no_refresh(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;gcp&#34;,
        get_google_credentials=lambda: _raise_exception(
            &#34;SHOULD NOT BE CALLED&#34;))
    self.assertTrue(loader._load_auth_provider_token())
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                     loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_gcp_token_with_refresh"><code class="name flex">
<span>def <span class="ident">test_load_gcp_token_with_refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_load_gcp_token_with_refresh(self):
    def cred(): return None
    cred.token = TEST_ANOTHER_DATA_BASE64
    cred.expiry = datetime.datetime.utcnow()

    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;expired_gcp&#34;,
        get_google_credentials=lambda: cred)
    original_expiry = _get_expiry(loader, &#34;expired_gcp&#34;)
    self.assertTrue(loader._load_auth_provider_token())
    new_expiry = _get_expiry(loader, &#34;expired_gcp&#34;)
    # assert that the configs expiry actually updates
    self.assertTrue(new_expiry &gt; original_expiry)
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_ANOTHER_DATA_BASE64,
                     loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_kube_config"><code class="name flex">
<span>def <span class="ident">test_load_kube_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_load_kube_config(self):
    expected = FakeConfig(host=TEST_HOST,
                          token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64)
    config_file = self._create_temp_file(
        yaml.safe_dump(self.TEST_KUBE_CONFIG))
    actual = FakeConfig()
    load_kube_config(config_file=config_file, context=&#34;simple_token&#34;,
                     client_configuration=actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_user_pass_token"><code class="name flex">
<span>def <span class="ident">test_load_user_pass_token</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_load_user_pass_token(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;user_pass&#34;)
    self.assertTrue(loader._load_user_pass_token())
    self.assertEqual(TEST_BASIC_TOKEN, loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_user_token"><code class="name flex">
<span>def <span class="ident">test_load_user_token</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_load_user_token(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;simple_token&#34;)
    self.assertTrue(loader._load_user_token())
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64, loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_new_client_from_config"><code class="name flex">
<span>def <span class="ident">test_new_client_from_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_new_client_from_config(self):
    config_file = self._create_temp_file(
        yaml.safe_dump(self.TEST_KUBE_CONFIG))
    client = new_client_from_config(
        config_file=config_file, context=&#34;simple_token&#34;)
    self.assertEqual(TEST_HOST, client.configuration.host)
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                     client.configuration.api_key[&#39;authorization&#39;])</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_no_user_context"><code class="name flex">
<span>def <span class="ident">test_no_user_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_no_user_context(self):
    expected = FakeConfig(host=TEST_HOST)
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;no_user&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_no_users_section"><code class="name flex">
<span>def <span class="ident">test_no_users_section</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_no_users_section(self):
    expected = FakeConfig(host=TEST_HOST)
    actual = FakeConfig()
    test_kube_config = self.TEST_KUBE_CONFIG.copy()
    del test_kube_config[&#39;users&#39;]
    KubeConfigLoader(
        config_dict=test_kube_config,
        active_context=&#34;gcp&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_non_existing_user"><code class="name flex">
<span>def <span class="ident">test_non_existing_user</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_non_existing_user(self):
    expected = FakeConfig(host=TEST_HOST)
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;non_existing_user&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_fails_if_contains_reserved_chars"><code class="name flex">
<span>def <span class="ident">test_oidc_fails_if_contains_reserved_chars</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_oidc_fails_if_contains_reserved_chars(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;oidc_contains_reserved_character&#34;,
    )
    self.assertEqual(
        loader._load_oid_token(&#34;oidc_contains_reserved_character&#34;),
        None,
    )</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_fails_if_invalid_padding_length"><code class="name flex">
<span>def <span class="ident">test_oidc_fails_if_invalid_padding_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_oidc_fails_if_invalid_padding_length(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;oidc_invalid_padding_length&#34;,
    )
    self.assertEqual(
        loader._load_oid_token(&#34;oidc_invalid_padding_length&#34;),
        None,
    )</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_no_refresh"><code class="name flex">
<span>def <span class="ident">test_oidc_no_refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_oidc_no_refresh(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;oidc&#34;,
    )
    self.assertTrue(loader._load_auth_provider_token())
    self.assertEqual(TEST_OIDC_TOKEN, loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_with_refresh"><code class="name flex">
<span>def <span class="ident">test_oidc_with_refresh</span></span>(<span>self, mock_ApiClient, mock_OAuth2Session)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mock.patch(&#39;kubernetes.config.kube_config.OAuth2Session.refresh_token&#39;)
@mock.patch(&#39;kubernetes.config.kube_config.ApiClient.request&#39;)
def test_oidc_with_refresh(self, mock_ApiClient, mock_OAuth2Session):
    mock_response = mock.MagicMock()
    type(mock_response).status = mock.PropertyMock(
        return_value=200
    )
    type(mock_response).data = mock.PropertyMock(
        return_value=json.dumps({
            &#34;token_endpoint&#34;: &#34;https://example.org/identity/token&#34;
        })
    )

    mock_ApiClient.return_value = mock_response

    mock_OAuth2Session.return_value = {&#34;id_token&#34;: &#34;abc123&#34;,
                                       &#34;refresh_token&#34;: &#34;newtoken123&#34;}

    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;expired_oidc&#34;,
    )
    self.assertTrue(loader._load_auth_provider_token())
    self.assertEqual(&#34;Bearer abc123&#34;, loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_with_refresh_nocert"><code class="name flex">
<span>def <span class="ident">test_oidc_with_refresh_nocert</span></span>(<span>self, mock_ApiClient, mock_OAuth2Session)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mock.patch(&#39;kubernetes.config.kube_config.OAuth2Session.refresh_token&#39;)
@mock.patch(&#39;kubernetes.config.kube_config.ApiClient.request&#39;)
def test_oidc_with_refresh_nocert(
        self, mock_ApiClient, mock_OAuth2Session):
    mock_response = mock.MagicMock()
    type(mock_response).status = mock.PropertyMock(
        return_value=200
    )
    type(mock_response).data = mock.PropertyMock(
        return_value=json.dumps({
            &#34;token_endpoint&#34;: &#34;https://example.org/identity/token&#34;
        })
    )

    mock_ApiClient.return_value = mock_response

    mock_OAuth2Session.return_value = {&#34;id_token&#34;: &#34;abc123&#34;,
                                       &#34;refresh_token&#34;: &#34;newtoken123&#34;}

    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;expired_oidc_nocert&#34;,
    )
    self.assertTrue(loader._load_auth_provider_token())
    self.assertEqual(&#34;Bearer abc123&#34;, loader.token)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_set_active_context"><code class="name flex">
<span>def <span class="ident">test_set_active_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_set_active_context(self):
    loader = KubeConfigLoader(config_dict=self.TEST_KUBE_CONFIG)
    loader.set_active_context(&#34;ssl&#34;)
    expected_contexts = ConfigNode(&#34;&#34;, self.TEST_KUBE_CONFIG)[&#39;contexts&#39;]
    self.assertEqual(expected_contexts.get_with_name(&#34;ssl&#34;).value,
                     loader.current_context)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_simple_token"><code class="name flex">
<span>def <span class="ident">test_simple_token</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_simple_token(self):
    expected = FakeConfig(host=TEST_HOST,
                          token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64)
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;simple_token&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl"><code class="name flex">
<span>def <span class="ident">test_ssl</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ssl(self):
    expected = FakeConfig(
        host=TEST_SSL_HOST,
        token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
        cert_file=self._create_temp_file(TEST_CLIENT_CERT),
        key_file=self._create_temp_file(TEST_CLIENT_KEY),
        ssl_ca_cert=self._create_temp_file(TEST_CERTIFICATE_AUTH)
    )
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;ssl&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_no_cert_files"><code class="name flex">
<span>def <span class="ident">test_ssl_no_cert_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ssl_no_cert_files(self):
    loader = KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;ssl-no_file&#34;)
    self.expect_exception(
        loader.load_and_set,
        &#34;does not exists&#34;,
        FakeConfig())</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_no_verification"><code class="name flex">
<span>def <span class="ident">test_ssl_no_verification</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ssl_no_verification(self):
    expected = FakeConfig(
        host=TEST_SSL_HOST,
        token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
        cert_file=self._create_temp_file(TEST_CLIENT_CERT),
        key_file=self._create_temp_file(TEST_CLIENT_KEY),
        verify_ssl=False,
        ssl_ca_cert=None,
    )
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;no_ssl_verification&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_with_relative_ssl_files"><code class="name flex">
<span>def <span class="ident">test_ssl_with_relative_ssl_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ssl_with_relative_ssl_files(self):
    expected = FakeConfig(
        host=TEST_SSL_HOST,
        token=BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
        cert_file=self._create_temp_file(TEST_CLIENT_CERT),
        key_file=self._create_temp_file(TEST_CLIENT_KEY),
        ssl_ca_cert=self._create_temp_file(TEST_CERTIFICATE_AUTH)
    )
    try:
        temp_dir = tempfile.mkdtemp()
        actual = FakeConfig()
        with open(os.path.join(temp_dir, &#34;cert_test&#34;), &#34;wb&#34;) as fd:
            fd.write(TEST_CERTIFICATE_AUTH.encode())
        with open(os.path.join(temp_dir, &#34;client_cert&#34;), &#34;wb&#34;) as fd:
            fd.write(TEST_CLIENT_CERT.encode())
        with open(os.path.join(temp_dir, &#34;client_key&#34;), &#34;wb&#34;) as fd:
            fd.write(TEST_CLIENT_KEY.encode())
        with open(os.path.join(temp_dir, &#34;token_file&#34;), &#34;wb&#34;) as fd:
            fd.write(TEST_DATA_BASE64.encode())
        KubeConfigLoader(
            config_dict=self.TEST_KUBE_CONFIG,
            active_context=&#34;ssl-local-file&#34;,
            config_base_path=temp_dir).load_and_set(actual)
        self.assertEqual(expected, actual)
    finally:
        shutil.rmtree(temp_dir)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_user_exec_auth"><code class="name flex">
<span>def <span class="ident">test_user_exec_auth</span></span>(<span>self, mock)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mock.patch(&#39;kubernetes.config.kube_config.ExecProvider.run&#39;)
def test_user_exec_auth(self, mock):
    token = &#34;dummy&#34;
    mock.return_value = {
        &#34;token&#34;: token
    }
    expected = FakeConfig(host=TEST_HOST, api_key={
                          &#34;authorization&#34;: BEARER_TOKEN_FORMAT % token})
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;exec_cred_user&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_user_pass"><code class="name flex">
<span>def <span class="ident">test_user_pass</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_user_pass(self):
    expected = FakeConfig(host=TEST_HOST, token=TEST_BASIC_TOKEN)
    actual = FakeConfig()
    KubeConfigLoader(
        config_dict=self.TEST_KUBE_CONFIG,
        active_context=&#34;user_pass&#34;).load_and_set(actual)
    self.assertEqual(expected, actual)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.setUp" href="#kubernetes.config.kube_config_test.BaseTestCase.setUp">setUp</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.tearDown" href="#kubernetes.config.kube_config_test.BaseTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger"><code class="flex name class">
<span>class <span class="ident">TestKubeConfigMerger</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestKubeConfigMerger(BaseTestCase):
    TEST_KUBE_CONFIG_PART1 = {
        &#34;current-context&#34;: &#34;no_user&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;no_user&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
            {
                &#34;name&#34;: &#34;default&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_HOST
                }
            },
        ],
        &#34;users&#34;: []
    }

    TEST_KUBE_CONFIG_PART2 = {
        &#34;current-context&#34;: &#34;&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;ssl&#34;,
                    &#34;user&#34;: &#34;ssl&#34;
                }
            },
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;simple_token&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;cluster&#34;: {
                    &#34;server&#34;: TEST_SSL_HOST,
                    &#34;certificate-authority-data&#34;:
                        TEST_CERTIFICATE_AUTH_BASE64,
                }
            },
        ],
        &#34;users&#34;: [
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;client-certificate-data&#34;: TEST_CLIENT_CERT_BASE64,
                    &#34;client-key-data&#34;: TEST_CLIENT_KEY_BASE64,
                }
            },
        ]
    }

    TEST_KUBE_CONFIG_PART3 = {
        &#34;current-context&#34;: &#34;no_user&#34;,
        &#34;contexts&#34;: [
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;default&#34;,
                    &#34;user&#34;: &#34;expired_oidc&#34;
                }
            },
            {
                &#34;name&#34;: &#34;ssl&#34;,
                &#34;context&#34;: {
                    &#34;cluster&#34;: &#34;skipped-part2-defined-this-context&#34;,
                    &#34;user&#34;: &#34;skipped&#34;
                }
            },
        ],
        &#34;clusters&#34;: [
        ],
        &#34;users&#34;: [
            {
                &#34;name&#34;: &#34;expired_oidc&#34;,
                &#34;user&#34;: {
                    &#34;auth-provider&#34;: {
                        &#34;name&#34;: &#34;oidc&#34;,
                        &#34;config&#34;: {
                            &#34;client-id&#34;: &#34;tectonic-kubectl&#34;,
                            &#34;client-secret&#34;: &#34;FAKE_SECRET&#34;,
                            &#34;id-token&#34;: TEST_OIDC_EXPIRED_LOGIN,
                            &#34;idp-certificate-authority-data&#34;: TEST_OIDC_CA,
                            &#34;idp-issuer-url&#34;: &#34;https://example.org/identity&#34;,
                            &#34;refresh-token&#34;:
                                &#34;lucWJjEhlxZW01cXI3YmVlcYnpxNGhzk&#34;
                        }
                    }
                }
            },
            {
                &#34;name&#34;: &#34;simple_token&#34;,
                &#34;user&#34;: {
                    &#34;token&#34;: TEST_DATA_BASE64,
                    &#34;username&#34;: TEST_USERNAME,  # should be ignored
                    &#34;password&#34;: TEST_PASSWORD,  # should be ignored
                }
            },
        ]
    }

    def _create_multi_config(self):
        files = []
        for part in (
                self.TEST_KUBE_CONFIG_PART1,
                self.TEST_KUBE_CONFIG_PART2,
                self.TEST_KUBE_CONFIG_PART3):
            files.append(self._create_temp_file(yaml.safe_dump(part)))
        return ENV_KUBECONFIG_PATH_SEPARATOR.join(files)

    def test_list_kube_config_contexts(self):
        kubeconfigs = self._create_multi_config()
        expected_contexts = [
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;}, &#39;name&#39;: &#39;no_user&#39;},
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;ssl&#39;, &#39;user&#39;: &#39;ssl&#39;}, &#39;name&#39;: &#39;ssl&#39;},
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;, &#39;user&#39;: &#39;simple_token&#39;},
             &#39;name&#39;: &#39;simple_token&#39;},
            {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;, &#39;user&#39;: &#39;expired_oidc&#39;}, &#39;name&#39;: &#39;expired_oidc&#39;}]

        contexts, active_context = list_kube_config_contexts(
            config_file=kubeconfigs)

        self.assertEqual(contexts, expected_contexts)
        self.assertEqual(active_context, expected_contexts[0])

    def test_new_client_from_config(self):
        kubeconfigs = self._create_multi_config()
        client = new_client_from_config(
            config_file=kubeconfigs, context=&#34;simple_token&#34;)
        self.assertEqual(TEST_HOST, client.configuration.host)
        self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                         client.configuration.api_key[&#39;authorization&#39;])

    def test_save_changes(self):
        kubeconfigs = self._create_multi_config()

        # load configuration, update token, save config
        kconf = KubeConfigMerger(kubeconfigs)
        user = kconf.config[&#39;users&#39;].get_with_name(&#39;expired_oidc&#39;)[&#39;user&#39;]
        provider = user[&#39;auth-provider&#39;][&#39;config&#39;]
        provider.value[&#39;id-token&#39;] = &#34;token-changed&#34;
        kconf.save_changes()

        # re-read configuration
        kconf = KubeConfigMerger(kubeconfigs)
        user = kconf.config[&#39;users&#39;].get_with_name(&#39;expired_oidc&#39;)[&#39;user&#39;]
        provider = user[&#39;auth-provider&#39;][&#39;config&#39;]

        # new token
        self.assertEqual(provider.value[&#39;id-token&#39;], &#34;token-changed&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART1"><code class="name">var <span class="ident">TEST_KUBE_CONFIG_PART1</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART2"><code class="name">var <span class="ident">TEST_KUBE_CONFIG_PART2</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART3"><code class="name">var <span class="ident">TEST_KUBE_CONFIG_PART3</span></code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger.test_list_kube_config_contexts"><code class="name flex">
<span>def <span class="ident">test_list_kube_config_contexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_kube_config_contexts(self):
    kubeconfigs = self._create_multi_config()
    expected_contexts = [
        {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;}, &#39;name&#39;: &#39;no_user&#39;},
        {&#39;context&#39;: {&#39;cluster&#39;: &#39;ssl&#39;, &#39;user&#39;: &#39;ssl&#39;}, &#39;name&#39;: &#39;ssl&#39;},
        {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;, &#39;user&#39;: &#39;simple_token&#39;},
         &#39;name&#39;: &#39;simple_token&#39;},
        {&#39;context&#39;: {&#39;cluster&#39;: &#39;default&#39;, &#39;user&#39;: &#39;expired_oidc&#39;}, &#39;name&#39;: &#39;expired_oidc&#39;}]

    contexts, active_context = list_kube_config_contexts(
        config_file=kubeconfigs)

    self.assertEqual(contexts, expected_contexts)
    self.assertEqual(active_context, expected_contexts[0])</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger.test_new_client_from_config"><code class="name flex">
<span>def <span class="ident">test_new_client_from_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_new_client_from_config(self):
    kubeconfigs = self._create_multi_config()
    client = new_client_from_config(
        config_file=kubeconfigs, context=&#34;simple_token&#34;)
    self.assertEqual(TEST_HOST, client.configuration.host)
    self.assertEqual(BEARER_TOKEN_FORMAT % TEST_DATA_BASE64,
                     client.configuration.api_key[&#39;authorization&#39;])</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubeConfigMerger.test_save_changes"><code class="name flex">
<span>def <span class="ident">test_save_changes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_save_changes(self):
    kubeconfigs = self._create_multi_config()

    # load configuration, update token, save config
    kconf = KubeConfigMerger(kubeconfigs)
    user = kconf.config[&#39;users&#39;].get_with_name(&#39;expired_oidc&#39;)[&#39;user&#39;]
    provider = user[&#39;auth-provider&#39;][&#39;config&#39;]
    provider.value[&#39;id-token&#39;] = &#34;token-changed&#34;
    kconf.save_changes()

    # re-read configuration
    kconf = KubeConfigMerger(kubeconfigs)
    user = kconf.config[&#39;users&#39;].get_with_name(&#39;expired_oidc&#39;)[&#39;user&#39;]
    provider = user[&#39;auth-provider&#39;][&#39;config&#39;]

    # new token
    self.assertEqual(provider.value[&#39;id-token&#39;], &#34;token-changed&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.setUp" href="#kubernetes.config.kube_config_test.BaseTestCase.setUp">setUp</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.tearDown" href="#kubernetes.config.kube_config_test.BaseTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration"><code class="flex name class">
<span>class <span class="ident">TestKubernetesClientConfiguration</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestKubernetesClientConfiguration(BaseTestCase):
    # Verifies properties of kubernetes.client.Configuration.
    # These tests guard against changes to the upstream configuration class,
    # since GCP authorization overrides get_api_key_with_prefix to refresh its
    # token regularly.

    def test_get_api_key_with_prefix_exists(self):
        self.assertTrue(hasattr(Configuration, &#39;get_api_key_with_prefix&#39;))

    def test_get_api_key_with_prefix_returns_token(self):
        expected_token = &#39;expected_token&#39;
        config = Configuration()
        config.api_key[&#39;authorization&#39;] = expected_token
        self.assertEqual(expected_token,
                         config.get_api_key_with_prefix(&#39;authorization&#39;))

    def test_auth_settings_calls_get_api_key_with_prefix(self):
        expected_token = &#39;expected_token&#39;

        def fake_get_api_key_with_prefix(identifier):
            self.assertEqual(&#39;authorization&#39;, identifier)
            return expected_token
        config = Configuration()
        config.get_api_key_with_prefix = fake_get_api_key_with_prefix
        self.assertEqual(expected_token,
                         config.auth_settings()[&#39;BearerToken&#39;][&#39;value&#39;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></li>
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_auth_settings_calls_get_api_key_with_prefix"><code class="name flex">
<span>def <span class="ident">test_auth_settings_calls_get_api_key_with_prefix</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_auth_settings_calls_get_api_key_with_prefix(self):
    expected_token = &#39;expected_token&#39;

    def fake_get_api_key_with_prefix(identifier):
        self.assertEqual(&#39;authorization&#39;, identifier)
        return expected_token
    config = Configuration()
    config.get_api_key_with_prefix = fake_get_api_key_with_prefix
    self.assertEqual(expected_token,
                     config.auth_settings()[&#39;BearerToken&#39;][&#39;value&#39;])</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_get_api_key_with_prefix_exists"><code class="name flex">
<span>def <span class="ident">test_get_api_key_with_prefix_exists</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_api_key_with_prefix_exists(self):
    self.assertTrue(hasattr(Configuration, &#39;get_api_key_with_prefix&#39;))</code></pre>
</details>
</dd>
<dt id="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_get_api_key_with_prefix_returns_token"><code class="name flex">
<span>def <span class="ident">test_get_api_key_with_prefix_returns_token</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_api_key_with_prefix_returns_token(self):
    expected_token = &#39;expected_token&#39;
    config = Configuration()
    config.api_key[&#39;authorization&#39;] = expected_token
    self.assertEqual(expected_token,
                     config.get_api_key_with_prefix(&#39;authorization&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></b></code>:
<ul class="hlist">
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.setUp" href="#kubernetes.config.kube_config_test.BaseTestCase.setUp">setUp</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.tearDown" href="#kubernetes.config.kube_config_test.BaseTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kubernetes.config" href="index.html">kubernetes.config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.BaseTestCase" href="#kubernetes.config.kube_config_test.BaseTestCase">BaseTestCase</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.expect_exception" href="#kubernetes.config.kube_config_test.BaseTestCase.expect_exception">expect_exception</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.setUp" href="#kubernetes.config.kube_config_test.BaseTestCase.setUp">setUp</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.BaseTestCase.tearDown" href="#kubernetes.config.kube_config_test.BaseTestCase.tearDown">tearDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.FakeConfig" href="#kubernetes.config.kube_config_test.FakeConfig">FakeConfig</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.FakeConfig.FILE_KEYS" href="#kubernetes.config.kube_config_test.FakeConfig.FILE_KEYS">FILE_KEYS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.TestConfigNode" href="#kubernetes.config.kube_config_test.TestConfigNode">TestConfigNode</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name" href="#kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name">test_get_with_name</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_duplicate_name" href="#kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_duplicate_name">test_get_with_name_on_duplicate_name</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_invalid_object" href="#kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_invalid_object">test_get_with_name_on_invalid_object</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_name_does_not_exists" href="#kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_name_does_not_exists">test_get_with_name_on_name_does_not_exists</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_non_list_object" href="#kubernetes.config.kube_config_test.TestConfigNode.test_get_with_name_on_non_list_object">test_get_with_name_on_non_list_object</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_key_does_not_exists" href="#kubernetes.config.kube_config_test.TestConfigNode.test_key_does_not_exists">test_key_does_not_exists</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_normal_map_array_operations" href="#kubernetes.config.kube_config_test.TestConfigNode.test_normal_map_array_operations">test_normal_map_array_operations</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestConfigNode.test_obj" href="#kubernetes.config.kube_config_test.TestConfigNode.test_obj">test_obj</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.TestFileOrData" href="#kubernetes.config.kube_config_test.TestFileOrData">TestFileOrData</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.get_file_content" href="#kubernetes.config.kube_config_test.TestFileOrData.get_file_content">get_file_content</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_create_temp_file_with_content" href="#kubernetes.config.kube_config_test.TestFileOrData.test_create_temp_file_with_content">test_create_temp_file_with_content</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_data" href="#kubernetes.config.kube_config_test.TestFileOrData.test_data_given_data">test_data_given_data</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file" href="#kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file">test_data_given_file</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file_and_data" href="#kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file_and_data">test_data_given_file_and_data</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file_no_base64" href="#kubernetes.config.kube_config_test.TestFileOrData.test_data_given_file_no_base64">test_data_given_file_no_base64</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data">test_file_given_data</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_bytes" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_bytes">test_file_given_data_bytes</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_bytes_no_base64" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_bytes_no_base64">test_file_given_data_bytes_no_base64</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_no_base64" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_data_no_base64">test_file_given_data_no_base64</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_file" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_file">test_file_given_file</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_file_and_data" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_file_and_data">test_file_given_file_and_data</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_given_non_existing_file" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_given_non_existing_file">test_file_given_non_existing_file</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestFileOrData.test_file_with_custom_dirname" href="#kubernetes.config.kube_config_test.TestFileOrData.test_file_with_custom_dirname">test_file_with_custom_dirname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader">TestKubeConfigLoader</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.TEST_KUBE_CONFIG" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.TEST_KUBE_CONFIG">TEST_KUBE_CONFIG</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_current_context" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_current_context">test_current_context</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_gcp_get_api_key_with_prefix" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_gcp_get_api_key_with_prefix">test_gcp_get_api_key_with_prefix</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_gcp_no_refresh" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_gcp_no_refresh">test_gcp_no_refresh</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_list_contexts" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_list_contexts">test_list_contexts</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_list_kube_config_contexts" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_list_kube_config_contexts">test_list_kube_config_contexts</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_gcp_token_no_refresh" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_gcp_token_no_refresh">test_load_gcp_token_no_refresh</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_gcp_token_with_refresh" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_gcp_token_with_refresh">test_load_gcp_token_with_refresh</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_kube_config" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_kube_config">test_load_kube_config</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_user_pass_token" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_user_pass_token">test_load_user_pass_token</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_user_token" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_load_user_token">test_load_user_token</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_new_client_from_config" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_new_client_from_config">test_new_client_from_config</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_no_user_context" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_no_user_context">test_no_user_context</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_no_users_section" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_no_users_section">test_no_users_section</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_non_existing_user" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_non_existing_user">test_non_existing_user</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_fails_if_contains_reserved_chars" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_fails_if_contains_reserved_chars">test_oidc_fails_if_contains_reserved_chars</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_fails_if_invalid_padding_length" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_fails_if_invalid_padding_length">test_oidc_fails_if_invalid_padding_length</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_no_refresh" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_no_refresh">test_oidc_no_refresh</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_with_refresh" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_with_refresh">test_oidc_with_refresh</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_with_refresh_nocert" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_oidc_with_refresh_nocert">test_oidc_with_refresh_nocert</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_set_active_context" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_set_active_context">test_set_active_context</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_simple_token" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_simple_token">test_simple_token</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl">test_ssl</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_no_cert_files" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_no_cert_files">test_ssl_no_cert_files</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_no_verification" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_no_verification">test_ssl_no_verification</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_with_relative_ssl_files" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_ssl_with_relative_ssl_files">test_ssl_with_relative_ssl_files</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_user_exec_auth" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_user_exec_auth">test_user_exec_auth</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigLoader.test_user_pass" href="#kubernetes.config.kube_config_test.TestKubeConfigLoader.test_user_pass">test_user_pass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger">TestKubeConfigMerger</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART1" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART1">TEST_KUBE_CONFIG_PART1</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART2" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART2">TEST_KUBE_CONFIG_PART2</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART3" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger.TEST_KUBE_CONFIG_PART3">TEST_KUBE_CONFIG_PART3</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger.test_list_kube_config_contexts" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger.test_list_kube_config_contexts">test_list_kube_config_contexts</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger.test_new_client_from_config" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger.test_new_client_from_config">test_new_client_from_config</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubeConfigMerger.test_save_changes" href="#kubernetes.config.kube_config_test.TestKubeConfigMerger.test_save_changes">test_save_changes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration" href="#kubernetes.config.kube_config_test.TestKubernetesClientConfiguration">TestKubernetesClientConfiguration</a></code></h4>
<ul class="">
<li><code><a title="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_auth_settings_calls_get_api_key_with_prefix" href="#kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_auth_settings_calls_get_api_key_with_prefix">test_auth_settings_calls_get_api_key_with_prefix</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_get_api_key_with_prefix_exists" href="#kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_get_api_key_with_prefix_exists">test_get_api_key_with_prefix_exists</a></code></li>
<li><code><a title="kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_get_api_key_with_prefix_returns_token" href="#kubernetes.config.kube_config_test.TestKubernetesClientConfiguration.test_get_api_key_with_prefix_returns_token">test_get_api_key_with_prefix_returns_token</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>