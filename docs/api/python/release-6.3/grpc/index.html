<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>grpc API documentation</title>
<meta name="description" content="gRPC&#39;s Python API." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grpc</code></h1>
</header>
<section id="section-intro">
<p>gRPC's Python API.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2015-2016 gRPC authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34;gRPC&#39;s Python API.&#34;&#34;&#34;

import abc
import contextlib
import enum
import logging
import sys
import six

from grpc._cython import cygrpc as _cygrpc
from grpc import _compression

logging.getLogger(__name__).addHandler(logging.NullHandler())

try:
    from grpc._grpcio_metadata import __version__
except ImportError:
    __version__ = &#34;dev0&#34;

############################## Future Interface  ###############################


class FutureTimeoutError(Exception):
    &#34;&#34;&#34;Indicates that a method call on a Future timed out.&#34;&#34;&#34;


class FutureCancelledError(Exception):
    &#34;&#34;&#34;Indicates that the computation underlying a Future was cancelled.&#34;&#34;&#34;


class Future(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;A representation of a computation in another control flow.

    Computations represented by a Future may be yet to be begun,
    may be ongoing, or may have already completed.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def cancel(self):
        &#34;&#34;&#34;Attempts to cancel the computation.

        This method does not block.

        Returns:
            bool:
            Returns True if the computation was canceled.

            Returns False under all other circumstances, for example:

            1. computation has begun and could not be canceled.
            2. computation has finished
            3. computation is scheduled for execution and it is impossible
                to determine its state without blocking.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def cancelled(self):
        &#34;&#34;&#34;Describes whether the computation was cancelled.

        This method does not block.

        Returns:
            bool:
            Returns True if the computation was cancelled before its result became
            available.

            Returns False under all other circumstances, for example:

            1. computation was not cancelled.
            2. computation&#39;s result is available.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def running(self):
        &#34;&#34;&#34;Describes whether the computation is taking place.

        This method does not block.

        Returns:
            Returns True if the computation is scheduled for execution or
            currently executing.

            Returns False if the computation already executed or was cancelled.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def done(self):
        &#34;&#34;&#34;Describes whether the computation has taken place.

        This method does not block.

        Returns:
            bool:
            Returns True if the computation already executed or was cancelled.
            Returns False if the computation is scheduled for execution or
            currently executing.
            This is exactly opposite of the running() method&#39;s result.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def result(self, timeout=None):
        &#34;&#34;&#34;Returns the result of the computation or raises its exception.

        This method may return immediately or may block.

        Args:
          timeout: The length of time in seconds to wait for the computation to
            finish or be cancelled. If None, the call will block until the
            computations&#39;s termination.

        Returns:
          The return value of the computation.

        Raises:
          FutureTimeoutError: If a timeout value is passed and the computation
            does not terminate within the allotted time.
          FutureCancelledError: If the computation was cancelled.
          Exception: If the computation raised an exception, this call will
            raise the same exception.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def exception(self, timeout=None):
        &#34;&#34;&#34;Return the exception raised by the computation.

        This method may return immediately or may block.

        Args:
          timeout: The length of time in seconds to wait for the computation to
            terminate or be cancelled. If None, the call will block until the
            computations&#39;s termination.

        Returns:
            The exception raised by the computation, or None if the computation
            did not raise an exception.

        Raises:
          FutureTimeoutError: If a timeout value is passed and the computation
            does not terminate within the allotted time.
          FutureCancelledError: If the computation was cancelled.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def traceback(self, timeout=None):
        &#34;&#34;&#34;Access the traceback of the exception raised by the computation.

        This method may return immediately or may block.

        Args:
          timeout: The length of time in seconds to wait for the computation
            to terminate or be cancelled. If None, the call will block until
            the computation&#39;s termination.

        Returns:
            The traceback of the exception raised by the computation, or None
            if the computation did not raise an exception.

        Raises:
          FutureTimeoutError: If a timeout value is passed and the computation
            does not terminate within the allotted time.
          FutureCancelledError: If the computation was cancelled.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_done_callback(self, fn):
        &#34;&#34;&#34;Adds a function to be called at completion of the computation.

        The callback will be passed this Future object describing the outcome
        of the computation.  Callbacks will be invoked after the future is
        terimated, whether successfully or not.

        If the computation has already completed, the callback will be called
        immediately.

        Exceptions raised in the callback will be logged at ERROR level, but
        will not terminate any threads of execution.

        Args:
          fn: A callable taking this Future object as its single parameter.
        &#34;&#34;&#34;
        raise NotImplementedError()


################################  gRPC Enums  ##################################


@enum.unique
class ChannelConnectivity(enum.Enum):
    &#34;&#34;&#34;Mirrors grpc_connectivity_state in the gRPC Core.

    Attributes:
      IDLE: The channel is idle.
      CONNECTING: The channel is connecting.
      READY: The channel is ready to conduct RPCs.
      TRANSIENT_FAILURE: The channel has seen a failure from which it expects
        to recover.
      SHUTDOWN: The channel has seen a failure from which it cannot recover.
    &#34;&#34;&#34;
    IDLE = (_cygrpc.ConnectivityState.idle, &#39;idle&#39;)
    CONNECTING = (_cygrpc.ConnectivityState.connecting, &#39;connecting&#39;)
    READY = (_cygrpc.ConnectivityState.ready, &#39;ready&#39;)
    TRANSIENT_FAILURE = (_cygrpc.ConnectivityState.transient_failure,
                         &#39;transient failure&#39;)
    SHUTDOWN = (_cygrpc.ConnectivityState.shutdown, &#39;shutdown&#39;)


@enum.unique
class StatusCode(enum.Enum):
    &#34;&#34;&#34;Mirrors grpc_status_code in the gRPC Core.

    Attributes:
      OK: Not an error; returned on success
      CANCELLED: The operation was cancelled (typically by the caller).
      UNKNOWN: Unknown error.
      INVALID_ARGUMENT: Client specified an invalid argument.
      DEADLINE_EXCEEDED: Deadline expired before operation could complete.
      NOT_FOUND: Some requested entity (e.g., file or directory) was not found.
      ALREADY_EXISTS: Some entity that we attempted to create (e.g., file or directory)
        already exists.
      PERMISSION_DENIED: The caller does not have permission to execute the specified
        operation.
      UNAUTHENTICATED: The request does not have valid authentication credentials for the
        operation.
      RESOURCE_EXHAUSTED: Some resource has been exhausted, perhaps a per-user quota, or
        perhaps the entire file system is out of space.
      FAILED_PRECONDITION: Operation was rejected because the system is not in a state
        required for the operation&#39;s execution.
      ABORTED: The operation was aborted, typically due to a concurrency issue
        like sequencer check failures, transaction aborts, etc.
      UNIMPLEMENTED: Operation is not implemented or not supported/enabled in this service.
      INTERNAL: Internal errors.  Means some invariants expected by underlying
        system has been broken.
      UNAVAILABLE: The service is currently unavailable.
      DATA_LOSS: Unrecoverable data loss or corruption.
    &#34;&#34;&#34;
    OK = (_cygrpc.StatusCode.ok, &#39;ok&#39;)
    CANCELLED = (_cygrpc.StatusCode.cancelled, &#39;cancelled&#39;)
    UNKNOWN = (_cygrpc.StatusCode.unknown, &#39;unknown&#39;)
    INVALID_ARGUMENT = (_cygrpc.StatusCode.invalid_argument, &#39;invalid argument&#39;)
    DEADLINE_EXCEEDED = (_cygrpc.StatusCode.deadline_exceeded,
                         &#39;deadline exceeded&#39;)
    NOT_FOUND = (_cygrpc.StatusCode.not_found, &#39;not found&#39;)
    ALREADY_EXISTS = (_cygrpc.StatusCode.already_exists, &#39;already exists&#39;)
    PERMISSION_DENIED = (_cygrpc.StatusCode.permission_denied,
                         &#39;permission denied&#39;)
    RESOURCE_EXHAUSTED = (_cygrpc.StatusCode.resource_exhausted,
                          &#39;resource exhausted&#39;)
    FAILED_PRECONDITION = (_cygrpc.StatusCode.failed_precondition,
                           &#39;failed precondition&#39;)
    ABORTED = (_cygrpc.StatusCode.aborted, &#39;aborted&#39;)
    OUT_OF_RANGE = (_cygrpc.StatusCode.out_of_range, &#39;out of range&#39;)
    UNIMPLEMENTED = (_cygrpc.StatusCode.unimplemented, &#39;unimplemented&#39;)
    INTERNAL = (_cygrpc.StatusCode.internal, &#39;internal&#39;)
    UNAVAILABLE = (_cygrpc.StatusCode.unavailable, &#39;unavailable&#39;)
    DATA_LOSS = (_cygrpc.StatusCode.data_loss, &#39;data loss&#39;)
    UNAUTHENTICATED = (_cygrpc.StatusCode.unauthenticated, &#39;unauthenticated&#39;)


#############################  gRPC Status  ################################


class Status(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Describes the status of an RPC.

    This is an EXPERIMENTAL API.

    Attributes:
      code: A StatusCode object to be sent to the client.
      details: A UTF-8-encodable string to be sent to the client upon
        termination of the RPC.
      trailing_metadata: The trailing :term:`metadata` in the RPC.
    &#34;&#34;&#34;


#############################  gRPC Exceptions  ################################


class RpcError(Exception):
    &#34;&#34;&#34;Raised by the gRPC library to indicate non-OK-status RPC termination.&#34;&#34;&#34;


##############################  Shared Context  ################################


class RpcContext(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Provides RPC-related information and action.&#34;&#34;&#34;

    @abc.abstractmethod
    def is_active(self):
        &#34;&#34;&#34;Describes whether the RPC is active or has terminated.

        Returns:
          bool:
          True if RPC is active, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def time_remaining(self):
        &#34;&#34;&#34;Describes the length of allowed time remaining for the RPC.

        Returns:
          A nonnegative float indicating the length of allowed time in seconds
          remaining for the RPC to complete before it is considered to have
          timed out, or None if no deadline was specified for the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def cancel(self):
        &#34;&#34;&#34;Cancels the RPC.

        Idempotent and has no effect if the RPC has already terminated.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_callback(self, callback):
        &#34;&#34;&#34;Registers a callback to be called on RPC termination.

        Args:
          callback: A no-parameter callable to be called on RPC termination.

        Returns:
          True if the callback was added and will be called later; False if
            the callback was not added and will not be called (because the RPC
            already terminated or some other reason).
        &#34;&#34;&#34;
        raise NotImplementedError()


#########################  Invocation-Side Context  ############################


class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):
    &#34;&#34;&#34;Invocation-side utility object for an RPC.&#34;&#34;&#34;

    @abc.abstractmethod
    def initial_metadata(self):
        &#34;&#34;&#34;Accesses the initial metadata sent by the server.

        This method blocks until the value is available.

        Returns:
          The initial :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def trailing_metadata(self):
        &#34;&#34;&#34;Accesses the trailing metadata sent by the server.

        This method blocks until the value is available.

        Returns:
          The trailing :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def code(self):
        &#34;&#34;&#34;Accesses the status code sent by the server.

        This method blocks until the value is available.

        Returns:
          The StatusCode value for the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def details(self):
        &#34;&#34;&#34;Accesses the details sent by the server.

        This method blocks until the value is available.

        Returns:
          The details string of the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()


##############  Invocation-Side Interceptor Interfaces &amp; Classes  ##############


class ClientCallDetails(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Describes an RPC to be invoked.

    This is an EXPERIMENTAL API.

    Attributes:
      method: The method name of the RPC.
      timeout: An optional duration of time in seconds to allow for the RPC.
      metadata: Optional :term:`metadata` to be transmitted to
        the service-side of the RPC.
      credentials: An optional CallCredentials for the RPC.
      wait_for_ready: This is an EXPERIMENTAL argument. An optional flag t
        enable wait for ready mechanism.
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This is an EXPERIMENTAL option.
    &#34;&#34;&#34;


class UnaryUnaryClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting unary-unary invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_unary_unary(self, continuation, client_call_details, request):
        &#34;&#34;&#34;Intercepts a unary-unary invocation asynchronously.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_future = continuation(client_call_details, request)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and a Future. In the event of RPC
            completion, the return Call-Future&#39;s result value will be
            the response message of the RPC. Should the event terminate
            with non-OK status, the returned Call-Future&#39;s exception value
            will be an RpcError.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request: The request value for the RPC.

        Returns:
            An object that is both a Call for the RPC and a Future.
            In the event of RPC completion, the return Call-Future&#39;s
            result value will be the response message of the RPC.
            Should the event terminate with non-OK status, the returned
            Call-Future&#39;s exception value will be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()


class UnaryStreamClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting unary-stream invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_unary_stream(self, continuation, client_call_details,
                               request):
        &#34;&#34;&#34;Intercepts a unary-stream invocation.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_iterator = continuation(client_call_details, request)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and an iterator for response values.
            Drawing response values from the returned Call-iterator may
            raise RpcError indicating termination of the RPC with non-OK
            status.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request: The request value for the RPC.

        Returns:
            An object that is both a Call for the RPC and an iterator of
            response values. Drawing response values from the returned
            Call-iterator may raise RpcError indicating termination of
            the RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()


class StreamUnaryClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting stream-unary invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_stream_unary(self, continuation, client_call_details,
                               request_iterator):
        &#34;&#34;&#34;Intercepts a stream-unary invocation asynchronously.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_future = continuation(client_call_details, request_iterator)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and a Future. In the event of RPC completion,
            the return Call-Future&#39;s result value will be the response message
            of the RPC. Should the event terminate with non-OK status, the
            returned Call-Future&#39;s exception value will be an RpcError.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request_iterator: An iterator that yields request values for the RPC.

        Returns:
          An object that is both a Call for the RPC and a Future.
          In the event of RPC completion, the return Call-Future&#39;s
          result value will be the response message of the RPC.
          Should the event terminate with non-OK status, the returned
          Call-Future&#39;s exception value will be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()


class StreamStreamClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting stream-stream invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_stream_stream(self, continuation, client_call_details,
                                request_iterator):
        &#34;&#34;&#34;Intercepts a stream-stream invocation.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_iterator = continuation(client_call_details, request_iterator)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and an iterator for response values.
            Drawing response values from the returned Call-iterator may
            raise RpcError indicating termination of the RPC with non-OK
            status.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request_iterator: An iterator that yields request values for the RPC.

        Returns:
          An object that is both a Call for the RPC and an iterator of
          response values. Drawing response values from the returned
          Call-iterator may raise RpcError indicating termination of
          the RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()


############  Authentication &amp; Authorization Interfaces &amp; Classes  #############


class ChannelCredentials(object):
    &#34;&#34;&#34;An encapsulation of the data required to create a secure Channel.

    This class has no supported interface - it exists to define the type of its
    instances and its instances exist to be passed to other functions. For
    example, ssl_channel_credentials returns an instance of this class and
    secure_channel requires an instance of this class.
    &#34;&#34;&#34;

    def __init__(self, credentials):
        self._credentials = credentials


class CallCredentials(object):
    &#34;&#34;&#34;An encapsulation of the data required to assert an identity over a call.

    A CallCredentials has to be used with secure Channel, otherwise the
    metadata will not be transmitted to the server.

    A CallCredentials may be composed with ChannelCredentials to always assert
    identity for every call over that Channel.

    This class has no supported interface - it exists to define the type of its
    instances and its instances exist to be passed to other functions.
    &#34;&#34;&#34;

    def __init__(self, credentials):
        self._credentials = credentials


class AuthMetadataContext(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Provides information to call credentials metadata plugins.

    Attributes:
      service_url: A string URL of the service being called into.
      method_name: A string of the fully qualified method name being called.
    &#34;&#34;&#34;


class AuthMetadataPluginCallback(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Callback object received by a metadata plugin.&#34;&#34;&#34;

    def __call__(self, metadata, error):
        &#34;&#34;&#34;Passes to the gRPC runtime authentication metadata for an RPC.

        Args:
          metadata: The :term:`metadata` used to construct the CallCredentials.
          error: An Exception to indicate error or None to indicate success.
        &#34;&#34;&#34;
        raise NotImplementedError()


class AuthMetadataPlugin(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;A specification for custom authentication.&#34;&#34;&#34;

    def __call__(self, context, callback):
        &#34;&#34;&#34;Implements authentication by passing metadata to a callback.

        Implementations of this method must not block.

        Args:
          context: An AuthMetadataContext providing information on the RPC that
            the plugin is being called to authenticate.
          callback: An AuthMetadataPluginCallback to be invoked either
            synchronously or asynchronously.
        &#34;&#34;&#34;
        raise NotImplementedError()


class ServerCredentials(object):
    &#34;&#34;&#34;An encapsulation of the data required to open a secure port on a Server.

    This class has no supported interface - it exists to define the type of its
    instances and its instances exist to be passed to other functions.
    &#34;&#34;&#34;

    def __init__(self, credentials):
        self._credentials = credentials


class ServerCertificateConfiguration(object):
    &#34;&#34;&#34;A certificate configuration for use with an SSL-enabled Server.

    Instances of this class can be returned in the certificate configuration
    fetching callback.

    This class has no supported interface -- it exists to define the
    type of its instances and its instances exist to be passed to
    other functions.
    &#34;&#34;&#34;

    def __init__(self, certificate_configuration):
        self._certificate_configuration = certificate_configuration


########################  Multi-Callable Interfaces  ###########################


class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a unary-unary RPC from client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow
            for the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def with_call(self,
                  request,
                  timeout=None,
                  metadata=None,
                  credentials=None,
                  wait_for_ready=None,
                  compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional durating of time in seconds to allow for
            the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC and a Call value for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def future(self,
               request,
               timeout=None,
               metadata=None,
               credentials=None,
               wait_for_ready=None,
               compression=None):
        &#34;&#34;&#34;Asynchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and a Future.
            In the event of RPC completion, the return Call-Future&#39;s result
            value will be the response message of the RPC.
            Should the event terminate with non-OK status,
            the returned Call-Future&#39;s exception value will be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()


class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a unary-stream RPC from client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: An optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and an iterator of
            response values. Drawing response values from the returned
            Call-iterator may raise RpcError indicating termination of the
            RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()


class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a stream-unary RPC from client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request_iterator,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC.

        Args:
          request_iterator: An iterator that yields request values for
            the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also implement grpc.Call, affording methods
            such as metadata, code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def with_call(self,
                  request_iterator,
                  timeout=None,
                  metadata=None,
                  credentials=None,
                  wait_for_ready=None,
                  compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC on the client.

        Args:
          request_iterator: An iterator that yields request values for
            the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC and a Call object for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def future(self,
               request_iterator,
               timeout=None,
               metadata=None,
               credentials=None,
               wait_for_ready=None,
               compression=None):
        &#34;&#34;&#34;Asynchronously invokes the underlying RPC on the client.

        Args:
          request_iterator: An iterator that yields request values for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and a Future.
            In the event of RPC completion, the return Call-Future&#39;s result value
            will be the response message of the RPC. Should the event terminate
            with non-OK status, the returned Call-Future&#39;s exception value will
            be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()


class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a stream-stream RPC on client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request_iterator,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Invokes the underlying RPC on the client.

        Args:
          request_iterator: An iterator that yields request values for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If not specified, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and an iterator of
            response values. Drawing response values from the returned
            Call-iterator may raise RpcError indicating termination of the
            RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()


#############################  Channel Interface  ##############################


class Channel(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords RPC invocation via generic methods on client-side.

    Channel objects implement the Context Manager type, although they need not
    support being entered and exited multiple times.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def subscribe(self, callback, try_to_connect=False):
        &#34;&#34;&#34;Subscribe to this Channel&#39;s connectivity state machine.

        A Channel may be in any of the states described by ChannelConnectivity.
        This method allows application to monitor the state transitions.
        The typical use case is to debug or gain better visibility into gRPC
        runtime&#39;s state.

        Args:
          callback: A callable to be invoked with ChannelConnectivity argument.
            ChannelConnectivity describes current state of the channel.
            The callable will be invoked immediately upon subscription
            and again for every change to ChannelConnectivity until it
            is unsubscribed or this Channel object goes out of scope.
          try_to_connect: A boolean indicating whether or not this Channel
            should attempt to connect immediately. If set to False, gRPC
            runtime decides when to connect.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def unsubscribe(self, callback):
        &#34;&#34;&#34;Unsubscribes a subscribed callback from this Channel&#39;s connectivity.

        Args:
          callback: A callable previously registered with this Channel from
          having been passed to its &#34;subscribe&#34; method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def unary_unary(self,
                    method,
                    request_serializer=None,
                    response_deserializer=None):
        &#34;&#34;&#34;Creates a UnaryUnaryMultiCallable for a unary-unary method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None
            is passed.

        Returns:
          A UnaryUnaryMultiCallable value for the named unary-unary method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def unary_stream(self,
                     method,
                     request_serializer=None,
                     response_deserializer=None):
        &#34;&#34;&#34;Creates a UnaryStreamMultiCallable for a unary-stream method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None is
            passed.

        Returns:
          A UnaryStreamMultiCallable value for the name unary-stream method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def stream_unary(self,
                     method,
                     request_serializer=None,
                     response_deserializer=None):
        &#34;&#34;&#34;Creates a StreamUnaryMultiCallable for a stream-unary method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None is
            passed.

        Returns:
          A StreamUnaryMultiCallable value for the named stream-unary method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def stream_stream(self,
                      method,
                      request_serializer=None,
                      response_deserializer=None):
        &#34;&#34;&#34;Creates a StreamStreamMultiCallable for a stream-stream method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None
            is passed.

        Returns:
          A StreamStreamMultiCallable value for the named stream-stream method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self):
        &#34;&#34;&#34;Closes this Channel and releases all resources held by it.

        Closing the Channel will immediately terminate all RPCs active with the
        Channel and it is not valid to invoke new RPCs with the Channel.

        This method is idempotent.
        &#34;&#34;&#34;
        raise NotImplementedError()


##########################  Service-Side Context  ##############################


class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):
    &#34;&#34;&#34;A context object passed to method implementations.&#34;&#34;&#34;

    @abc.abstractmethod
    def invocation_metadata(self):
        &#34;&#34;&#34;Accesses the metadata from the sent by the client.

        Returns:
          The invocation :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def peer(self):
        &#34;&#34;&#34;Identifies the peer that invoked the RPC being serviced.

        Returns:
          A string identifying the peer that invoked the RPC being serviced.
          The string format is determined by gRPC runtime.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def peer_identities(self):
        &#34;&#34;&#34;Gets one or more peer identity(s).

        Equivalent to
        servicer_context.auth_context().get(servicer_context.peer_identity_key())

        Returns:
          An iterable of the identities, or None if the call is not
          authenticated. Each identity is returned as a raw bytes type.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def peer_identity_key(self):
        &#34;&#34;&#34;The auth property used to identify the peer.

        For example, &#34;x509_common_name&#34; or &#34;x509_subject_alternative_name&#34; are
        used to identify an SSL peer.

        Returns:
          The auth property (string) that indicates the
          peer identity, or None if the call is not authenticated.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def auth_context(self):
        &#34;&#34;&#34;Gets the auth context for the call.

        Returns:
          A map of strings to an iterable of bytes for each auth property.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def set_compression(self, compression):
        &#34;&#34;&#34;Set the compression algorithm to be used for the entire call.

        This is an EXPERIMENTAL method.

        Args:
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def send_initial_metadata(self, initial_metadata):
        &#34;&#34;&#34;Sends the initial metadata value to the client.

        This method need not be called by implementations if they have no
        metadata to add to what the gRPC runtime will transmit.

        Args:
          initial_metadata: The initial :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def set_trailing_metadata(self, trailing_metadata):
        &#34;&#34;&#34;Sends the trailing metadata for the RPC.

        This method need not be called by implementations if they have no
        metadata to add to what the gRPC runtime will transmit.

        Args:
          trailing_metadata: The trailing :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def abort(self, code, details):
        &#34;&#34;&#34;Raises an exception to terminate the RPC with a non-OK status.

        The code and details passed as arguments will supercede any existing
        ones.

        Args:
          code: A StatusCode object to be sent to the client.
            It must not be StatusCode.OK.
          details: A UTF-8-encodable string to be sent to the client upon
            termination of the RPC.

        Raises:
          Exception: An exception is always raised to signal the abortion the
            RPC to the gRPC runtime.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def abort_with_status(self, status):
        &#34;&#34;&#34;Raises an exception to terminate the RPC with a non-OK status.

        The status passed as argument will supercede any existing status code,
        status message and trailing metadata.

        This is an EXPERIMENTAL API.

        Args:
          status: A grpc.Status object. The status code in it must not be
            StatusCode.OK.

        Raises:
          Exception: An exception is always raised to signal the abortion the
            RPC to the gRPC runtime.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def set_code(self, code):
        &#34;&#34;&#34;Sets the value to be used as status code upon RPC completion.

        This method need not be called by method implementations if they wish
        the gRPC runtime to determine the status code of the RPC.

        Args:
          code: A StatusCode object to be sent to the client.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def set_details(self, details):
        &#34;&#34;&#34;Sets the value to be used as detail string upon RPC completion.

        This method need not be called by method implementations if they have
        no details to transmit.

        Args:
          details: A UTF-8-encodable string to be sent to the client upon
            termination of the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def disable_next_message_compression(self):
        &#34;&#34;&#34;Disables compression for the next response message.

        This is an EXPERIMENTAL method.

        This method will override any compression configuration set during
        server creation or set on the call.
        &#34;&#34;&#34;
        raise NotImplementedError()


#####################  Service-Side Handler Interfaces  ########################


class RpcMethodHandler(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;An implementation of a single RPC method.

    Attributes:
      request_streaming: Whether the RPC supports exactly one request message
        or any arbitrary number of request messages.
      response_streaming: Whether the RPC supports exactly one response message
        or any arbitrary number of response messages.
      request_deserializer: A callable behavior that accepts a byte string and
        returns an object suitable to be passed to this object&#39;s business
        logic, or None to indicate that this object&#39;s business logic should be
        passed the raw request bytes.
      response_serializer: A callable behavior that accepts an object produced
        by this object&#39;s business logic and returns a byte string, or None to
        indicate that the byte strings produced by this object&#39;s business logic
        should be transmitted on the wire as they are.
      unary_unary: This object&#39;s application-specific business logic as a
        callable value that takes a request value and a ServicerContext object
        and returns a response value. Only non-None if both request_streaming
        and response_streaming are False.
      unary_stream: This object&#39;s application-specific business logic as a
        callable value that takes a request value and a ServicerContext object
        and returns an iterator of response values. Only non-None if
        request_streaming is False and response_streaming is True.
      stream_unary: This object&#39;s application-specific business logic as a
        callable value that takes an iterator of request values and a
        ServicerContext object and returns a response value. Only non-None if
        request_streaming is True and response_streaming is False.
      stream_stream: This object&#39;s application-specific business logic as a
        callable value that takes an iterator of request values and a
        ServicerContext object and returns an iterator of response values.
        Only non-None if request_streaming and response_streaming are both
        True.
    &#34;&#34;&#34;


class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Describes an RPC that has just arrived for service.

    Attributes:
      method: The method name of the RPC.
      invocation_metadata: The :term:`metadata` sent by the client.
    &#34;&#34;&#34;


class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;An implementation of arbitrarily many RPC methods.&#34;&#34;&#34;

    @abc.abstractmethod
    def service(self, handler_call_details):
        &#34;&#34;&#34;Returns the handler for servicing the RPC.

        Args:
          handler_call_details: A HandlerCallDetails describing the RPC.

        Returns:
          An RpcMethodHandler with which the RPC may be serviced if the
          implementation chooses to service this RPC, or None otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError()


class ServiceRpcHandler(six.with_metaclass(abc.ABCMeta, GenericRpcHandler)):
    &#34;&#34;&#34;An implementation of RPC methods belonging to a service.

    A service handles RPC methods with structured names of the form
    &#39;/Service.Name/Service.Method&#39;, where &#39;Service.Name&#39; is the value
    returned by service_name(), and &#39;Service.Method&#39; is the method
    name.  A service can have multiple method names, but only a single
    service name.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def service_name(self):
        &#34;&#34;&#34;Returns this service&#39;s name.

        Returns:
          The service name.
        &#34;&#34;&#34;
        raise NotImplementedError()


####################  Service-Side Interceptor Interfaces  #####################


class ServerInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting incoming RPCs on the service-side.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_service(self, continuation, handler_call_details):
        &#34;&#34;&#34;Intercepts incoming RPCs before handing them over to a handler.

        Args:
          continuation: A function that takes a HandlerCallDetails and
            proceeds to invoke the next interceptor in the chain, if any,
            or the RPC handler lookup logic, with the call details passed
            as an argument, and returns an RpcMethodHandler instance if
            the RPC is considered serviced, or None otherwise.
          handler_call_details: A HandlerCallDetails describing the RPC.

        Returns:
          An RpcMethodHandler with which the RPC may be serviced if the
          interceptor chooses to service this RPC, or None otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError()


#############################  Server Interface  ###############################


class Server(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Services RPCs.&#34;&#34;&#34;

    @abc.abstractmethod
    def add_generic_rpc_handlers(self, generic_rpc_handlers):
        &#34;&#34;&#34;Registers GenericRpcHandlers with this Server.

        This method is only safe to call before the server is started.

        Args:
          generic_rpc_handlers: An iterable of GenericRpcHandlers that will be
          used to service RPCs.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_insecure_port(self, address):
        &#34;&#34;&#34;Opens an insecure port for accepting RPCs.

        This method may only be called before starting the server.

        Args:
          address: The address for which to open a port. If the port is 0,
            or not specified in the address, then gRPC runtime will choose a port.

        Returns:
          An integer port on which server will accept RPC requests.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_secure_port(self, address, server_credentials):
        &#34;&#34;&#34;Opens a secure port for accepting RPCs.

        This method may only be called before starting the server.

        Args:
          address: The address for which to open a port.
            if the port is 0, or not specified in the address, then gRPC
            runtime will choose a port.
          server_credentials: A ServerCredentials object.

        Returns:
          An integer port on which server will accept RPC requests.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def start(self):
        &#34;&#34;&#34;Starts this Server.

        This method may only be called once. (i.e. it is not idempotent).
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def stop(self, grace):
        &#34;&#34;&#34;Stops this Server.

        This method immediately stop service of new RPCs in all cases.

        If a grace period is specified, this method returns immediately
        and all RPCs active at the end of the grace period are aborted.
        If a grace period is not specified (by passing None for `grace`),
        all existing RPCs are aborted immediately and this method
        blocks until the last RPC handler terminates.

        This method is idempotent and may be called at any time.
        Passing a smaller grace value in a subsequent call will have
        the effect of stopping the Server sooner (passing None will
        have the effect of stopping the server immediately). Passing
        a larger grace value in a subsequent call *will not* have the
        effect of stopping the server later (i.e. the most restrictive
        grace value is used).

        Args:
          grace: A duration of time in seconds or None.

        Returns:
          A threading.Event that will be set when this Server has completely
          stopped, i.e. when running RPCs either complete or are aborted and
          all handlers have terminated.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def wait_for_termination(self, timeout=None):
        &#34;&#34;&#34;Block current thread until the server stops.

        This is an EXPERIMENTAL API.

        The wait will not consume computational resources during blocking, and
        it will block until one of the two following conditions are met:

        1) The server is stopped or terminated;
        2) A timeout occurs if timeout is not `None`.

        The timeout argument works in the same way as `threading.Event.wait()`.
        https://docs.python.org/3/library/threading.html#threading.Event.wait

        Args:
          timeout: A floating point number specifying a timeout for the
            operation in seconds.

        Returns:
          A bool indicates if the operation times out.
        &#34;&#34;&#34;
        raise NotImplementedError()


#################################  Functions    ################################


def unary_unary_rpc_method_handler(behavior,
                                   request_deserializer=None,
                                   response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a unary-unary RPC method.

    Args:
      behavior: The implementation of an RPC that accepts one request
        and returns one response.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(False, False, request_deserializer,
                                       response_serializer, behavior, None,
                                       None, None)


def unary_stream_rpc_method_handler(behavior,
                                    request_deserializer=None,
                                    response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a unary-stream RPC method.

    Args:
      behavior: The implementation of an RPC that accepts one request
        and returns an iterator of response values.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(False, True, request_deserializer,
                                       response_serializer, None, behavior,
                                       None, None)


def stream_unary_rpc_method_handler(behavior,
                                    request_deserializer=None,
                                    response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a stream-unary RPC method.

    Args:
      behavior: The implementation of an RPC that accepts an iterator of
        request values and returns a single response value.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(True, False, request_deserializer,
                                       response_serializer, None, None,
                                       behavior, None)


def stream_stream_rpc_method_handler(behavior,
                                     request_deserializer=None,
                                     response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a stream-stream RPC method.

    Args:
      behavior: The implementation of an RPC that accepts an iterator of
        request values and returns an iterator of response values.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(True, True, request_deserializer,
                                       response_serializer, None, None, None,
                                       behavior)


def method_handlers_generic_handler(service, method_handlers):
    &#34;&#34;&#34;Creates a GenericRpcHandler from RpcMethodHandlers.

    Args:
      service: The name of the service that is implemented by the
        method_handlers.
      method_handlers: A dictionary that maps method names to corresponding
        RpcMethodHandler.

    Returns:
      A GenericRpcHandler. This is typically added to the grpc.Server object
      with add_generic_rpc_handlers() before starting the server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.DictionaryGenericHandler(service, method_handlers)


def ssl_channel_credentials(root_certificates=None,
                            private_key=None,
                            certificate_chain=None):
    &#34;&#34;&#34;Creates a ChannelCredentials for use with an SSL-enabled Channel.

    Args:
      root_certificates: The PEM-encoded root certificates as a byte string,
        or None to retrieve them from a default location chosen by gRPC
        runtime.
      private_key: The PEM-encoded private key as a byte string, or None if no
        private key should be used.
      certificate_chain: The PEM-encoded certificate chain as a byte string
        to use or or None if no certificate chain should be used.

    Returns:
      A ChannelCredentials for use with an SSL-enabled Channel.
    &#34;&#34;&#34;
    return ChannelCredentials(
        _cygrpc.SSLChannelCredentials(root_certificates, private_key,
                                      certificate_chain))


def metadata_call_credentials(metadata_plugin, name=None):
    &#34;&#34;&#34;Construct CallCredentials from an AuthMetadataPlugin.

    Args:
      metadata_plugin: An AuthMetadataPlugin to use for authentication.
      name: An optional name for the plugin.

    Returns:
      A CallCredentials.
    &#34;&#34;&#34;
    from grpc import _plugin_wrapping  # pylint: disable=cyclic-import
    return _plugin_wrapping.metadata_plugin_call_credentials(
        metadata_plugin, name)


def access_token_call_credentials(access_token):
    &#34;&#34;&#34;Construct CallCredentials from an access token.

    Args:
      access_token: A string to place directly in the http request
        authorization header, for example
        &#34;authorization: Bearer &lt;access_token&gt;&#34;.

    Returns:
      A CallCredentials.
    &#34;&#34;&#34;
    from grpc import _auth  # pylint: disable=cyclic-import
    from grpc import _plugin_wrapping  # pylint: disable=cyclic-import
    return _plugin_wrapping.metadata_plugin_call_credentials(
        _auth.AccessTokenAuthMetadataPlugin(access_token), None)


def composite_call_credentials(*call_credentials):
    &#34;&#34;&#34;Compose multiple CallCredentials to make a new CallCredentials.

    Args:
      *call_credentials: At least two CallCredentials objects.

    Returns:
      A CallCredentials object composed of the given CallCredentials objects.
    &#34;&#34;&#34;
    return CallCredentials(
        _cygrpc.CompositeCallCredentials(
            tuple(single_call_credentials._credentials
                  for single_call_credentials in call_credentials)))


def composite_channel_credentials(channel_credentials, *call_credentials):
    &#34;&#34;&#34;Compose a ChannelCredentials and one or more CallCredentials objects.

    Args:
      channel_credentials: A ChannelCredentials object.
      *call_credentials: One or more CallCredentials objects.

    Returns:
      A ChannelCredentials composed of the given ChannelCredentials and
        CallCredentials objects.
    &#34;&#34;&#34;
    return ChannelCredentials(
        _cygrpc.CompositeChannelCredentials(
            tuple(single_call_credentials._credentials
                  for single_call_credentials in call_credentials),
            channel_credentials._credentials))


def ssl_server_credentials(private_key_certificate_chain_pairs,
                           root_certificates=None,
                           require_client_auth=False):
    &#34;&#34;&#34;Creates a ServerCredentials for use with an SSL-enabled Server.

    Args:
      private_key_certificate_chain_pairs: A list of pairs of the form
        [PEM-encoded private key, PEM-encoded certificate chain].
      root_certificates: An optional byte string of PEM-encoded client root
        certificates that the server will use to verify client authentication.
        If omitted, require_client_auth must also be False.
      require_client_auth: A boolean indicating whether or not to require
        clients to be authenticated. May only be True if root_certificates
        is not None.

    Returns:
      A ServerCredentials for use with an SSL-enabled Server. Typically, this
      object is an argument to add_secure_port() method during server setup.
    &#34;&#34;&#34;
    if not private_key_certificate_chain_pairs:
        raise ValueError(
            &#39;At least one private key-certificate chain pair is required!&#39;)
    elif require_client_auth and root_certificates is None:
        raise ValueError(
            &#39;Illegal to require client auth without providing root certificates!&#39;
        )
    else:
        return ServerCredentials(
            _cygrpc.server_credentials_ssl(root_certificates, [
                _cygrpc.SslPemKeyCertPair(key, pem)
                for key, pem in private_key_certificate_chain_pairs
            ], require_client_auth))


def ssl_server_certificate_configuration(private_key_certificate_chain_pairs,
                                         root_certificates=None):
    &#34;&#34;&#34;Creates a ServerCertificateConfiguration for use with a Server.

    Args:
      private_key_certificate_chain_pairs: A collection of pairs of
        the form [PEM-encoded private key, PEM-encoded certificate
        chain].
      root_certificates: An optional byte string of PEM-encoded client root
        certificates that the server will use to verify client authentication.

    Returns:
      A ServerCertificateConfiguration that can be returned in the certificate
        configuration fetching callback.
    &#34;&#34;&#34;
    if private_key_certificate_chain_pairs:
        return ServerCertificateConfiguration(
            _cygrpc.server_certificate_config_ssl(root_certificates, [
                _cygrpc.SslPemKeyCertPair(key, pem)
                for key, pem in private_key_certificate_chain_pairs
            ]))
    else:
        raise ValueError(
            &#39;At least one private key-certificate chain pair is required!&#39;)


def dynamic_ssl_server_credentials(initial_certificate_configuration,
                                   certificate_configuration_fetcher,
                                   require_client_authentication=False):
    &#34;&#34;&#34;Creates a ServerCredentials for use with an SSL-enabled Server.

    Args:
      initial_certificate_configuration (ServerCertificateConfiguration): The
        certificate configuration with which the server will be initialized.
      certificate_configuration_fetcher (callable): A callable that takes no
        arguments and should return a ServerCertificateConfiguration to
        replace the server&#39;s current certificate, or None for no change
        (i.e., the server will continue its current certificate
        config). The library will call this callback on *every* new
        client connection before starting the TLS handshake with the
        client, thus allowing the user application to optionally
        return a new ServerCertificateConfiguration that the server will then
        use for the handshake.
      require_client_authentication: A boolean indicating whether or not to
        require clients to be authenticated.

    Returns:
      A ServerCredentials.
    &#34;&#34;&#34;
    return ServerCredentials(
        _cygrpc.server_credentials_ssl_dynamic_cert_config(
            initial_certificate_configuration,
            certificate_configuration_fetcher, require_client_authentication))


@enum.unique
class LocalConnectionType(enum.Enum):
    &#34;&#34;&#34;Types of local connection for local credential creation.

    Attributes:
      UDS: Unix domain socket connections
      LOCAL_TCP: Local TCP connections.
    &#34;&#34;&#34;
    UDS = _cygrpc.LocalConnectionType.uds
    LOCAL_TCP = _cygrpc.LocalConnectionType.local_tcp


def local_channel_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):
    &#34;&#34;&#34;Creates a local ChannelCredentials used for local connections.

    This is an EXPERIMENTAL API.

    Local credentials are used by local TCP endpoints (e.g. localhost:10000)
    also UDS connections.

    The connections created by local channel credentials are not
    encrypted, but will be checked if they are local or not.
    The UDS connections are considered secure by providing peer authentication
    and data confidentiality while TCP connections are considered insecure.

    It is allowed to transmit call credentials over connections created by
    local channel credentials.

    Local channel credentials are useful for 1) eliminating insecure_channel usage;
    2) enable unit testing for call credentials without setting up secrets.

    Args:
      local_connect_type: Local connection type (either
        grpc.LocalConnectionType.UDS or grpc.LocalConnectionType.LOCAL_TCP)

    Returns:
      A ChannelCredentials for use with a local Channel
    &#34;&#34;&#34;
    return ChannelCredentials(
        _cygrpc.channel_credentials_local(local_connect_type.value))


def local_server_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):
    &#34;&#34;&#34;Creates a local ServerCredentials used for local connections.

    This is an EXPERIMENTAL API.

    Local credentials are used by local TCP endpoints (e.g. localhost:10000)
    also UDS connections.

    The connections created by local server credentials are not
    encrypted, but will be checked if they are local or not.
    The UDS connections are considered secure by providing peer authentication
    and data confidentiality while TCP connections are considered insecure.

    It is allowed to transmit call credentials over connections created by local
    server credentials.

    Local server credentials are useful for 1) eliminating insecure_channel usage;
    2) enable unit testing for call credentials without setting up secrets.

    Args:
      local_connect_type: Local connection type (either
        grpc.LocalConnectionType.UDS or grpc.LocalConnectionType.LOCAL_TCP)

    Returns:
      A ServerCredentials for use with a local Server
    &#34;&#34;&#34;
    return ServerCredentials(
        _cygrpc.server_credentials_local(local_connect_type.value))


def channel_ready_future(channel):
    &#34;&#34;&#34;Creates a Future that tracks when a Channel is ready.

    Cancelling the Future does not affect the channel&#39;s state machine.
    It merely decouples the Future from channel state machine.

    Args:
      channel: A Channel object.

    Returns:
      A Future object that matures when the channel connectivity is
      ChannelConnectivity.READY.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.channel_ready_future(channel)


def insecure_channel(target, options=None, compression=None):
    &#34;&#34;&#34;Creates an insecure Channel to a server.

    The returned Channel is thread-safe.

    Args:
      target: The server address
      options: An optional list of key-value pairs (channel args
        in gRPC Core runtime) to configure the channel.
      compression: An optional value indicating the compression method to be
        used over the lifetime of the channel. This is an EXPERIMENTAL option.

    Returns:
      A Channel.
    &#34;&#34;&#34;
    from grpc import _channel  # pylint: disable=cyclic-import
    return _channel.Channel(target, ()
                            if options is None else options, None, compression)


def secure_channel(target, credentials, options=None, compression=None):
    &#34;&#34;&#34;Creates a secure Channel to a server.

    The returned Channel is thread-safe.

    Args:
      target: The server address.
      credentials: A ChannelCredentials instance.
      options: An optional list of key-value pairs (channel args
        in gRPC Core runtime) to configure the channel.
      compression: An optional value indicating the compression method to be
        used over the lifetime of the channel. This is an EXPERIMENTAL option.

    Returns:
      A Channel.
    &#34;&#34;&#34;
    from grpc import _channel  # pylint: disable=cyclic-import
    return _channel.Channel(target, () if options is None else options,
                            credentials._credentials, compression)


def intercept_channel(channel, *interceptors):
    &#34;&#34;&#34;Intercepts a channel through a set of interceptors.

    This is an EXPERIMENTAL API.

    Args:
      channel: A Channel.
      interceptors: Zero or more objects of type
        UnaryUnaryClientInterceptor,
        UnaryStreamClientInterceptor,
        StreamUnaryClientInterceptor, or
        StreamStreamClientInterceptor.
        Interceptors are given control in the order they are listed.

    Returns:
      A Channel that intercepts each invocation via the provided interceptors.

    Raises:
      TypeError: If interceptor does not derive from any of
        UnaryUnaryClientInterceptor,
        UnaryStreamClientInterceptor,
        StreamUnaryClientInterceptor, or
        StreamStreamClientInterceptor.
    &#34;&#34;&#34;
    from grpc import _interceptor  # pylint: disable=cyclic-import
    return _interceptor.intercept_channel(channel, *interceptors)


def server(thread_pool,
           handlers=None,
           interceptors=None,
           options=None,
           maximum_concurrent_rpcs=None,
           compression=None):
    &#34;&#34;&#34;Creates a Server with which RPCs can be serviced.

    Args:
      thread_pool: A futures.ThreadPoolExecutor to be used by the Server
        to execute RPC handlers.
      handlers: An optional list of GenericRpcHandlers used for executing RPCs.
        More handlers may be added by calling add_generic_rpc_handlers any time
        before the server is started.
      interceptors: An optional list of ServerInterceptor objects that observe
        and optionally manipulate the incoming RPCs before handing them over to
        handlers. The interceptors are given control in the order they are
        specified. This is an EXPERIMENTAL API.
      options: An optional list of key-value pairs (channel args in gRPC runtime)
        to configure the channel.
      maximum_concurrent_rpcs: The maximum number of concurrent RPCs this server
        will service before returning RESOURCE_EXHAUSTED status, or None to
        indicate no limit.
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This compression algorithm will be used for the
        lifetime of the server unless overridden. This is an EXPERIMENTAL option.

    Returns:
      A Server object.
    &#34;&#34;&#34;
    from grpc import _server  # pylint: disable=cyclic-import
    return _server.create_server(thread_pool, ()
                                 if handlers is None else handlers, ()
                                 if interceptors is None else interceptors, ()
                                 if options is None else options,
                                 maximum_concurrent_rpcs, compression)


@contextlib.contextmanager
def _create_servicer_context(rpc_event, state, request_deserializer):
    from grpc import _server  # pylint: disable=cyclic-import
    context = _server._Context(rpc_event, state, request_deserializer)
    yield context
    context._finalize_state()  # pylint: disable=protected-access


@enum.unique
class Compression(enum.IntEnum):
    &#34;&#34;&#34;Indicates the compression method to be used for an RPC.

       This enumeration is part of an EXPERIMENTAL API.

       Attributes:
        NoCompression: Do not use compression algorithm.
        Deflate: Use &#34;Deflate&#34; compression algorithm.
        Gzip: Use &#34;Gzip&#34; compression algorithm.
    &#34;&#34;&#34;
    NoCompression = _compression.NoCompression
    Deflate = _compression.Deflate
    Gzip = _compression.Gzip


###################################  __all__  #################################

__all__ = (
    &#39;FutureTimeoutError&#39;,
    &#39;FutureCancelledError&#39;,
    &#39;Future&#39;,
    &#39;ChannelConnectivity&#39;,
    &#39;StatusCode&#39;,
    &#39;Status&#39;,
    &#39;RpcError&#39;,
    &#39;RpcContext&#39;,
    &#39;Call&#39;,
    &#39;ChannelCredentials&#39;,
    &#39;CallCredentials&#39;,
    &#39;AuthMetadataContext&#39;,
    &#39;AuthMetadataPluginCallback&#39;,
    &#39;AuthMetadataPlugin&#39;,
    &#39;Compression&#39;,
    &#39;ClientCallDetails&#39;,
    &#39;ServerCertificateConfiguration&#39;,
    &#39;ServerCredentials&#39;,
    &#39;LocalConnectionType&#39;,
    &#39;UnaryUnaryMultiCallable&#39;,
    &#39;UnaryStreamMultiCallable&#39;,
    &#39;StreamUnaryMultiCallable&#39;,
    &#39;StreamStreamMultiCallable&#39;,
    &#39;UnaryUnaryClientInterceptor&#39;,
    &#39;UnaryStreamClientInterceptor&#39;,
    &#39;StreamUnaryClientInterceptor&#39;,
    &#39;StreamStreamClientInterceptor&#39;,
    &#39;Channel&#39;,
    &#39;ServicerContext&#39;,
    &#39;RpcMethodHandler&#39;,
    &#39;HandlerCallDetails&#39;,
    &#39;GenericRpcHandler&#39;,
    &#39;ServiceRpcHandler&#39;,
    &#39;Server&#39;,
    &#39;ServerInterceptor&#39;,
    &#39;unary_unary_rpc_method_handler&#39;,
    &#39;unary_stream_rpc_method_handler&#39;,
    &#39;stream_unary_rpc_method_handler&#39;,
    &#39;stream_stream_rpc_method_handler&#39;,
    &#39;method_handlers_generic_handler&#39;,
    &#39;ssl_channel_credentials&#39;,
    &#39;metadata_call_credentials&#39;,
    &#39;access_token_call_credentials&#39;,
    &#39;composite_call_credentials&#39;,
    &#39;composite_channel_credentials&#39;,
    &#39;local_channel_credentials&#39;,
    &#39;local_server_credentials&#39;,
    &#39;ssl_server_credentials&#39;,
    &#39;ssl_server_certificate_configuration&#39;,
    &#39;dynamic_ssl_server_credentials&#39;,
    &#39;channel_ready_future&#39;,
    &#39;insecure_channel&#39;,
    &#39;secure_channel&#39;,
    &#39;intercept_channel&#39;,
    &#39;server&#39;,
)

############################### Extension Shims ################################

# Here to maintain backwards compatibility; avoid using these in new code!
try:
    import grpc_tools
    sys.modules.update({&#39;grpc.tools&#39;: grpc_tools})
except ImportError:
    pass
try:
    import grpc_health
    sys.modules.update({&#39;grpc.health&#39;: grpc_health})
except ImportError:
    pass
try:
    import grpc_reflection
    sys.modules.update({&#39;grpc.reflection&#39;: grpc_reflection})
except ImportError:
    pass</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="grpc.beta" href="beta/index.html">grpc.beta</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="grpc.experimental" href="experimental/index.html">grpc.experimental</a></code></dt>
<dd>
<section class="desc"><p>gRPC's experimental APIs </p></section>
</dd>
<dt><code class="name"><a title="grpc.framework" href="framework/index.html">grpc.framework</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grpc.access_token_call_credentials"><code class="name flex">
<span>def <span class="ident">access_token_call_credentials</span></span>(<span>access_token)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct CallCredentials from an access token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong></dt>
<dd>A string to place directly in the http request
authorization header, for example
"authorization: Bearer <access_token>".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A CallCredentials.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def access_token_call_credentials(access_token):
    &#34;&#34;&#34;Construct CallCredentials from an access token.

    Args:
      access_token: A string to place directly in the http request
        authorization header, for example
        &#34;authorization: Bearer &lt;access_token&gt;&#34;.

    Returns:
      A CallCredentials.
    &#34;&#34;&#34;
    from grpc import _auth  # pylint: disable=cyclic-import
    from grpc import _plugin_wrapping  # pylint: disable=cyclic-import
    return _plugin_wrapping.metadata_plugin_call_credentials(
        _auth.AccessTokenAuthMetadataPlugin(access_token), None)</code></pre>
</details>
</dd>
<dt id="grpc.channel_ready_future"><code class="name flex">
<span>def <span class="ident">channel_ready_future</span></span>(<span>channel)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a Future that tracks when a Channel is ready.</p>
<p>Cancelling the Future does not affect the channel's state machine.
It merely decouples the Future from channel state machine.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong></dt>
<dd>A Channel object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <a title="grpc.Future" href="#grpc.Future"><code>Future</code></a> <code>object</code> <code>that</code> <code>matures</code> <code>when</code> <code>the</code> <code>channel</code> <code>connectivity</code> <code>is</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>ChannelConnectivity.READY.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channel_ready_future(channel):
    &#34;&#34;&#34;Creates a Future that tracks when a Channel is ready.

    Cancelling the Future does not affect the channel&#39;s state machine.
    It merely decouples the Future from channel state machine.

    Args:
      channel: A Channel object.

    Returns:
      A Future object that matures when the channel connectivity is
      ChannelConnectivity.READY.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.channel_ready_future(channel)</code></pre>
</details>
</dd>
<dt id="grpc.composite_call_credentials"><code class="name flex">
<span>def <span class="ident">composite_call_credentials</span></span>(<span>*call_credentials)</span>
</code></dt>
<dd>
<section class="desc"><p>Compose multiple CallCredentials to make a new CallCredentials.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*call_credentials</code></strong></dt>
<dd>At least two CallCredentials objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A CallCredentials object composed of the given CallCredentials objects.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def composite_call_credentials(*call_credentials):
    &#34;&#34;&#34;Compose multiple CallCredentials to make a new CallCredentials.

    Args:
      *call_credentials: At least two CallCredentials objects.

    Returns:
      A CallCredentials object composed of the given CallCredentials objects.
    &#34;&#34;&#34;
    return CallCredentials(
        _cygrpc.CompositeCallCredentials(
            tuple(single_call_credentials._credentials
                  for single_call_credentials in call_credentials)))</code></pre>
</details>
</dd>
<dt id="grpc.composite_channel_credentials"><code class="name flex">
<span>def <span class="ident">composite_channel_credentials</span></span>(<span>channel_credentials, *call_credentials)</span>
</code></dt>
<dd>
<section class="desc"><p>Compose a ChannelCredentials and one or more CallCredentials objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_credentials</code></strong></dt>
<dd>A ChannelCredentials object.</dd>
<dt><strong><code>*call_credentials</code></strong></dt>
<dd>One or more CallCredentials objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <a title="grpc.ChannelCredentials" href="#grpc.ChannelCredentials"><code>ChannelCredentials</code></a> <code>composed</code> of <code>the</code> <code>given</code> <a title="grpc.ChannelCredentials" href="#grpc.ChannelCredentials"><code>ChannelCredentials</code></a> <code>and</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>CallCredentials objects.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def composite_channel_credentials(channel_credentials, *call_credentials):
    &#34;&#34;&#34;Compose a ChannelCredentials and one or more CallCredentials objects.

    Args:
      channel_credentials: A ChannelCredentials object.
      *call_credentials: One or more CallCredentials objects.

    Returns:
      A ChannelCredentials composed of the given ChannelCredentials and
        CallCredentials objects.
    &#34;&#34;&#34;
    return ChannelCredentials(
        _cygrpc.CompositeChannelCredentials(
            tuple(single_call_credentials._credentials
                  for single_call_credentials in call_credentials),
            channel_credentials._credentials))</code></pre>
</details>
</dd>
<dt id="grpc.dynamic_ssl_server_credentials"><code class="name flex">
<span>def <span class="ident">dynamic_ssl_server_credentials</span></span>(<span>initial_certificate_configuration, certificate_configuration_fetcher, require_client_authentication=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a ServerCredentials for use with an SSL-enabled Server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_certificate_configuration</code></strong> :&ensp;<a title="grpc.ServerCertificateConfiguration" href="#grpc.ServerCertificateConfiguration"><code>ServerCertificateConfiguration</code></a></dt>
<dd>The
certificate configuration with which the server will be initialized.</dd>
<dt><strong><code>certificate_configuration_fetcher</code></strong> :&ensp;<code>callable</code></dt>
<dd>A callable that takes no
arguments and should return a ServerCertificateConfiguration to
replace the server's current certificate, or None for no change
(i.e., the server will continue its current certificate
config). The library will call this callback on <em>every</em> new
client connection before starting the TLS handshake with the
client, thus allowing the user application to optionally
return a new ServerCertificateConfiguration that the server will then
use for the handshake.</dd>
<dt><strong><code>require_client_authentication</code></strong></dt>
<dd>A boolean indicating whether or not to
require clients to be authenticated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A ServerCredentials.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_ssl_server_credentials(initial_certificate_configuration,
                                   certificate_configuration_fetcher,
                                   require_client_authentication=False):
    &#34;&#34;&#34;Creates a ServerCredentials for use with an SSL-enabled Server.

    Args:
      initial_certificate_configuration (ServerCertificateConfiguration): The
        certificate configuration with which the server will be initialized.
      certificate_configuration_fetcher (callable): A callable that takes no
        arguments and should return a ServerCertificateConfiguration to
        replace the server&#39;s current certificate, or None for no change
        (i.e., the server will continue its current certificate
        config). The library will call this callback on *every* new
        client connection before starting the TLS handshake with the
        client, thus allowing the user application to optionally
        return a new ServerCertificateConfiguration that the server will then
        use for the handshake.
      require_client_authentication: A boolean indicating whether or not to
        require clients to be authenticated.

    Returns:
      A ServerCredentials.
    &#34;&#34;&#34;
    return ServerCredentials(
        _cygrpc.server_credentials_ssl_dynamic_cert_config(
            initial_certificate_configuration,
            certificate_configuration_fetcher, require_client_authentication))</code></pre>
</details>
</dd>
<dt id="grpc.insecure_channel"><code class="name flex">
<span>def <span class="ident">insecure_channel</span></span>(<span>target, options=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an insecure Channel to a server.</p>
<p>The returned Channel is thread-safe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>The server address</dd>
<dt><strong><code>options</code></strong></dt>
<dd>An optional list of key-value pairs (channel args
in gRPC Core runtime) to configure the channel.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An optional value indicating the compression method to be
used over the lifetime of the channel. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insecure_channel(target, options=None, compression=None):
    &#34;&#34;&#34;Creates an insecure Channel to a server.

    The returned Channel is thread-safe.

    Args:
      target: The server address
      options: An optional list of key-value pairs (channel args
        in gRPC Core runtime) to configure the channel.
      compression: An optional value indicating the compression method to be
        used over the lifetime of the channel. This is an EXPERIMENTAL option.

    Returns:
      A Channel.
    &#34;&#34;&#34;
    from grpc import _channel  # pylint: disable=cyclic-import
    return _channel.Channel(target, ()
                            if options is None else options, None, compression)</code></pre>
</details>
</dd>
<dt id="grpc.intercept_channel"><code class="name flex">
<span>def <span class="ident">intercept_channel</span></span>(<span>channel, *interceptors)</span>
</code></dt>
<dd>
<section class="desc"><p>Intercepts a channel through a set of interceptors.</p>
<p>This is an EXPERIMENTAL API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong></dt>
<dd>A Channel.</dd>
<dt><strong><code>interceptors</code></strong></dt>
<dd>Zero or more objects of type
UnaryUnaryClientInterceptor,
UnaryStreamClientInterceptor,
StreamUnaryClientInterceptor, or
StreamStreamClientInterceptor.
Interceptors are given control in the order they are listed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Channel that intercepts each invocation via the provided interceptors.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>TypeError</code></strong></dt>
<dd>If interceptor does not derive from any of
UnaryUnaryClientInterceptor,
UnaryStreamClientInterceptor,
StreamUnaryClientInterceptor, or
StreamStreamClientInterceptor.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intercept_channel(channel, *interceptors):
    &#34;&#34;&#34;Intercepts a channel through a set of interceptors.

    This is an EXPERIMENTAL API.

    Args:
      channel: A Channel.
      interceptors: Zero or more objects of type
        UnaryUnaryClientInterceptor,
        UnaryStreamClientInterceptor,
        StreamUnaryClientInterceptor, or
        StreamStreamClientInterceptor.
        Interceptors are given control in the order they are listed.

    Returns:
      A Channel that intercepts each invocation via the provided interceptors.

    Raises:
      TypeError: If interceptor does not derive from any of
        UnaryUnaryClientInterceptor,
        UnaryStreamClientInterceptor,
        StreamUnaryClientInterceptor, or
        StreamStreamClientInterceptor.
    &#34;&#34;&#34;
    from grpc import _interceptor  # pylint: disable=cyclic-import
    return _interceptor.intercept_channel(channel, *interceptors)</code></pre>
</details>
</dd>
<dt id="grpc.local_channel_credentials"><code class="name flex">
<span>def <span class="ident">local_channel_credentials</span></span>(<span>local_connect_type=LocalConnectionType.LOCAL_TCP)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a local ChannelCredentials used for local connections.</p>
<p>This is an EXPERIMENTAL API.</p>
<p>Local credentials are used by local TCP endpoints (e.g. localhost:10000)
also UDS connections.</p>
<p>The connections created by local channel credentials are not
encrypted, but will be checked if they are local or not.
The UDS connections are considered secure by providing peer authentication
and data confidentiality while TCP connections are considered insecure.</p>
<p>It is allowed to transmit call credentials over connections created by
local channel credentials.</p>
<p>Local channel credentials are useful for 1) eliminating insecure_channel usage;
2) enable unit testing for call credentials without setting up secrets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_connect_type</code></strong></dt>
<dd>Local connection type (either
grpc.LocalConnectionType.UDS or grpc.LocalConnectionType.LOCAL_TCP)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <a title="grpc.ChannelCredentials" href="#grpc.ChannelCredentials"><code>ChannelCredentials</code></a> <code>for</code> <code>use</code> <code>with</code> <code>a</code> <code>local</code> <a title="grpc.Channel" href="#grpc.Channel"><code>Channel</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_channel_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):
    &#34;&#34;&#34;Creates a local ChannelCredentials used for local connections.

    This is an EXPERIMENTAL API.

    Local credentials are used by local TCP endpoints (e.g. localhost:10000)
    also UDS connections.

    The connections created by local channel credentials are not
    encrypted, but will be checked if they are local or not.
    The UDS connections are considered secure by providing peer authentication
    and data confidentiality while TCP connections are considered insecure.

    It is allowed to transmit call credentials over connections created by
    local channel credentials.

    Local channel credentials are useful for 1) eliminating insecure_channel usage;
    2) enable unit testing for call credentials without setting up secrets.

    Args:
      local_connect_type: Local connection type (either
        grpc.LocalConnectionType.UDS or grpc.LocalConnectionType.LOCAL_TCP)

    Returns:
      A ChannelCredentials for use with a local Channel
    &#34;&#34;&#34;
    return ChannelCredentials(
        _cygrpc.channel_credentials_local(local_connect_type.value))</code></pre>
</details>
</dd>
<dt id="grpc.local_server_credentials"><code class="name flex">
<span>def <span class="ident">local_server_credentials</span></span>(<span>local_connect_type=LocalConnectionType.LOCAL_TCP)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a local ServerCredentials used for local connections.</p>
<p>This is an EXPERIMENTAL API.</p>
<p>Local credentials are used by local TCP endpoints (e.g. localhost:10000)
also UDS connections.</p>
<p>The connections created by local server credentials are not
encrypted, but will be checked if they are local or not.
The UDS connections are considered secure by providing peer authentication
and data confidentiality while TCP connections are considered insecure.</p>
<p>It is allowed to transmit call credentials over connections created by local
server credentials.</p>
<p>Local server credentials are useful for 1) eliminating insecure_channel usage;
2) enable unit testing for call credentials without setting up secrets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>local_connect_type</code></strong></dt>
<dd>Local connection type (either
grpc.LocalConnectionType.UDS or grpc.LocalConnectionType.LOCAL_TCP)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <a title="grpc.ServerCredentials" href="#grpc.ServerCredentials"><code>ServerCredentials</code></a> <code>for</code> <code>use</code> <code>with</code> <code>a</code> <code>local</code> <a title="grpc.Server" href="#grpc.Server"><code>Server</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_server_credentials(local_connect_type=LocalConnectionType.LOCAL_TCP):
    &#34;&#34;&#34;Creates a local ServerCredentials used for local connections.

    This is an EXPERIMENTAL API.

    Local credentials are used by local TCP endpoints (e.g. localhost:10000)
    also UDS connections.

    The connections created by local server credentials are not
    encrypted, but will be checked if they are local or not.
    The UDS connections are considered secure by providing peer authentication
    and data confidentiality while TCP connections are considered insecure.

    It is allowed to transmit call credentials over connections created by local
    server credentials.

    Local server credentials are useful for 1) eliminating insecure_channel usage;
    2) enable unit testing for call credentials without setting up secrets.

    Args:
      local_connect_type: Local connection type (either
        grpc.LocalConnectionType.UDS or grpc.LocalConnectionType.LOCAL_TCP)

    Returns:
      A ServerCredentials for use with a local Server
    &#34;&#34;&#34;
    return ServerCredentials(
        _cygrpc.server_credentials_local(local_connect_type.value))</code></pre>
</details>
</dd>
<dt id="grpc.metadata_call_credentials"><code class="name flex">
<span>def <span class="ident">metadata_call_credentials</span></span>(<span>metadata_plugin, name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct CallCredentials from an AuthMetadataPlugin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata_plugin</code></strong></dt>
<dd>An AuthMetadataPlugin to use for authentication.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>An optional name for the plugin.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A CallCredentials.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_call_credentials(metadata_plugin, name=None):
    &#34;&#34;&#34;Construct CallCredentials from an AuthMetadataPlugin.

    Args:
      metadata_plugin: An AuthMetadataPlugin to use for authentication.
      name: An optional name for the plugin.

    Returns:
      A CallCredentials.
    &#34;&#34;&#34;
    from grpc import _plugin_wrapping  # pylint: disable=cyclic-import
    return _plugin_wrapping.metadata_plugin_call_credentials(
        metadata_plugin, name)</code></pre>
</details>
</dd>
<dt id="grpc.method_handlers_generic_handler"><code class="name flex">
<span>def <span class="ident">method_handlers_generic_handler</span></span>(<span>service, method_handlers)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a GenericRpcHandler from RpcMethodHandlers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>service</code></strong></dt>
<dd>The name of the service that is implemented by the
method_handlers.</dd>
<dt><strong><code>method_handlers</code></strong></dt>
<dd>A dictionary that maps method names to corresponding
RpcMethodHandler.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>GenericRpcHandler.</code> <code>This</code> <code>is</code> <code>typically</code> <code>added</code> <code>to</code> <code>the</code> <a title="grpc.Server" href="#grpc.Server"><code>Server</code></a> <code>object</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>with add_generic_rpc_handlers() before starting the server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_handlers_generic_handler(service, method_handlers):
    &#34;&#34;&#34;Creates a GenericRpcHandler from RpcMethodHandlers.

    Args:
      service: The name of the service that is implemented by the
        method_handlers.
      method_handlers: A dictionary that maps method names to corresponding
        RpcMethodHandler.

    Returns:
      A GenericRpcHandler. This is typically added to the grpc.Server object
      with add_generic_rpc_handlers() before starting the server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.DictionaryGenericHandler(service, method_handlers)</code></pre>
</details>
</dd>
<dt id="grpc.secure_channel"><code class="name flex">
<span>def <span class="ident">secure_channel</span></span>(<span>target, credentials, options=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a secure Channel to a server.</p>
<p>The returned Channel is thread-safe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>The server address.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>A ChannelCredentials instance.</dd>
<dt><strong><code>options</code></strong></dt>
<dd>An optional list of key-value pairs (channel args
in gRPC Core runtime) to configure the channel.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An optional value indicating the compression method to be
used over the lifetime of the channel. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def secure_channel(target, credentials, options=None, compression=None):
    &#34;&#34;&#34;Creates a secure Channel to a server.

    The returned Channel is thread-safe.

    Args:
      target: The server address.
      credentials: A ChannelCredentials instance.
      options: An optional list of key-value pairs (channel args
        in gRPC Core runtime) to configure the channel.
      compression: An optional value indicating the compression method to be
        used over the lifetime of the channel. This is an EXPERIMENTAL option.

    Returns:
      A Channel.
    &#34;&#34;&#34;
    from grpc import _channel  # pylint: disable=cyclic-import
    return _channel.Channel(target, () if options is None else options,
                            credentials._credentials, compression)</code></pre>
</details>
</dd>
<dt id="grpc.server"><code class="name flex">
<span>def <span class="ident">server</span></span>(<span>thread_pool, handlers=None, interceptors=None, options=None, maximum_concurrent_rpcs=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a Server with which RPCs can be serviced.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_pool</code></strong></dt>
<dd>A futures.ThreadPoolExecutor to be used by the Server
to execute RPC handlers.</dd>
<dt><strong><code>handlers</code></strong></dt>
<dd>An optional list of GenericRpcHandlers used for executing RPCs.
More handlers may be added by calling add_generic_rpc_handlers any time
before the server is started.</dd>
<dt><strong><code>interceptors</code></strong></dt>
<dd>An optional list of ServerInterceptor objects that observe
and optionally manipulate the incoming RPCs before handing them over to
handlers. The interceptors are given control in the order they are
specified. This is an EXPERIMENTAL API.</dd>
<dt><strong><code>options</code></strong></dt>
<dd>An optional list of key-value pairs (channel args in gRPC runtime)
to configure the channel.</dd>
<dt><strong><code>maximum_concurrent_rpcs</code></strong></dt>
<dd>The maximum number of concurrent RPCs this server
will service before returning RESOURCE_EXHAUSTED status, or None to
indicate no limit.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This compression algorithm will be used for the
lifetime of the server unless overridden. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Server object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server(thread_pool,
           handlers=None,
           interceptors=None,
           options=None,
           maximum_concurrent_rpcs=None,
           compression=None):
    &#34;&#34;&#34;Creates a Server with which RPCs can be serviced.

    Args:
      thread_pool: A futures.ThreadPoolExecutor to be used by the Server
        to execute RPC handlers.
      handlers: An optional list of GenericRpcHandlers used for executing RPCs.
        More handlers may be added by calling add_generic_rpc_handlers any time
        before the server is started.
      interceptors: An optional list of ServerInterceptor objects that observe
        and optionally manipulate the incoming RPCs before handing them over to
        handlers. The interceptors are given control in the order they are
        specified. This is an EXPERIMENTAL API.
      options: An optional list of key-value pairs (channel args in gRPC runtime)
        to configure the channel.
      maximum_concurrent_rpcs: The maximum number of concurrent RPCs this server
        will service before returning RESOURCE_EXHAUSTED status, or None to
        indicate no limit.
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This compression algorithm will be used for the
        lifetime of the server unless overridden. This is an EXPERIMENTAL option.

    Returns:
      A Server object.
    &#34;&#34;&#34;
    from grpc import _server  # pylint: disable=cyclic-import
    return _server.create_server(thread_pool, ()
                                 if handlers is None else handlers, ()
                                 if interceptors is None else interceptors, ()
                                 if options is None else options,
                                 maximum_concurrent_rpcs, compression)</code></pre>
</details>
</dd>
<dt id="grpc.ssl_channel_credentials"><code class="name flex">
<span>def <span class="ident">ssl_channel_credentials</span></span>(<span>root_certificates=None, private_key=None, certificate_chain=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a ChannelCredentials for use with an SSL-enabled Channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_certificates</code></strong></dt>
<dd>The PEM-encoded root certificates as a byte string,
or None to retrieve them from a default location chosen by gRPC
runtime.</dd>
<dt><strong><code>private_key</code></strong></dt>
<dd>The PEM-encoded private key as a byte string, or None if no
private key should be used.</dd>
<dt><strong><code>certificate_chain</code></strong></dt>
<dd>The PEM-encoded certificate chain as a byte string
to use or or None if no certificate chain should be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A ChannelCredentials for use with an SSL-enabled Channel.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ssl_channel_credentials(root_certificates=None,
                            private_key=None,
                            certificate_chain=None):
    &#34;&#34;&#34;Creates a ChannelCredentials for use with an SSL-enabled Channel.

    Args:
      root_certificates: The PEM-encoded root certificates as a byte string,
        or None to retrieve them from a default location chosen by gRPC
        runtime.
      private_key: The PEM-encoded private key as a byte string, or None if no
        private key should be used.
      certificate_chain: The PEM-encoded certificate chain as a byte string
        to use or or None if no certificate chain should be used.

    Returns:
      A ChannelCredentials for use with an SSL-enabled Channel.
    &#34;&#34;&#34;
    return ChannelCredentials(
        _cygrpc.SSLChannelCredentials(root_certificates, private_key,
                                      certificate_chain))</code></pre>
</details>
</dd>
<dt id="grpc.ssl_server_certificate_configuration"><code class="name flex">
<span>def <span class="ident">ssl_server_certificate_configuration</span></span>(<span>private_key_certificate_chain_pairs, root_certificates=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a ServerCertificateConfiguration for use with a Server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>private_key_certificate_chain_pairs</code></strong></dt>
<dd>A collection of pairs of
the form [PEM-encoded private key, PEM-encoded certificate
chain].</dd>
<dt><strong><code>root_certificates</code></strong></dt>
<dd>An optional byte string of PEM-encoded client root
certificates that the server will use to verify client authentication.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <a title="grpc.ServerCertificateConfiguration" href="#grpc.ServerCertificateConfiguration"><code>ServerCertificateConfiguration</code></a> <code>that</code> <code>can</code> <code>be</code> <code>returned</code> <code>in</code> <code>the</code> <code>certificate</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>configuration fetching callback.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ssl_server_certificate_configuration(private_key_certificate_chain_pairs,
                                         root_certificates=None):
    &#34;&#34;&#34;Creates a ServerCertificateConfiguration for use with a Server.

    Args:
      private_key_certificate_chain_pairs: A collection of pairs of
        the form [PEM-encoded private key, PEM-encoded certificate
        chain].
      root_certificates: An optional byte string of PEM-encoded client root
        certificates that the server will use to verify client authentication.

    Returns:
      A ServerCertificateConfiguration that can be returned in the certificate
        configuration fetching callback.
    &#34;&#34;&#34;
    if private_key_certificate_chain_pairs:
        return ServerCertificateConfiguration(
            _cygrpc.server_certificate_config_ssl(root_certificates, [
                _cygrpc.SslPemKeyCertPair(key, pem)
                for key, pem in private_key_certificate_chain_pairs
            ]))
    else:
        raise ValueError(
            &#39;At least one private key-certificate chain pair is required!&#39;)</code></pre>
</details>
</dd>
<dt id="grpc.ssl_server_credentials"><code class="name flex">
<span>def <span class="ident">ssl_server_credentials</span></span>(<span>private_key_certificate_chain_pairs, root_certificates=None, require_client_auth=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a ServerCredentials for use with an SSL-enabled Server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>private_key_certificate_chain_pairs</code></strong></dt>
<dd>A list of pairs of the form
[PEM-encoded private key, PEM-encoded certificate chain].</dd>
<dt><strong><code>root_certificates</code></strong></dt>
<dd>An optional byte string of PEM-encoded client root
certificates that the server will use to verify client authentication.
If omitted, require_client_auth must also be False.</dd>
<dt><strong><code>require_client_auth</code></strong></dt>
<dd>A boolean indicating whether or not to require
clients to be authenticated. May only be True if root_certificates
is not None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <a title="grpc.ServerCredentials" href="#grpc.ServerCredentials"><code>ServerCredentials</code></a> <code>for</code> <code>use</code> <code>with</code> <code>an</code> <code>SSL</code>-<code>enabled</code> <code>Server.</code> <code>Typically</code>, <code>this</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>object is an argument to add_secure_port() method during server setup.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ssl_server_credentials(private_key_certificate_chain_pairs,
                           root_certificates=None,
                           require_client_auth=False):
    &#34;&#34;&#34;Creates a ServerCredentials for use with an SSL-enabled Server.

    Args:
      private_key_certificate_chain_pairs: A list of pairs of the form
        [PEM-encoded private key, PEM-encoded certificate chain].
      root_certificates: An optional byte string of PEM-encoded client root
        certificates that the server will use to verify client authentication.
        If omitted, require_client_auth must also be False.
      require_client_auth: A boolean indicating whether or not to require
        clients to be authenticated. May only be True if root_certificates
        is not None.

    Returns:
      A ServerCredentials for use with an SSL-enabled Server. Typically, this
      object is an argument to add_secure_port() method during server setup.
    &#34;&#34;&#34;
    if not private_key_certificate_chain_pairs:
        raise ValueError(
            &#39;At least one private key-certificate chain pair is required!&#39;)
    elif require_client_auth and root_certificates is None:
        raise ValueError(
            &#39;Illegal to require client auth without providing root certificates!&#39;
        )
    else:
        return ServerCredentials(
            _cygrpc.server_credentials_ssl(root_certificates, [
                _cygrpc.SslPemKeyCertPair(key, pem)
                for key, pem in private_key_certificate_chain_pairs
            ], require_client_auth))</code></pre>
</details>
</dd>
<dt id="grpc.stream_stream_rpc_method_handler"><code class="name flex">
<span>def <span class="ident">stream_stream_rpc_method_handler</span></span>(<span>behavior, request_deserializer=None, response_serializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an RpcMethodHandler for a stream-stream RPC method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>behavior</code></strong></dt>
<dd>The implementation of an RPC that accepts an iterator of
request values and returns an iterator of response values.</dd>
<dt><strong><code>request_deserializer</code></strong></dt>
<dd>An optional behavior for request deserialization.</dd>
<dt><strong><code>response_serializer</code></strong></dt>
<dd>An optional behavior for response serialization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An RpcMethodHandler object that is typically used by grpc.Server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_stream_rpc_method_handler(behavior,
                                     request_deserializer=None,
                                     response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a stream-stream RPC method.

    Args:
      behavior: The implementation of an RPC that accepts an iterator of
        request values and returns an iterator of response values.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(True, True, request_deserializer,
                                       response_serializer, None, None, None,
                                       behavior)</code></pre>
</details>
</dd>
<dt id="grpc.stream_unary_rpc_method_handler"><code class="name flex">
<span>def <span class="ident">stream_unary_rpc_method_handler</span></span>(<span>behavior, request_deserializer=None, response_serializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an RpcMethodHandler for a stream-unary RPC method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>behavior</code></strong></dt>
<dd>The implementation of an RPC that accepts an iterator of
request values and returns a single response value.</dd>
<dt><strong><code>request_deserializer</code></strong></dt>
<dd>An optional behavior for request deserialization.</dd>
<dt><strong><code>response_serializer</code></strong></dt>
<dd>An optional behavior for response serialization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An RpcMethodHandler object that is typically used by grpc.Server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_unary_rpc_method_handler(behavior,
                                    request_deserializer=None,
                                    response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a stream-unary RPC method.

    Args:
      behavior: The implementation of an RPC that accepts an iterator of
        request values and returns a single response value.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(True, False, request_deserializer,
                                       response_serializer, None, None,
                                       behavior, None)</code></pre>
</details>
</dd>
<dt id="grpc.unary_stream_rpc_method_handler"><code class="name flex">
<span>def <span class="ident">unary_stream_rpc_method_handler</span></span>(<span>behavior, request_deserializer=None, response_serializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an RpcMethodHandler for a unary-stream RPC method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>behavior</code></strong></dt>
<dd>The implementation of an RPC that accepts one request
and returns an iterator of response values.</dd>
<dt><strong><code>request_deserializer</code></strong></dt>
<dd>An optional behavior for request deserialization.</dd>
<dt><strong><code>response_serializer</code></strong></dt>
<dd>An optional behavior for response serialization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An RpcMethodHandler object that is typically used by grpc.Server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unary_stream_rpc_method_handler(behavior,
                                    request_deserializer=None,
                                    response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a unary-stream RPC method.

    Args:
      behavior: The implementation of an RPC that accepts one request
        and returns an iterator of response values.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(False, True, request_deserializer,
                                       response_serializer, None, behavior,
                                       None, None)</code></pre>
</details>
</dd>
<dt id="grpc.unary_unary_rpc_method_handler"><code class="name flex">
<span>def <span class="ident">unary_unary_rpc_method_handler</span></span>(<span>behavior, request_deserializer=None, response_serializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an RpcMethodHandler for a unary-unary RPC method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>behavior</code></strong></dt>
<dd>The implementation of an RPC that accepts one request
and returns one response.</dd>
<dt><strong><code>request_deserializer</code></strong></dt>
<dd>An optional behavior for request deserialization.</dd>
<dt><strong><code>response_serializer</code></strong></dt>
<dd>An optional behavior for response serialization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An RpcMethodHandler object that is typically used by grpc.Server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unary_unary_rpc_method_handler(behavior,
                                   request_deserializer=None,
                                   response_serializer=None):
    &#34;&#34;&#34;Creates an RpcMethodHandler for a unary-unary RPC method.

    Args:
      behavior: The implementation of an RPC that accepts one request
        and returns one response.
      request_deserializer: An optional behavior for request deserialization.
      response_serializer: An optional behavior for response serialization.

    Returns:
      An RpcMethodHandler object that is typically used by grpc.Server.
    &#34;&#34;&#34;
    from grpc import _utilities  # pylint: disable=cyclic-import
    return _utilities.RpcMethodHandler(False, False, request_deserializer,
                                       response_serializer, behavior, None,
                                       None, None)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grpc.AuthMetadataContext"><code class="flex name class">
<span>class <span class="ident">AuthMetadataContext</span></span>
</code></dt>
<dd>
<section class="desc"><p>Provides information to call credentials metadata plugins.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>service_url</code></strong></dt>
<dd>A string URL of the service being called into.</dd>
<dt><strong><code>method_name</code></strong></dt>
<dd>A string of the fully qualified method name being called.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthMetadataContext(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Provides information to call credentials metadata plugins.

    Attributes:
      service_url: A string URL of the service being called into.
      method_name: A string of the fully qualified method name being called.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="grpc.AuthMetadataPlugin"><code class="flex name class">
<span>class <span class="ident">AuthMetadataPlugin</span></span>
</code></dt>
<dd>
<section class="desc"><p>A specification for custom authentication.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthMetadataPlugin(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;A specification for custom authentication.&#34;&#34;&#34;

    def __call__(self, context, callback):
        &#34;&#34;&#34;Implements authentication by passing metadata to a callback.

        Implementations of this method must not block.

        Args:
          context: An AuthMetadataContext providing information on the RPC that
            the plugin is being called to authenticate.
          callback: An AuthMetadataPluginCallback to be invoked either
            synchronously or asynchronously.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.auth.transport.grpc.AuthMetadataPlugin" href="../google/auth/transport/grpc.html#google.auth.transport.grpc.AuthMetadataPlugin">AuthMetadataPlugin</a></li>
<li>grpc._auth.AccessTokenAuthMetadataPlugin</li>
<li>grpc._auth.GoogleCallCredentials</li>
</ul>
</dd>
<dt id="grpc.AuthMetadataPluginCallback"><code class="flex name class">
<span>class <span class="ident">AuthMetadataPluginCallback</span></span>
</code></dt>
<dd>
<section class="desc"><p>Callback object received by a metadata plugin.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthMetadataPluginCallback(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Callback object received by a metadata plugin.&#34;&#34;&#34;

    def __call__(self, metadata, error):
        &#34;&#34;&#34;Passes to the gRPC runtime authentication metadata for an RPC.

        Args:
          metadata: The :term:`metadata` used to construct the CallCredentials.
          error: An Exception to indicate error or None to indicate success.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Call"><code class="flex name class">
<span>class <span class="ident">Call</span></span>
</code></dt>
<dd>
<section class="desc"><p>Invocation-side utility object for an RPC.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):
    &#34;&#34;&#34;Invocation-side utility object for an RPC.&#34;&#34;&#34;

    @abc.abstractmethod
    def initial_metadata(self):
        &#34;&#34;&#34;Accesses the initial metadata sent by the server.

        This method blocks until the value is available.

        Returns:
          The initial :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def trailing_metadata(self):
        &#34;&#34;&#34;Accesses the trailing metadata sent by the server.

        This method blocks until the value is available.

        Returns:
          The trailing :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def code(self):
        &#34;&#34;&#34;Accesses the status code sent by the server.

        This method blocks until the value is available.

        Returns:
          The StatusCode value for the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def details(self):
        &#34;&#34;&#34;Accesses the details sent by the server.

        This method blocks until the value is available.

        Returns:
          The details string of the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="grpc.RpcContext" href="#grpc.RpcContext">RpcContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.Call.code"><code class="name flex">
<span>def <span class="ident">code</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Accesses the status code sent by the server.</p>
<p>This method blocks until the value is available.</p>
<h2 id="returns">Returns</h2>
<p>The StatusCode value for the RPC.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def code(self):
    &#34;&#34;&#34;Accesses the status code sent by the server.

    This method blocks until the value is available.

    Returns:
      The StatusCode value for the RPC.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Call.details"><code class="name flex">
<span>def <span class="ident">details</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Accesses the details sent by the server.</p>
<p>This method blocks until the value is available.</p>
<h2 id="returns">Returns</h2>
<p>The details string of the RPC.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def details(self):
    &#34;&#34;&#34;Accesses the details sent by the server.

    This method blocks until the value is available.

    Returns:
      The details string of the RPC.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Call.initial_metadata"><code class="name flex">
<span>def <span class="ident">initial_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Accesses the initial metadata sent by the server.</p>
<p>This method blocks until the value is available.</p>
<h2 id="returns">Returns</h2>
<p>The initial :term:<code>metadata</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def initial_metadata(self):
    &#34;&#34;&#34;Accesses the initial metadata sent by the server.

    This method blocks until the value is available.

    Returns:
      The initial :term:`metadata`.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Call.trailing_metadata"><code class="name flex">
<span>def <span class="ident">trailing_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Accesses the trailing metadata sent by the server.</p>
<p>This method blocks until the value is available.</p>
<h2 id="returns">Returns</h2>
<p>The trailing :term:<code>metadata</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def trailing_metadata(self):
    &#34;&#34;&#34;Accesses the trailing metadata sent by the server.

    This method blocks until the value is available.

    Returns:
      The trailing :term:`metadata`.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grpc.RpcContext" href="#grpc.RpcContext">RpcContext</a></b></code>:
<ul class="hlist">
<li><code><a title="grpc.RpcContext.add_callback" href="#grpc.RpcContext.add_callback">add_callback</a></code></li>
<li><code><a title="grpc.RpcContext.cancel" href="#grpc.RpcContext.cancel">cancel</a></code></li>
<li><code><a title="grpc.RpcContext.is_active" href="#grpc.RpcContext.is_active">is_active</a></code></li>
<li><code><a title="grpc.RpcContext.time_remaining" href="#grpc.RpcContext.time_remaining">time_remaining</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="grpc.CallCredentials"><code class="flex name class">
<span>class <span class="ident">CallCredentials</span></span>
<span>(</span><span>credentials)</span>
</code></dt>
<dd>
<section class="desc"><p>An encapsulation of the data required to assert an identity over a call.</p>
<p>A CallCredentials has to be used with secure Channel, otherwise the
metadata will not be transmitted to the server.</p>
<p>A CallCredentials may be composed with ChannelCredentials to always assert
identity for every call over that Channel.</p>
<p>This class has no supported interface - it exists to define the type of its
instances and its instances exist to be passed to other functions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallCredentials(object):
    &#34;&#34;&#34;An encapsulation of the data required to assert an identity over a call.

    A CallCredentials has to be used with secure Channel, otherwise the
    metadata will not be transmitted to the server.

    A CallCredentials may be composed with ChannelCredentials to always assert
    identity for every call over that Channel.

    This class has no supported interface - it exists to define the type of its
    instances and its instances exist to be passed to other functions.
    &#34;&#34;&#34;

    def __init__(self, credentials):
        self._credentials = credentials</code></pre>
</details>
</dd>
<dt id="grpc.Channel"><code class="flex name class">
<span>class <span class="ident">Channel</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords RPC invocation via generic methods on client-side.</p>
<p>Channel objects implement the Context Manager type, although they need not
support being entered and exited multiple times.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Channel(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords RPC invocation via generic methods on client-side.

    Channel objects implement the Context Manager type, although they need not
    support being entered and exited multiple times.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def subscribe(self, callback, try_to_connect=False):
        &#34;&#34;&#34;Subscribe to this Channel&#39;s connectivity state machine.

        A Channel may be in any of the states described by ChannelConnectivity.
        This method allows application to monitor the state transitions.
        The typical use case is to debug or gain better visibility into gRPC
        runtime&#39;s state.

        Args:
          callback: A callable to be invoked with ChannelConnectivity argument.
            ChannelConnectivity describes current state of the channel.
            The callable will be invoked immediately upon subscription
            and again for every change to ChannelConnectivity until it
            is unsubscribed or this Channel object goes out of scope.
          try_to_connect: A boolean indicating whether or not this Channel
            should attempt to connect immediately. If set to False, gRPC
            runtime decides when to connect.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def unsubscribe(self, callback):
        &#34;&#34;&#34;Unsubscribes a subscribed callback from this Channel&#39;s connectivity.

        Args:
          callback: A callable previously registered with this Channel from
          having been passed to its &#34;subscribe&#34; method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def unary_unary(self,
                    method,
                    request_serializer=None,
                    response_deserializer=None):
        &#34;&#34;&#34;Creates a UnaryUnaryMultiCallable for a unary-unary method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None
            is passed.

        Returns:
          A UnaryUnaryMultiCallable value for the named unary-unary method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def unary_stream(self,
                     method,
                     request_serializer=None,
                     response_deserializer=None):
        &#34;&#34;&#34;Creates a UnaryStreamMultiCallable for a unary-stream method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None is
            passed.

        Returns:
          A UnaryStreamMultiCallable value for the name unary-stream method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def stream_unary(self,
                     method,
                     request_serializer=None,
                     response_deserializer=None):
        &#34;&#34;&#34;Creates a StreamUnaryMultiCallable for a stream-unary method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None is
            passed.

        Returns:
          A StreamUnaryMultiCallable value for the named stream-unary method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def stream_stream(self,
                      method,
                      request_serializer=None,
                      response_deserializer=None):
        &#34;&#34;&#34;Creates a StreamStreamMultiCallable for a stream-stream method.

        Args:
          method: The name of the RPC method.
          request_serializer: Optional behaviour for serializing the request
            message. Request goes unserialized in case None is passed.
          response_deserializer: Optional behaviour for deserializing the
            response message. Response goes undeserialized in case None
            is passed.

        Returns:
          A StreamStreamMultiCallable value for the named stream-stream method.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def close(self):
        &#34;&#34;&#34;Closes this Channel and releases all resources held by it.

        Closing the Channel will immediately terminate all RPCs active with the
        Channel and it is not valid to invoke new RPCs with the Channel.

        This method is idempotent.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.Channel.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Closes this Channel and releases all resources held by it.</p>
<p>Closing the Channel will immediately terminate all RPCs active with the
Channel and it is not valid to invoke new RPCs with the Channel.</p>
<p>This method is idempotent.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def close(self):
    &#34;&#34;&#34;Closes this Channel and releases all resources held by it.

    Closing the Channel will immediately terminate all RPCs active with the
    Channel and it is not valid to invoke new RPCs with the Channel.

    This method is idempotent.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Channel.stream_stream"><code class="name flex">
<span>def <span class="ident">stream_stream</span></span>(<span>self, method, request_serializer=None, response_deserializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a StreamStreamMultiCallable for a stream-stream method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The name of the RPC method.</dd>
<dt><strong><code>request_serializer</code></strong></dt>
<dd>Optional behaviour for serializing the request
message. Request goes unserialized in case None is passed.</dd>
<dt><strong><code>response_deserializer</code></strong></dt>
<dd>Optional behaviour for deserializing the
response message. Response goes undeserialized in case None
is passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A StreamStreamMultiCallable value for the named stream-stream method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def stream_stream(self,
                  method,
                  request_serializer=None,
                  response_deserializer=None):
    &#34;&#34;&#34;Creates a StreamStreamMultiCallable for a stream-stream method.

    Args:
      method: The name of the RPC method.
      request_serializer: Optional behaviour for serializing the request
        message. Request goes unserialized in case None is passed.
      response_deserializer: Optional behaviour for deserializing the
        response message. Response goes undeserialized in case None
        is passed.

    Returns:
      A StreamStreamMultiCallable value for the named stream-stream method.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Channel.stream_unary"><code class="name flex">
<span>def <span class="ident">stream_unary</span></span>(<span>self, method, request_serializer=None, response_deserializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a StreamUnaryMultiCallable for a stream-unary method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The name of the RPC method.</dd>
<dt><strong><code>request_serializer</code></strong></dt>
<dd>Optional behaviour for serializing the request
message. Request goes unserialized in case None is passed.</dd>
<dt><strong><code>response_deserializer</code></strong></dt>
<dd>Optional behaviour for deserializing the
response message. Response goes undeserialized in case None is
passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A StreamUnaryMultiCallable value for the named stream-unary method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def stream_unary(self,
                 method,
                 request_serializer=None,
                 response_deserializer=None):
    &#34;&#34;&#34;Creates a StreamUnaryMultiCallable for a stream-unary method.

    Args:
      method: The name of the RPC method.
      request_serializer: Optional behaviour for serializing the request
        message. Request goes unserialized in case None is passed.
      response_deserializer: Optional behaviour for deserializing the
        response message. Response goes undeserialized in case None is
        passed.

    Returns:
      A StreamUnaryMultiCallable value for the named stream-unary method.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Channel.subscribe"><code class="name flex">
<span>def <span class="ident">subscribe</span></span>(<span>self, callback, try_to_connect=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Subscribe to this Channel's connectivity state machine.</p>
<p>A Channel may be in any of the states described by ChannelConnectivity.
This method allows application to monitor the state transitions.
The typical use case is to debug or gain better visibility into gRPC
runtime's state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback</code></strong></dt>
<dd>A callable to be invoked with ChannelConnectivity argument.
ChannelConnectivity describes current state of the channel.
The callable will be invoked immediately upon subscription
and again for every change to ChannelConnectivity until it
is unsubscribed or this Channel object goes out of scope.</dd>
<dt><strong><code>try_to_connect</code></strong></dt>
<dd>A boolean indicating whether or not this Channel
should attempt to connect immediately. If set to False, gRPC
runtime decides when to connect.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def subscribe(self, callback, try_to_connect=False):
    &#34;&#34;&#34;Subscribe to this Channel&#39;s connectivity state machine.

    A Channel may be in any of the states described by ChannelConnectivity.
    This method allows application to monitor the state transitions.
    The typical use case is to debug or gain better visibility into gRPC
    runtime&#39;s state.

    Args:
      callback: A callable to be invoked with ChannelConnectivity argument.
        ChannelConnectivity describes current state of the channel.
        The callable will be invoked immediately upon subscription
        and again for every change to ChannelConnectivity until it
        is unsubscribed or this Channel object goes out of scope.
      try_to_connect: A boolean indicating whether or not this Channel
        should attempt to connect immediately. If set to False, gRPC
        runtime decides when to connect.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Channel.unary_stream"><code class="name flex">
<span>def <span class="ident">unary_stream</span></span>(<span>self, method, request_serializer=None, response_deserializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a UnaryStreamMultiCallable for a unary-stream method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The name of the RPC method.</dd>
<dt><strong><code>request_serializer</code></strong></dt>
<dd>Optional behaviour for serializing the request
message. Request goes unserialized in case None is passed.</dd>
<dt><strong><code>response_deserializer</code></strong></dt>
<dd>Optional behaviour for deserializing the
response message. Response goes undeserialized in case None is
passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A UnaryStreamMultiCallable value for the name unary-stream method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def unary_stream(self,
                 method,
                 request_serializer=None,
                 response_deserializer=None):
    &#34;&#34;&#34;Creates a UnaryStreamMultiCallable for a unary-stream method.

    Args:
      method: The name of the RPC method.
      request_serializer: Optional behaviour for serializing the request
        message. Request goes unserialized in case None is passed.
      response_deserializer: Optional behaviour for deserializing the
        response message. Response goes undeserialized in case None is
        passed.

    Returns:
      A UnaryStreamMultiCallable value for the name unary-stream method.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Channel.unary_unary"><code class="name flex">
<span>def <span class="ident">unary_unary</span></span>(<span>self, method, request_serializer=None, response_deserializer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a UnaryUnaryMultiCallable for a unary-unary method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The name of the RPC method.</dd>
<dt><strong><code>request_serializer</code></strong></dt>
<dd>Optional behaviour for serializing the request
message. Request goes unserialized in case None is passed.</dd>
<dt><strong><code>response_deserializer</code></strong></dt>
<dd>Optional behaviour for deserializing the
response message. Response goes undeserialized in case None
is passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A UnaryUnaryMultiCallable value for the named unary-unary method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def unary_unary(self,
                method,
                request_serializer=None,
                response_deserializer=None):
    &#34;&#34;&#34;Creates a UnaryUnaryMultiCallable for a unary-unary method.

    Args:
      method: The name of the RPC method.
      request_serializer: Optional behaviour for serializing the request
        message. Request goes unserialized in case None is passed.
      response_deserializer: Optional behaviour for deserializing the
        response message. Response goes undeserialized in case None
        is passed.

    Returns:
      A UnaryUnaryMultiCallable value for the named unary-unary method.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Channel.unsubscribe"><code class="name flex">
<span>def <span class="ident">unsubscribe</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<section class="desc"><p>Unsubscribes a subscribed callback from this Channel's connectivity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback</code></strong></dt>
<dd>A callable previously registered with this Channel from</dd>
</dl>
<p>having been passed to its "subscribe" method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def unsubscribe(self, callback):
    &#34;&#34;&#34;Unsubscribes a subscribed callback from this Channel&#39;s connectivity.

    Args:
      callback: A callable previously registered with this Channel from
      having been passed to its &#34;subscribe&#34; method.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.ChannelConnectivity"><code class="flex name class">
<span>class <span class="ident">ChannelConnectivity</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_connectivity_state in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>IDLE</code></strong></dt>
<dd>The channel is idle.</dd>
<dt><strong><code>CONNECTING</code></strong></dt>
<dd>The channel is connecting.</dd>
<dt><strong><code>READY</code></strong></dt>
<dd>The channel is ready to conduct RPCs.</dd>
<dt><strong><code>TRANSIENT_FAILURE</code></strong></dt>
<dd>The channel has seen a failure from which it expects
to recover.</dd>
<dt><strong><code>SHUTDOWN</code></strong></dt>
<dd>The channel has seen a failure from which it cannot recover.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelConnectivity(enum.Enum):
    &#34;&#34;&#34;Mirrors grpc_connectivity_state in the gRPC Core.

    Attributes:
      IDLE: The channel is idle.
      CONNECTING: The channel is connecting.
      READY: The channel is ready to conduct RPCs.
      TRANSIENT_FAILURE: The channel has seen a failure from which it expects
        to recover.
      SHUTDOWN: The channel has seen a failure from which it cannot recover.
    &#34;&#34;&#34;
    IDLE = (_cygrpc.ConnectivityState.idle, &#39;idle&#39;)
    CONNECTING = (_cygrpc.ConnectivityState.connecting, &#39;connecting&#39;)
    READY = (_cygrpc.ConnectivityState.ready, &#39;ready&#39;)
    TRANSIENT_FAILURE = (_cygrpc.ConnectivityState.transient_failure,
                         &#39;transient failure&#39;)
    SHUTDOWN = (_cygrpc.ConnectivityState.shutdown, &#39;shutdown&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="grpc.ChannelConnectivity.CONNECTING"><code class="name">var <span class="ident">CONNECTING</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_connectivity_state in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>IDLE</code></strong></dt>
<dd>The channel is idle.</dd>
<dt><strong><code>CONNECTING</code></strong></dt>
<dd>The channel is connecting.</dd>
<dt><strong><code>READY</code></strong></dt>
<dd>The channel is ready to conduct RPCs.</dd>
<dt><strong><code>TRANSIENT_FAILURE</code></strong></dt>
<dd>The channel has seen a failure from which it expects
to recover.</dd>
<dt><strong><code>SHUTDOWN</code></strong></dt>
<dd>The channel has seen a failure from which it cannot recover.</dd>
</dl></section>
</dd>
<dt id="grpc.ChannelConnectivity.IDLE"><code class="name">var <span class="ident">IDLE</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_connectivity_state in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>IDLE</code></strong></dt>
<dd>The channel is idle.</dd>
<dt><strong><code>CONNECTING</code></strong></dt>
<dd>The channel is connecting.</dd>
<dt><strong><code>READY</code></strong></dt>
<dd>The channel is ready to conduct RPCs.</dd>
<dt><strong><code>TRANSIENT_FAILURE</code></strong></dt>
<dd>The channel has seen a failure from which it expects
to recover.</dd>
<dt><strong><code>SHUTDOWN</code></strong></dt>
<dd>The channel has seen a failure from which it cannot recover.</dd>
</dl></section>
</dd>
<dt id="grpc.ChannelConnectivity.READY"><code class="name">var <span class="ident">READY</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_connectivity_state in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>IDLE</code></strong></dt>
<dd>The channel is idle.</dd>
<dt><strong><code>CONNECTING</code></strong></dt>
<dd>The channel is connecting.</dd>
<dt><strong><code>READY</code></strong></dt>
<dd>The channel is ready to conduct RPCs.</dd>
<dt><strong><code>TRANSIENT_FAILURE</code></strong></dt>
<dd>The channel has seen a failure from which it expects
to recover.</dd>
<dt><strong><code>SHUTDOWN</code></strong></dt>
<dd>The channel has seen a failure from which it cannot recover.</dd>
</dl></section>
</dd>
<dt id="grpc.ChannelConnectivity.SHUTDOWN"><code class="name">var <span class="ident">SHUTDOWN</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_connectivity_state in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>IDLE</code></strong></dt>
<dd>The channel is idle.</dd>
<dt><strong><code>CONNECTING</code></strong></dt>
<dd>The channel is connecting.</dd>
<dt><strong><code>READY</code></strong></dt>
<dd>The channel is ready to conduct RPCs.</dd>
<dt><strong><code>TRANSIENT_FAILURE</code></strong></dt>
<dd>The channel has seen a failure from which it expects
to recover.</dd>
<dt><strong><code>SHUTDOWN</code></strong></dt>
<dd>The channel has seen a failure from which it cannot recover.</dd>
</dl></section>
</dd>
<dt id="grpc.ChannelConnectivity.TRANSIENT_FAILURE"><code class="name">var <span class="ident">TRANSIENT_FAILURE</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_connectivity_state in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>IDLE</code></strong></dt>
<dd>The channel is idle.</dd>
<dt><strong><code>CONNECTING</code></strong></dt>
<dd>The channel is connecting.</dd>
<dt><strong><code>READY</code></strong></dt>
<dd>The channel is ready to conduct RPCs.</dd>
<dt><strong><code>TRANSIENT_FAILURE</code></strong></dt>
<dd>The channel has seen a failure from which it expects
to recover.</dd>
<dt><strong><code>SHUTDOWN</code></strong></dt>
<dd>The channel has seen a failure from which it cannot recover.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="grpc.ChannelCredentials"><code class="flex name class">
<span>class <span class="ident">ChannelCredentials</span></span>
<span>(</span><span>credentials)</span>
</code></dt>
<dd>
<section class="desc"><p>An encapsulation of the data required to create a secure Channel.</p>
<p>This class has no supported interface - it exists to define the type of its
instances and its instances exist to be passed to other functions. For
example, ssl_channel_credentials returns an instance of this class and
secure_channel requires an instance of this class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelCredentials(object):
    &#34;&#34;&#34;An encapsulation of the data required to create a secure Channel.

    This class has no supported interface - it exists to define the type of its
    instances and its instances exist to be passed to other functions. For
    example, ssl_channel_credentials returns an instance of this class and
    secure_channel requires an instance of this class.
    &#34;&#34;&#34;

    def __init__(self, credentials):
        self._credentials = credentials</code></pre>
</details>
</dd>
<dt id="grpc.ClientCallDetails"><code class="flex name class">
<span>class <span class="ident">ClientCallDetails</span></span>
</code></dt>
<dd>
<section class="desc"><p>Describes an RPC to be invoked.</p>
<p>This is an EXPERIMENTAL API.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The method name of the RPC.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>An optional duration of time in seconds to allow for the RPC.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional :term:<code>metadata</code> to be transmitted to
the service-side of the RPC.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>An optional CallCredentials for the RPC.</dd>
<dt><strong><code>wait_for_ready</code></strong></dt>
<dd>This is an EXPERIMENTAL argument. An optional flag t
enable wait for ready mechanism.</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This is an EXPERIMENTAL option.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClientCallDetails(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Describes an RPC to be invoked.

    This is an EXPERIMENTAL API.

    Attributes:
      method: The method name of the RPC.
      timeout: An optional duration of time in seconds to allow for the RPC.
      metadata: Optional :term:`metadata` to be transmitted to
        the service-side of the RPC.
      credentials: An optional CallCredentials for the RPC.
      wait_for_ready: This is an EXPERIMENTAL argument. An optional flag t
        enable wait for ready mechanism.
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This is an EXPERIMENTAL option.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="grpc.Compression"><code class="flex name class">
<span>class <span class="ident">Compression</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates the compression method to be used for an RPC.</p>
<p>This enumeration is part of an EXPERIMENTAL API.</p>
<p>Attributes:
NoCompression: Do not use compression algorithm.
Deflate: Use "Deflate" compression algorithm.
Gzip: Use "Gzip" compression algorithm.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Compression(enum.IntEnum):
    &#34;&#34;&#34;Indicates the compression method to be used for an RPC.

       This enumeration is part of an EXPERIMENTAL API.

       Attributes:
        NoCompression: Do not use compression algorithm.
        Deflate: Use &#34;Deflate&#34; compression algorithm.
        Gzip: Use &#34;Gzip&#34; compression algorithm.
    &#34;&#34;&#34;
    NoCompression = _compression.NoCompression
    Deflate = _compression.Deflate
    Gzip = _compression.Gzip</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="grpc.Compression.Deflate"><code class="name">var <span class="ident">Deflate</span></code></dt>
<dd>
<section class="desc"><p>Indicates the compression method to be used for an RPC.</p>
<p>This enumeration is part of an EXPERIMENTAL API.</p>
<p>Attributes:
NoCompression: Do not use compression algorithm.
Deflate: Use "Deflate" compression algorithm.
Gzip: Use "Gzip" compression algorithm.</p></section>
</dd>
<dt id="grpc.Compression.Gzip"><code class="name">var <span class="ident">Gzip</span></code></dt>
<dd>
<section class="desc"><p>Indicates the compression method to be used for an RPC.</p>
<p>This enumeration is part of an EXPERIMENTAL API.</p>
<p>Attributes:
NoCompression: Do not use compression algorithm.
Deflate: Use "Deflate" compression algorithm.
Gzip: Use "Gzip" compression algorithm.</p></section>
</dd>
<dt id="grpc.Compression.NoCompression"><code class="name">var <span class="ident">NoCompression</span></code></dt>
<dd>
<section class="desc"><p>Indicates the compression method to be used for an RPC.</p>
<p>This enumeration is part of an EXPERIMENTAL API.</p>
<p>Attributes:
NoCompression: Do not use compression algorithm.
Deflate: Use "Deflate" compression algorithm.
Gzip: Use "Gzip" compression algorithm.</p></section>
</dd>
</dl>
</dd>
<dt id="grpc.Future"><code class="flex name class">
<span>class <span class="ident">Future</span></span>
</code></dt>
<dd>
<section class="desc"><p>A representation of a computation in another control flow.</p>
<p>Computations represented by a Future may be yet to be begun,
may be ongoing, or may have already completed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Future(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;A representation of a computation in another control flow.

    Computations represented by a Future may be yet to be begun,
    may be ongoing, or may have already completed.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def cancel(self):
        &#34;&#34;&#34;Attempts to cancel the computation.

        This method does not block.

        Returns:
            bool:
            Returns True if the computation was canceled.

            Returns False under all other circumstances, for example:

            1. computation has begun and could not be canceled.
            2. computation has finished
            3. computation is scheduled for execution and it is impossible
                to determine its state without blocking.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def cancelled(self):
        &#34;&#34;&#34;Describes whether the computation was cancelled.

        This method does not block.

        Returns:
            bool:
            Returns True if the computation was cancelled before its result became
            available.

            Returns False under all other circumstances, for example:

            1. computation was not cancelled.
            2. computation&#39;s result is available.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def running(self):
        &#34;&#34;&#34;Describes whether the computation is taking place.

        This method does not block.

        Returns:
            Returns True if the computation is scheduled for execution or
            currently executing.

            Returns False if the computation already executed or was cancelled.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def done(self):
        &#34;&#34;&#34;Describes whether the computation has taken place.

        This method does not block.

        Returns:
            bool:
            Returns True if the computation already executed or was cancelled.
            Returns False if the computation is scheduled for execution or
            currently executing.
            This is exactly opposite of the running() method&#39;s result.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def result(self, timeout=None):
        &#34;&#34;&#34;Returns the result of the computation or raises its exception.

        This method may return immediately or may block.

        Args:
          timeout: The length of time in seconds to wait for the computation to
            finish or be cancelled. If None, the call will block until the
            computations&#39;s termination.

        Returns:
          The return value of the computation.

        Raises:
          FutureTimeoutError: If a timeout value is passed and the computation
            does not terminate within the allotted time.
          FutureCancelledError: If the computation was cancelled.
          Exception: If the computation raised an exception, this call will
            raise the same exception.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def exception(self, timeout=None):
        &#34;&#34;&#34;Return the exception raised by the computation.

        This method may return immediately or may block.

        Args:
          timeout: The length of time in seconds to wait for the computation to
            terminate or be cancelled. If None, the call will block until the
            computations&#39;s termination.

        Returns:
            The exception raised by the computation, or None if the computation
            did not raise an exception.

        Raises:
          FutureTimeoutError: If a timeout value is passed and the computation
            does not terminate within the allotted time.
          FutureCancelledError: If the computation was cancelled.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def traceback(self, timeout=None):
        &#34;&#34;&#34;Access the traceback of the exception raised by the computation.

        This method may return immediately or may block.

        Args:
          timeout: The length of time in seconds to wait for the computation
            to terminate or be cancelled. If None, the call will block until
            the computation&#39;s termination.

        Returns:
            The traceback of the exception raised by the computation, or None
            if the computation did not raise an exception.

        Raises:
          FutureTimeoutError: If a timeout value is passed and the computation
            does not terminate within the allotted time.
          FutureCancelledError: If the computation was cancelled.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_done_callback(self, fn):
        &#34;&#34;&#34;Adds a function to be called at completion of the computation.

        The callback will be passed this Future object describing the outcome
        of the computation.  Callbacks will be invoked after the future is
        terimated, whether successfully or not.

        If the computation has already completed, the callback will be called
        immediately.

        Exceptions raised in the callback will be logged at ERROR level, but
        will not terminate any threads of execution.

        Args:
          fn: A callable taking this Future object as its single parameter.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.Future.add_done_callback"><code class="name flex">
<span>def <span class="ident">add_done_callback</span></span>(<span>self, fn)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a function to be called at completion of the computation.</p>
<p>The callback will be passed this Future object describing the outcome
of the computation.
Callbacks will be invoked after the future is
terimated, whether successfully or not.</p>
<p>If the computation has already completed, the callback will be called
immediately.</p>
<p>Exceptions raised in the callback will be logged at ERROR level, but
will not terminate any threads of execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fn</code></strong></dt>
<dd>A callable taking this Future object as its single parameter.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_done_callback(self, fn):
    &#34;&#34;&#34;Adds a function to be called at completion of the computation.

    The callback will be passed this Future object describing the outcome
    of the computation.  Callbacks will be invoked after the future is
    terimated, whether successfully or not.

    If the computation has already completed, the callback will be called
    immediately.

    Exceptions raised in the callback will be logged at ERROR level, but
    will not terminate any threads of execution.

    Args:
      fn: A callable taking this Future object as its single parameter.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to cancel the computation.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code>:</dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns True if the computation was canceled.</p>
<dl>
<dt><code>Returns</code> <code>False</code> <code>under</code> <code>all</code> <code>other</code> <code>circumstances</code>, <code>for</code> <code>example</code>:</dt>
<dd>&nbsp;</dd>
</dl>
<ol>
<li>
<dl>
<dt>computation has begun and could not be canceled.</dt>
<dt><code>2.</code> <code>computation</code> <code>has</code> <code>finished</code></dt>
<dd>&nbsp;</dd>
</dl>
</li>
</ol>
<dl>
<dt><code>3.</code> <code>computation</code> <code>is</code> <code>scheduled</code> <code>for</code> <code>execution</code> <code>and</code> <code>it</code> <code>is</code> <code>impossible</code></dt>
<dd>to determine its state without blocking.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def cancel(self):
    &#34;&#34;&#34;Attempts to cancel the computation.

    This method does not block.

    Returns:
        bool:
        Returns True if the computation was canceled.

        Returns False under all other circumstances, for example:

        1. computation has begun and could not be canceled.
        2. computation has finished
        3. computation is scheduled for execution and it is impossible
            to determine its state without blocking.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.cancelled"><code class="name flex">
<span>def <span class="ident">cancelled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the computation was cancelled.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code>:</dt>
<dd>&nbsp;</dd>
<dt><code>Returns</code> <code>True</code> <code>if</code> <code>the</code> <code>computation</code> <code>was</code> <code>cancelled</code> <code>before</code> <code>its</code> <code>result</code> <code>became</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>available.</p>
<dl>
<dt><code>Returns</code> <code>False</code> <code>under</code> <code>all</code> <code>other</code> <code>circumstances</code>, <code>for</code> <code>example</code>:</dt>
<dd>&nbsp;</dd>
</dl>
<ol>
<li>computation was not cancelled.</li>
<li>computation's result is available.</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def cancelled(self):
    &#34;&#34;&#34;Describes whether the computation was cancelled.

    This method does not block.

    Returns:
        bool:
        Returns True if the computation was cancelled before its result became
        available.

        Returns False under all other circumstances, for example:

        1. computation was not cancelled.
        2. computation&#39;s result is available.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the computation has taken place.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code>:</dt>
<dd>&nbsp;</dd>
<dt>Returns True if the computation already executed or was cancelled.</dt>
<dt><code>Returns</code> <code>False</code> <code>if</code> <code>the</code> <code>computation</code> <code>is</code> <code>scheduled</code> <code>for</code> <code>execution</code> or</dt>
<dd>&nbsp;</dd>
</dl>
<p>currently executing.
This is exactly opposite of the running() method's result.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def done(self):
    &#34;&#34;&#34;Describes whether the computation has taken place.

    This method does not block.

    Returns:
        bool:
        Returns True if the computation already executed or was cancelled.
        Returns False if the computation is scheduled for execution or
        currently executing.
        This is exactly opposite of the running() method&#39;s result.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.exception"><code class="name flex">
<span>def <span class="ident">exception</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the exception raised by the computation.</p>
<p>This method may return immediately or may block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>The length of time in seconds to wait for the computation to
terminate or be cancelled. If None, the call will block until the
computations's termination.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>exception</code> <code>raised</code> <code>by</code> <code>the</code> <code>computation</code>, or <code>None</code> <code>if</code> <code>the</code> <code>computation</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>did not raise an exception.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.FutureTimeoutError" href="#grpc.FutureTimeoutError"><code>FutureTimeoutError</code></a></strong></dt>
<dd>If a timeout value is passed and the computation
does not terminate within the allotted time.</dd>
<dt><strong><a title="grpc.FutureCancelledError" href="#grpc.FutureCancelledError"><code>FutureCancelledError</code></a></strong></dt>
<dd>If the computation was cancelled.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def exception(self, timeout=None):
    &#34;&#34;&#34;Return the exception raised by the computation.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        terminate or be cancelled. If None, the call will block until the
        computations&#39;s termination.

    Returns:
        The exception raised by the computation, or None if the computation
        did not raise an exception.

    Raises:
      FutureTimeoutError: If a timeout value is passed and the computation
        does not terminate within the allotted time.
      FutureCancelledError: If the computation was cancelled.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.result"><code class="name flex">
<span>def <span class="ident">result</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the result of the computation or raises its exception.</p>
<p>This method may return immediately or may block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>The length of time in seconds to wait for the computation to
finish or be cancelled. If None, the call will block until the
computations's termination.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The return value of the computation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.FutureTimeoutError" href="#grpc.FutureTimeoutError"><code>FutureTimeoutError</code></a></strong></dt>
<dd>If a timeout value is passed and the computation
does not terminate within the allotted time.</dd>
<dt><strong><a title="grpc.FutureCancelledError" href="#grpc.FutureCancelledError"><code>FutureCancelledError</code></a></strong></dt>
<dd>If the computation was cancelled.</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>If the computation raised an exception, this call will
raise the same exception.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def result(self, timeout=None):
    &#34;&#34;&#34;Returns the result of the computation or raises its exception.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation to
        finish or be cancelled. If None, the call will block until the
        computations&#39;s termination.

    Returns:
      The return value of the computation.

    Raises:
      FutureTimeoutError: If a timeout value is passed and the computation
        does not terminate within the allotted time.
      FutureCancelledError: If the computation was cancelled.
      Exception: If the computation raised an exception, this call will
        raise the same exception.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.running"><code class="name flex">
<span>def <span class="ident">running</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the computation is taking place.</p>
<p>This method does not block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Returns</code> <code>True</code> <code>if</code> <code>the</code> <code>computation</code> <code>is</code> <code>scheduled</code> <code>for</code> <code>execution</code> or</dt>
<dd>&nbsp;</dd>
</dl>
<p>currently executing.</p>
<p>Returns False if the computation already executed or was cancelled.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def running(self):
    &#34;&#34;&#34;Describes whether the computation is taking place.

    This method does not block.

    Returns:
        Returns True if the computation is scheduled for execution or
        currently executing.

        Returns False if the computation already executed or was cancelled.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Future.traceback"><code class="name flex">
<span>def <span class="ident">traceback</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Access the traceback of the exception raised by the computation.</p>
<p>This method may return immediately or may block.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>The length of time in seconds to wait for the computation
to terminate or be cancelled. If None, the call will block until
the computation's termination.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>traceback</code> of <code>the</code> <code>exception</code> <code>raised</code> <code>by</code> <code>the</code> <code>computation</code>, or <code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>if the computation did not raise an exception.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.FutureTimeoutError" href="#grpc.FutureTimeoutError"><code>FutureTimeoutError</code></a></strong></dt>
<dd>If a timeout value is passed and the computation
does not terminate within the allotted time.</dd>
<dt><strong><a title="grpc.FutureCancelledError" href="#grpc.FutureCancelledError"><code>FutureCancelledError</code></a></strong></dt>
<dd>If the computation was cancelled.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def traceback(self, timeout=None):
    &#34;&#34;&#34;Access the traceback of the exception raised by the computation.

    This method may return immediately or may block.

    Args:
      timeout: The length of time in seconds to wait for the computation
        to terminate or be cancelled. If None, the call will block until
        the computation&#39;s termination.

    Returns:
        The traceback of the exception raised by the computation, or None
        if the computation did not raise an exception.

    Raises:
      FutureTimeoutError: If a timeout value is passed and the computation
        does not terminate within the allotted time.
      FutureCancelledError: If the computation was cancelled.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.FutureCancelledError"><code class="flex name class">
<span>class <span class="ident">FutureCancelledError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates that the computation underlying a Future was cancelled.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FutureCancelledError(Exception):
    &#34;&#34;&#34;Indicates that the computation underlying a Future was cancelled.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="grpc.FutureTimeoutError"><code class="flex name class">
<span>class <span class="ident">FutureTimeoutError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates that a method call on a Future timed out.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FutureTimeoutError(Exception):
    &#34;&#34;&#34;Indicates that a method call on a Future timed out.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="grpc.GenericRpcHandler"><code class="flex name class">
<span>class <span class="ident">GenericRpcHandler</span></span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of arbitrarily many RPC methods.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;An implementation of arbitrarily many RPC methods.&#34;&#34;&#34;

    @abc.abstractmethod
    def service(self, handler_call_details):
        &#34;&#34;&#34;Returns the handler for servicing the RPC.

        Args:
          handler_call_details: A HandlerCallDetails describing the RPC.

        Returns:
          An RpcMethodHandler with which the RPC may be serviced if the
          implementation chooses to service this RPC, or None otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="grpc.ServiceRpcHandler" href="#grpc.ServiceRpcHandler">ServiceRpcHandler</a></li>
<li>grpc.beta._server_adaptations._GenericRpcHandler</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.GenericRpcHandler.service"><code class="name flex">
<span>def <span class="ident">service</span></span>(<span>self, handler_call_details)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the handler for servicing the RPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handler_call_details</code></strong></dt>
<dd>A HandlerCallDetails describing the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An</code> <a title="grpc.RpcMethodHandler" href="#grpc.RpcMethodHandler"><code>RpcMethodHandler</code></a> <code>with</code> <code>which</code> <code>the</code> <code>RPC</code> <code>may</code> <code>be</code> <code>serviced</code> <code>if</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>implementation chooses to service this RPC, or None otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def service(self, handler_call_details):
    &#34;&#34;&#34;Returns the handler for servicing the RPC.

    Args:
      handler_call_details: A HandlerCallDetails describing the RPC.

    Returns:
      An RpcMethodHandler with which the RPC may be serviced if the
      implementation chooses to service this RPC, or None otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.HandlerCallDetails"><code class="flex name class">
<span>class <span class="ident">HandlerCallDetails</span></span>
</code></dt>
<dd>
<section class="desc"><p>Describes an RPC that has just arrived for service.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd>The method name of the RPC.</dd>
<dt><strong><code>invocation_metadata</code></strong></dt>
<dd>The :term:<code>metadata</code> sent by the client.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Describes an RPC that has just arrived for service.

    Attributes:
      method: The method name of the RPC.
      invocation_metadata: The :term:`metadata` sent by the client.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="grpc.LocalConnectionType"><code class="flex name class">
<span>class <span class="ident">LocalConnectionType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Types of local connection for local credential creation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>UDS</code></strong></dt>
<dd>Unix domain socket connections</dd>
<dt><strong><code>LOCAL_TCP</code></strong></dt>
<dd>Local TCP connections.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalConnectionType(enum.Enum):
    &#34;&#34;&#34;Types of local connection for local credential creation.

    Attributes:
      UDS: Unix domain socket connections
      LOCAL_TCP: Local TCP connections.
    &#34;&#34;&#34;
    UDS = _cygrpc.LocalConnectionType.uds
    LOCAL_TCP = _cygrpc.LocalConnectionType.local_tcp</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="grpc.LocalConnectionType.LOCAL_TCP"><code class="name">var <span class="ident">LOCAL_TCP</span></code></dt>
<dd>
<section class="desc"><p>Types of local connection for local credential creation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>UDS</code></strong></dt>
<dd>Unix domain socket connections</dd>
<dt><strong><code>LOCAL_TCP</code></strong></dt>
<dd>Local TCP connections.</dd>
</dl></section>
</dd>
<dt id="grpc.LocalConnectionType.UDS"><code class="name">var <span class="ident">UDS</span></code></dt>
<dd>
<section class="desc"><p>Types of local connection for local credential creation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>UDS</code></strong></dt>
<dd>Unix domain socket connections</dd>
<dt><strong><code>LOCAL_TCP</code></strong></dt>
<dd>Local TCP connections.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="grpc.RpcContext"><code class="flex name class">
<span>class <span class="ident">RpcContext</span></span>
</code></dt>
<dd>
<section class="desc"><p>Provides RPC-related information and action.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcContext(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Provides RPC-related information and action.&#34;&#34;&#34;

    @abc.abstractmethod
    def is_active(self):
        &#34;&#34;&#34;Describes whether the RPC is active or has terminated.

        Returns:
          bool:
          True if RPC is active, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def time_remaining(self):
        &#34;&#34;&#34;Describes the length of allowed time remaining for the RPC.

        Returns:
          A nonnegative float indicating the length of allowed time in seconds
          remaining for the RPC to complete before it is considered to have
          timed out, or None if no deadline was specified for the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def cancel(self):
        &#34;&#34;&#34;Cancels the RPC.

        Idempotent and has no effect if the RPC has already terminated.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_callback(self, callback):
        &#34;&#34;&#34;Registers a callback to be called on RPC termination.

        Args:
          callback: A no-parameter callable to be called on RPC termination.

        Returns:
          True if the callback was added and will be called later; False if
            the callback was not added and will not be called (because the RPC
            already terminated or some other reason).
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="grpc.Call" href="#grpc.Call">Call</a></li>
<li><a title="grpc.ServicerContext" href="#grpc.ServicerContext">ServicerContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.RpcContext.add_callback"><code class="name flex">
<span>def <span class="ident">add_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<section class="desc"><p>Registers a callback to be called on RPC termination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callback</code></strong></dt>
<dd>A no-parameter callable to be called on RPC termination.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>the</code> <code>callback</code> <code>was</code> <code>added</code> <code>and</code> <code>will</code> <code>be</code> <code>called</code> <code>later</code>; <code>False</code> <code>if</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>the callback was not added and will not be called (because the RPC
already terminated or some other reason).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_callback(self, callback):
    &#34;&#34;&#34;Registers a callback to be called on RPC termination.

    Args:
      callback: A no-parameter callable to be called on RPC termination.

    Returns:
      True if the callback was added and will be called later; False if
        the callback was not added and will not be called (because the RPC
        already terminated or some other reason).
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.RpcContext.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Cancels the RPC.</p>
<p>Idempotent and has no effect if the RPC has already terminated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def cancel(self):
    &#34;&#34;&#34;Cancels the RPC.

    Idempotent and has no effect if the RPC has already terminated.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.RpcContext.is_active"><code class="name flex">
<span>def <span class="ident">is_active</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes whether the RPC is active or has terminated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code>:</dt>
<dd>&nbsp;</dd>
</dl>
<p>True if RPC is active, False otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def is_active(self):
    &#34;&#34;&#34;Describes whether the RPC is active or has terminated.

    Returns:
      bool:
      True if RPC is active, False otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.RpcContext.time_remaining"><code class="name flex">
<span>def <span class="ident">time_remaining</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes the length of allowed time remaining for the RPC.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>nonnegative</code> <code>float</code> <code>indicating</code> <code>the</code> <code>length</code> of <code>allowed</code> <code>time</code> <code>in</code> <code>seconds</code></dt>
<dd>&nbsp;</dd>
<dt><code>remaining</code> <code>for</code> <code>the</code> <code>RPC</code> <code>to</code> <code>complete</code> <code>before</code> <code>it</code> <code>is</code> <code>considered</code> <code>to</code> <code>have</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>timed out, or None if no deadline was specified for the RPC.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def time_remaining(self):
    &#34;&#34;&#34;Describes the length of allowed time remaining for the RPC.

    Returns:
      A nonnegative float indicating the length of allowed time in seconds
      remaining for the RPC to complete before it is considered to have
      timed out, or None if no deadline was specified for the RPC.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.RpcError"><code class="flex name class">
<span>class <span class="ident">RpcError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised by the gRPC library to indicate non-OK-status RPC termination.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcError(Exception):
    &#34;&#34;&#34;Raised by the gRPC library to indicate non-OK-status RPC termination.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>grpc.experimental.aio._call.AioRpcError</li>
</ul>
</dd>
<dt id="grpc.RpcMethodHandler"><code class="flex name class">
<span>class <span class="ident">RpcMethodHandler</span></span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of a single RPC method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>request_streaming</code></strong></dt>
<dd>Whether the RPC supports exactly one request message
or any arbitrary number of request messages.</dd>
<dt><strong><code>response_streaming</code></strong></dt>
<dd>Whether the RPC supports exactly one response message
or any arbitrary number of response messages.</dd>
<dt><strong><code>request_deserializer</code></strong></dt>
<dd>A callable behavior that accepts a byte string and
returns an object suitable to be passed to this object's business
logic, or None to indicate that this object's business logic should be
passed the raw request bytes.</dd>
<dt><strong><code>response_serializer</code></strong></dt>
<dd>A callable behavior that accepts an object produced
by this object's business logic and returns a byte string, or None to
indicate that the byte strings produced by this object's business logic
should be transmitted on the wire as they are.</dd>
<dt><strong><code>unary_unary</code></strong></dt>
<dd>This object's application-specific business logic as a
callable value that takes a request value and a ServicerContext object
and returns a response value. Only non-None if both request_streaming
and response_streaming are False.</dd>
<dt><strong><code>unary_stream</code></strong></dt>
<dd>This object's application-specific business logic as a
callable value that takes a request value and a ServicerContext object
and returns an iterator of response values. Only non-None if
request_streaming is False and response_streaming is True.</dd>
<dt><strong><code>stream_unary</code></strong></dt>
<dd>This object's application-specific business logic as a
callable value that takes an iterator of request values and a
ServicerContext object and returns a response value. Only non-None if
request_streaming is True and response_streaming is False.</dd>
<dt><strong><code>stream_stream</code></strong></dt>
<dd>This object's application-specific business logic as a
callable value that takes an iterator of request values and a
ServicerContext object and returns an iterator of response values.
Only non-None if request_streaming and response_streaming are both
True.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcMethodHandler(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;An implementation of a single RPC method.

    Attributes:
      request_streaming: Whether the RPC supports exactly one request message
        or any arbitrary number of request messages.
      response_streaming: Whether the RPC supports exactly one response message
        or any arbitrary number of response messages.
      request_deserializer: A callable behavior that accepts a byte string and
        returns an object suitable to be passed to this object&#39;s business
        logic, or None to indicate that this object&#39;s business logic should be
        passed the raw request bytes.
      response_serializer: A callable behavior that accepts an object produced
        by this object&#39;s business logic and returns a byte string, or None to
        indicate that the byte strings produced by this object&#39;s business logic
        should be transmitted on the wire as they are.
      unary_unary: This object&#39;s application-specific business logic as a
        callable value that takes a request value and a ServicerContext object
        and returns a response value. Only non-None if both request_streaming
        and response_streaming are False.
      unary_stream: This object&#39;s application-specific business logic as a
        callable value that takes a request value and a ServicerContext object
        and returns an iterator of response values. Only non-None if
        request_streaming is False and response_streaming is True.
      stream_unary: This object&#39;s application-specific business logic as a
        callable value that takes an iterator of request values and a
        ServicerContext object and returns a response value. Only non-None if
        request_streaming is True and response_streaming is False.
      stream_stream: This object&#39;s application-specific business logic as a
        callable value that takes an iterator of request values and a
        ServicerContext object and returns an iterator of response values.
        Only non-None if request_streaming and response_streaming are both
        True.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>grpc.beta._server_adaptations._SimpleMethodHandler</li>
</ul>
</dd>
<dt id="grpc.Server"><code class="flex name class">
<span>class <span class="ident">Server</span></span>
</code></dt>
<dd>
<section class="desc"><p>Services RPCs.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Server(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Services RPCs.&#34;&#34;&#34;

    @abc.abstractmethod
    def add_generic_rpc_handlers(self, generic_rpc_handlers):
        &#34;&#34;&#34;Registers GenericRpcHandlers with this Server.

        This method is only safe to call before the server is started.

        Args:
          generic_rpc_handlers: An iterable of GenericRpcHandlers that will be
          used to service RPCs.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_insecure_port(self, address):
        &#34;&#34;&#34;Opens an insecure port for accepting RPCs.

        This method may only be called before starting the server.

        Args:
          address: The address for which to open a port. If the port is 0,
            or not specified in the address, then gRPC runtime will choose a port.

        Returns:
          An integer port on which server will accept RPC requests.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def add_secure_port(self, address, server_credentials):
        &#34;&#34;&#34;Opens a secure port for accepting RPCs.

        This method may only be called before starting the server.

        Args:
          address: The address for which to open a port.
            if the port is 0, or not specified in the address, then gRPC
            runtime will choose a port.
          server_credentials: A ServerCredentials object.

        Returns:
          An integer port on which server will accept RPC requests.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def start(self):
        &#34;&#34;&#34;Starts this Server.

        This method may only be called once. (i.e. it is not idempotent).
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def stop(self, grace):
        &#34;&#34;&#34;Stops this Server.

        This method immediately stop service of new RPCs in all cases.

        If a grace period is specified, this method returns immediately
        and all RPCs active at the end of the grace period are aborted.
        If a grace period is not specified (by passing None for `grace`),
        all existing RPCs are aborted immediately and this method
        blocks until the last RPC handler terminates.

        This method is idempotent and may be called at any time.
        Passing a smaller grace value in a subsequent call will have
        the effect of stopping the Server sooner (passing None will
        have the effect of stopping the server immediately). Passing
        a larger grace value in a subsequent call *will not* have the
        effect of stopping the server later (i.e. the most restrictive
        grace value is used).

        Args:
          grace: A duration of time in seconds or None.

        Returns:
          A threading.Event that will be set when this Server has completely
          stopped, i.e. when running RPCs either complete or are aborted and
          all handlers have terminated.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def wait_for_termination(self, timeout=None):
        &#34;&#34;&#34;Block current thread until the server stops.

        This is an EXPERIMENTAL API.

        The wait will not consume computational resources during blocking, and
        it will block until one of the two following conditions are met:

        1) The server is stopped or terminated;
        2) A timeout occurs if timeout is not `None`.

        The timeout argument works in the same way as `threading.Event.wait()`.
        https://docs.python.org/3/library/threading.html#threading.Event.wait

        Args:
          timeout: A floating point number specifying a timeout for the
            operation in seconds.

        Returns:
          A bool indicates if the operation times out.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.Server.add_generic_rpc_handlers"><code class="name flex">
<span>def <span class="ident">add_generic_rpc_handlers</span></span>(<span>self, generic_rpc_handlers)</span>
</code></dt>
<dd>
<section class="desc"><p>Registers GenericRpcHandlers with this Server.</p>
<p>This method is only safe to call before the server is started.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generic_rpc_handlers</code></strong></dt>
<dd>An iterable of GenericRpcHandlers that will be</dd>
</dl>
<p>used to service RPCs.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_generic_rpc_handlers(self, generic_rpc_handlers):
    &#34;&#34;&#34;Registers GenericRpcHandlers with this Server.

    This method is only safe to call before the server is started.

    Args:
      generic_rpc_handlers: An iterable of GenericRpcHandlers that will be
      used to service RPCs.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Server.add_insecure_port"><code class="name flex">
<span>def <span class="ident">add_insecure_port</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Opens an insecure port for accepting RPCs.</p>
<p>This method may only be called before starting the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>The address for which to open a port. If the port is 0,
or not specified in the address, then gRPC runtime will choose a port.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An integer port on which server will accept RPC requests.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_insecure_port(self, address):
    &#34;&#34;&#34;Opens an insecure port for accepting RPCs.

    This method may only be called before starting the server.

    Args:
      address: The address for which to open a port. If the port is 0,
        or not specified in the address, then gRPC runtime will choose a port.

    Returns:
      An integer port on which server will accept RPC requests.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Server.add_secure_port"><code class="name flex">
<span>def <span class="ident">add_secure_port</span></span>(<span>self, address, server_credentials)</span>
</code></dt>
<dd>
<section class="desc"><p>Opens a secure port for accepting RPCs.</p>
<p>This method may only be called before starting the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>The address for which to open a port.
if the port is 0, or not specified in the address, then gRPC
runtime will choose a port.</dd>
<dt><strong><code>server_credentials</code></strong></dt>
<dd>A ServerCredentials object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An integer port on which server will accept RPC requests.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def add_secure_port(self, address, server_credentials):
    &#34;&#34;&#34;Opens a secure port for accepting RPCs.

    This method may only be called before starting the server.

    Args:
      address: The address for which to open a port.
        if the port is 0, or not specified in the address, then gRPC
        runtime will choose a port.
      server_credentials: A ServerCredentials object.

    Returns:
      An integer port on which server will accept RPC requests.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Server.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Starts this Server.</p>
<p>This method may only be called once. (i.e. it is not idempotent).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def start(self):
    &#34;&#34;&#34;Starts this Server.

    This method may only be called once. (i.e. it is not idempotent).
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Server.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, grace)</span>
</code></dt>
<dd>
<section class="desc"><p>Stops this Server.</p>
<p>This method immediately stop service of new RPCs in all cases.</p>
<p>If a grace period is specified, this method returns immediately
and all RPCs active at the end of the grace period are aborted.
If a grace period is not specified (by passing None for <code>grace</code>),
all existing RPCs are aborted immediately and this method
blocks until the last RPC handler terminates.</p>
<p>This method is idempotent and may be called at any time.
Passing a smaller grace value in a subsequent call will have
the effect of stopping the Server sooner (passing None will
have the effect of stopping the server immediately). Passing
a larger grace value in a subsequent call <em>will not</em> have the
effect of stopping the server later (i.e. the most restrictive
grace value is used).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grace</code></strong></dt>
<dd>A duration of time in seconds or None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>threading.Event</code> <code>that</code> <code>will</code> <code>be</code> <code>set</code> <code>when</code> <code>this</code> <a title="grpc.Server" href="#grpc.Server"><code>Server</code></a> <code>has</code> <code>completely</code></dt>
<dd>&nbsp;</dd>
<dt><code>stopped</code>, <code>i.e.</code> <code>when</code> <code>running</code> <code>RPCs</code> <code>either</code> <code>complete</code> or <code>are</code> <code>aborted</code> <code>and</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>all handlers have terminated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def stop(self, grace):
    &#34;&#34;&#34;Stops this Server.

    This method immediately stop service of new RPCs in all cases.

    If a grace period is specified, this method returns immediately
    and all RPCs active at the end of the grace period are aborted.
    If a grace period is not specified (by passing None for `grace`),
    all existing RPCs are aborted immediately and this method
    blocks until the last RPC handler terminates.

    This method is idempotent and may be called at any time.
    Passing a smaller grace value in a subsequent call will have
    the effect of stopping the Server sooner (passing None will
    have the effect of stopping the server immediately). Passing
    a larger grace value in a subsequent call *will not* have the
    effect of stopping the server later (i.e. the most restrictive
    grace value is used).

    Args:
      grace: A duration of time in seconds or None.

    Returns:
      A threading.Event that will be set when this Server has completely
      stopped, i.e. when running RPCs either complete or are aborted and
      all handlers have terminated.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.Server.wait_for_termination"><code class="name flex">
<span>def <span class="ident">wait_for_termination</span></span>(<span>self, timeout=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Block current thread until the server stops.</p>
<p>This is an EXPERIMENTAL API.</p>
<p>The wait will not consume computational resources during blocking, and
it will block until one of the two following conditions are met:</p>
<p>1) The server is stopped or terminated;
2) A timeout occurs if timeout is not <code>None</code>.</p>
<p>The timeout argument works in the same way as <code>threading.Event.wait()</code>.
<a href="https://docs.python.org/3/library/threading.html#threading.Event.wait">https://docs.python.org/3/library/threading.html#threading.Event.wait</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>A floating point number specifying a timeout for the
operation in seconds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A bool indicates if the operation times out.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_termination(self, timeout=None):
    &#34;&#34;&#34;Block current thread until the server stops.

    This is an EXPERIMENTAL API.

    The wait will not consume computational resources during blocking, and
    it will block until one of the two following conditions are met:

    1) The server is stopped or terminated;
    2) A timeout occurs if timeout is not `None`.

    The timeout argument works in the same way as `threading.Event.wait()`.
    https://docs.python.org/3/library/threading.html#threading.Event.wait

    Args:
      timeout: A floating point number specifying a timeout for the
        operation in seconds.

    Returns:
      A bool indicates if the operation times out.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.ServerCertificateConfiguration"><code class="flex name class">
<span>class <span class="ident">ServerCertificateConfiguration</span></span>
<span>(</span><span>certificate_configuration)</span>
</code></dt>
<dd>
<section class="desc"><p>A certificate configuration for use with an SSL-enabled Server.</p>
<p>Instances of this class can be returned in the certificate configuration
fetching callback.</p>
<p>This class has no supported interface &ndash; it exists to define the
type of its instances and its instances exist to be passed to
other functions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerCertificateConfiguration(object):
    &#34;&#34;&#34;A certificate configuration for use with an SSL-enabled Server.

    Instances of this class can be returned in the certificate configuration
    fetching callback.

    This class has no supported interface -- it exists to define the
    type of its instances and its instances exist to be passed to
    other functions.
    &#34;&#34;&#34;

    def __init__(self, certificate_configuration):
        self._certificate_configuration = certificate_configuration</code></pre>
</details>
</dd>
<dt id="grpc.ServerCredentials"><code class="flex name class">
<span>class <span class="ident">ServerCredentials</span></span>
<span>(</span><span>credentials)</span>
</code></dt>
<dd>
<section class="desc"><p>An encapsulation of the data required to open a secure port on a Server.</p>
<p>This class has no supported interface - it exists to define the type of its
instances and its instances exist to be passed to other functions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerCredentials(object):
    &#34;&#34;&#34;An encapsulation of the data required to open a secure port on a Server.

    This class has no supported interface - it exists to define the type of its
    instances and its instances exist to be passed to other functions.
    &#34;&#34;&#34;

    def __init__(self, credentials):
        self._credentials = credentials</code></pre>
</details>
</dd>
<dt id="grpc.ServerInterceptor"><code class="flex name class">
<span>class <span class="ident">ServerInterceptor</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords intercepting incoming RPCs on the service-side.</p>
<p>This is an EXPERIMENTAL API.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting incoming RPCs on the service-side.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_service(self, continuation, handler_call_details):
        &#34;&#34;&#34;Intercepts incoming RPCs before handing them over to a handler.

        Args:
          continuation: A function that takes a HandlerCallDetails and
            proceeds to invoke the next interceptor in the chain, if any,
            or the RPC handler lookup logic, with the call details passed
            as an argument, and returns an RpcMethodHandler instance if
            the RPC is considered serviced, or None otherwise.
          handler_call_details: A HandlerCallDetails describing the RPC.

        Returns:
          An RpcMethodHandler with which the RPC may be serviced if the
          interceptor chooses to service this RPC, or None otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.ServerInterceptor.intercept_service"><code class="name flex">
<span>def <span class="ident">intercept_service</span></span>(<span>self, continuation, handler_call_details)</span>
</code></dt>
<dd>
<section class="desc"><p>Intercepts incoming RPCs before handing them over to a handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A function that takes a HandlerCallDetails and
proceeds to invoke the next interceptor in the chain, if any,
or the RPC handler lookup logic, with the call details passed
as an argument, and returns an RpcMethodHandler instance if
the RPC is considered serviced, or None otherwise.</dd>
<dt><strong><code>handler_call_details</code></strong></dt>
<dd>A HandlerCallDetails describing the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An</code> <a title="grpc.RpcMethodHandler" href="#grpc.RpcMethodHandler"><code>RpcMethodHandler</code></a> <code>with</code> <code>which</code> <code>the</code> <code>RPC</code> <code>may</code> <code>be</code> <code>serviced</code> <code>if</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>interceptor chooses to service this RPC, or None otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def intercept_service(self, continuation, handler_call_details):
    &#34;&#34;&#34;Intercepts incoming RPCs before handing them over to a handler.

    Args:
      continuation: A function that takes a HandlerCallDetails and
        proceeds to invoke the next interceptor in the chain, if any,
        or the RPC handler lookup logic, with the call details passed
        as an argument, and returns an RpcMethodHandler instance if
        the RPC is considered serviced, or None otherwise.
      handler_call_details: A HandlerCallDetails describing the RPC.

    Returns:
      An RpcMethodHandler with which the RPC may be serviced if the
      interceptor chooses to service this RPC, or None otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.ServiceRpcHandler"><code class="flex name class">
<span>class <span class="ident">ServiceRpcHandler</span></span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of RPC methods belonging to a service.</p>
<p>A service handles RPC methods with structured names of the form
'/Service.Name/Service.Method', where 'Service.Name' is the value
returned by service_name(), and 'Service.Method' is the method
name.
A service can have multiple method names, but only a single
service name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServiceRpcHandler(six.with_metaclass(abc.ABCMeta, GenericRpcHandler)):
    &#34;&#34;&#34;An implementation of RPC methods belonging to a service.

    A service handles RPC methods with structured names of the form
    &#39;/Service.Name/Service.Method&#39;, where &#39;Service.Name&#39; is the value
    returned by service_name(), and &#39;Service.Method&#39; is the method
    name.  A service can have multiple method names, but only a single
    service name.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def service_name(self):
        &#34;&#34;&#34;Returns this service&#39;s name.

        Returns:
          The service name.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="grpc.GenericRpcHandler" href="#grpc.GenericRpcHandler">GenericRpcHandler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.ServiceRpcHandler.service_name"><code class="name flex">
<span>def <span class="ident">service_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns this service's name.</p>
<h2 id="returns">Returns</h2>
<p>The service name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def service_name(self):
    &#34;&#34;&#34;Returns this service&#39;s name.

    Returns:
      The service name.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grpc.GenericRpcHandler" href="#grpc.GenericRpcHandler">GenericRpcHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="grpc.GenericRpcHandler.service" href="#grpc.GenericRpcHandler.service">service</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="grpc.ServicerContext"><code class="flex name class">
<span>class <span class="ident">ServicerContext</span></span>
</code></dt>
<dd>
<section class="desc"><p>A context object passed to method implementations.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):
    &#34;&#34;&#34;A context object passed to method implementations.&#34;&#34;&#34;

    @abc.abstractmethod
    def invocation_metadata(self):
        &#34;&#34;&#34;Accesses the metadata from the sent by the client.

        Returns:
          The invocation :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def peer(self):
        &#34;&#34;&#34;Identifies the peer that invoked the RPC being serviced.

        Returns:
          A string identifying the peer that invoked the RPC being serviced.
          The string format is determined by gRPC runtime.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def peer_identities(self):
        &#34;&#34;&#34;Gets one or more peer identity(s).

        Equivalent to
        servicer_context.auth_context().get(servicer_context.peer_identity_key())

        Returns:
          An iterable of the identities, or None if the call is not
          authenticated. Each identity is returned as a raw bytes type.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def peer_identity_key(self):
        &#34;&#34;&#34;The auth property used to identify the peer.

        For example, &#34;x509_common_name&#34; or &#34;x509_subject_alternative_name&#34; are
        used to identify an SSL peer.

        Returns:
          The auth property (string) that indicates the
          peer identity, or None if the call is not authenticated.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def auth_context(self):
        &#34;&#34;&#34;Gets the auth context for the call.

        Returns:
          A map of strings to an iterable of bytes for each auth property.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def set_compression(self, compression):
        &#34;&#34;&#34;Set the compression algorithm to be used for the entire call.

        This is an EXPERIMENTAL method.

        Args:
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def send_initial_metadata(self, initial_metadata):
        &#34;&#34;&#34;Sends the initial metadata value to the client.

        This method need not be called by implementations if they have no
        metadata to add to what the gRPC runtime will transmit.

        Args:
          initial_metadata: The initial :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def set_trailing_metadata(self, trailing_metadata):
        &#34;&#34;&#34;Sends the trailing metadata for the RPC.

        This method need not be called by implementations if they have no
        metadata to add to what the gRPC runtime will transmit.

        Args:
          trailing_metadata: The trailing :term:`metadata`.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def abort(self, code, details):
        &#34;&#34;&#34;Raises an exception to terminate the RPC with a non-OK status.

        The code and details passed as arguments will supercede any existing
        ones.

        Args:
          code: A StatusCode object to be sent to the client.
            It must not be StatusCode.OK.
          details: A UTF-8-encodable string to be sent to the client upon
            termination of the RPC.

        Raises:
          Exception: An exception is always raised to signal the abortion the
            RPC to the gRPC runtime.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def abort_with_status(self, status):
        &#34;&#34;&#34;Raises an exception to terminate the RPC with a non-OK status.

        The status passed as argument will supercede any existing status code,
        status message and trailing metadata.

        This is an EXPERIMENTAL API.

        Args:
          status: A grpc.Status object. The status code in it must not be
            StatusCode.OK.

        Raises:
          Exception: An exception is always raised to signal the abortion the
            RPC to the gRPC runtime.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def set_code(self, code):
        &#34;&#34;&#34;Sets the value to be used as status code upon RPC completion.

        This method need not be called by method implementations if they wish
        the gRPC runtime to determine the status code of the RPC.

        Args:
          code: A StatusCode object to be sent to the client.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def set_details(self, details):
        &#34;&#34;&#34;Sets the value to be used as detail string upon RPC completion.

        This method need not be called by method implementations if they have
        no details to transmit.

        Args:
          details: A UTF-8-encodable string to be sent to the client upon
            termination of the RPC.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def disable_next_message_compression(self):
        &#34;&#34;&#34;Disables compression for the next response message.

        This is an EXPERIMENTAL method.

        This method will override any compression configuration set during
        server creation or set on the call.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="grpc.RpcContext" href="#grpc.RpcContext">RpcContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grpc.ServicerContext.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self, code, details)</span>
</code></dt>
<dd>
<section class="desc"><p>Raises an exception to terminate the RPC with a non-OK status.</p>
<p>The code and details passed as arguments will supercede any existing
ones.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong></dt>
<dd>A StatusCode object to be sent to the client.
It must not be StatusCode.OK.</dd>
<dt><strong><code>details</code></strong></dt>
<dd>A UTF-8-encodable string to be sent to the client upon
termination of the RPC.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>An exception is always raised to signal the abortion the
RPC to the gRPC runtime.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def abort(self, code, details):
    &#34;&#34;&#34;Raises an exception to terminate the RPC with a non-OK status.

    The code and details passed as arguments will supercede any existing
    ones.

    Args:
      code: A StatusCode object to be sent to the client.
        It must not be StatusCode.OK.
      details: A UTF-8-encodable string to be sent to the client upon
        termination of the RPC.

    Raises:
      Exception: An exception is always raised to signal the abortion the
        RPC to the gRPC runtime.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.abort_with_status"><code class="name flex">
<span>def <span class="ident">abort_with_status</span></span>(<span>self, status)</span>
</code></dt>
<dd>
<section class="desc"><p>Raises an exception to terminate the RPC with a non-OK status.</p>
<p>The status passed as argument will supercede any existing status code,
status message and trailing metadata.</p>
<p>This is an EXPERIMENTAL API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>A grpc.Status object. The status code in it must not be
StatusCode.OK.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>An exception is always raised to signal the abortion the
RPC to the gRPC runtime.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def abort_with_status(self, status):
    &#34;&#34;&#34;Raises an exception to terminate the RPC with a non-OK status.

    The status passed as argument will supercede any existing status code,
    status message and trailing metadata.

    This is an EXPERIMENTAL API.

    Args:
      status: A grpc.Status object. The status code in it must not be
        StatusCode.OK.

    Raises:
      Exception: An exception is always raised to signal the abortion the
        RPC to the gRPC runtime.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.auth_context"><code class="name flex">
<span>def <span class="ident">auth_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the auth context for the call.</p>
<h2 id="returns">Returns</h2>
<p>A map of strings to an iterable of bytes for each auth property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def auth_context(self):
    &#34;&#34;&#34;Gets the auth context for the call.

    Returns:
      A map of strings to an iterable of bytes for each auth property.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.disable_next_message_compression"><code class="name flex">
<span>def <span class="ident">disable_next_message_compression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Disables compression for the next response message.</p>
<p>This is an EXPERIMENTAL method.</p>
<p>This method will override any compression configuration set during
server creation or set on the call.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_next_message_compression(self):
    &#34;&#34;&#34;Disables compression for the next response message.

    This is an EXPERIMENTAL method.

    This method will override any compression configuration set during
    server creation or set on the call.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.invocation_metadata"><code class="name flex">
<span>def <span class="ident">invocation_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Accesses the metadata from the sent by the client.</p>
<h2 id="returns">Returns</h2>
<p>The invocation :term:<code>metadata</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def invocation_metadata(self):
    &#34;&#34;&#34;Accesses the metadata from the sent by the client.

    Returns:
      The invocation :term:`metadata`.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.peer"><code class="name flex">
<span>def <span class="ident">peer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Identifies the peer that invoked the RPC being serviced.</p>
<h2 id="returns">Returns</h2>
<p>A string identifying the peer that invoked the RPC being serviced.
The string format is determined by gRPC runtime.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def peer(self):
    &#34;&#34;&#34;Identifies the peer that invoked the RPC being serviced.

    Returns:
      A string identifying the peer that invoked the RPC being serviced.
      The string format is determined by gRPC runtime.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.peer_identities"><code class="name flex">
<span>def <span class="ident">peer_identities</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets one or more peer identity(s).</p>
<p>Equivalent to
servicer_context.auth_context().get(servicer_context.peer_identity_key())</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An</code> <code>iterable</code> of <code>the</code> <code>identities</code>, or <code>None</code> <code>if</code> <code>the</code> <code>call</code> <code>is</code> <code>not</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>authenticated. Each identity is returned as a raw bytes type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def peer_identities(self):
    &#34;&#34;&#34;Gets one or more peer identity(s).

    Equivalent to
    servicer_context.auth_context().get(servicer_context.peer_identity_key())

    Returns:
      An iterable of the identities, or None if the call is not
      authenticated. Each identity is returned as a raw bytes type.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.peer_identity_key"><code class="name flex">
<span>def <span class="ident">peer_identity_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The auth property used to identify the peer.</p>
<p>For example, "x509_common_name" or "x509_subject_alternative_name" are
used to identify an SSL peer.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>auth</code> <code>property</code> (<code>string</code>) <code>that</code> <code>indicates</code> <code>the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>peer identity, or None if the call is not authenticated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def peer_identity_key(self):
    &#34;&#34;&#34;The auth property used to identify the peer.

    For example, &#34;x509_common_name&#34; or &#34;x509_subject_alternative_name&#34; are
    used to identify an SSL peer.

    Returns:
      The auth property (string) that indicates the
      peer identity, or None if the call is not authenticated.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.send_initial_metadata"><code class="name flex">
<span>def <span class="ident">send_initial_metadata</span></span>(<span>self, initial_metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends the initial metadata value to the client.</p>
<p>This method need not be called by implementations if they have no
metadata to add to what the gRPC runtime will transmit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_metadata</code></strong></dt>
<dd>The initial :term:<code>metadata</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def send_initial_metadata(self, initial_metadata):
    &#34;&#34;&#34;Sends the initial metadata value to the client.

    This method need not be called by implementations if they have no
    metadata to add to what the gRPC runtime will transmit.

    Args:
      initial_metadata: The initial :term:`metadata`.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.set_code"><code class="name flex">
<span>def <span class="ident">set_code</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the value to be used as status code upon RPC completion.</p>
<p>This method need not be called by method implementations if they wish
the gRPC runtime to determine the status code of the RPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong></dt>
<dd>A StatusCode object to be sent to the client.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_code(self, code):
    &#34;&#34;&#34;Sets the value to be used as status code upon RPC completion.

    This method need not be called by method implementations if they wish
    the gRPC runtime to determine the status code of the RPC.

    Args:
      code: A StatusCode object to be sent to the client.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, compression)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the compression algorithm to be used for the entire call.</p>
<p>This is an EXPERIMENTAL method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compression(self, compression):
    &#34;&#34;&#34;Set the compression algorithm to be used for the entire call.

    This is an EXPERIMENTAL method.

    Args:
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.set_details"><code class="name flex">
<span>def <span class="ident">set_details</span></span>(<span>self, details)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the value to be used as detail string upon RPC completion.</p>
<p>This method need not be called by method implementations if they have
no details to transmit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>details</code></strong></dt>
<dd>A UTF-8-encodable string to be sent to the client upon
termination of the RPC.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_details(self, details):
    &#34;&#34;&#34;Sets the value to be used as detail string upon RPC completion.

    This method need not be called by method implementations if they have
    no details to transmit.

    Args:
      details: A UTF-8-encodable string to be sent to the client upon
        termination of the RPC.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.ServicerContext.set_trailing_metadata"><code class="name flex">
<span>def <span class="ident">set_trailing_metadata</span></span>(<span>self, trailing_metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends the trailing metadata for the RPC.</p>
<p>This method need not be called by implementations if they have no
metadata to add to what the gRPC runtime will transmit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trailing_metadata</code></strong></dt>
<dd>The trailing :term:<code>metadata</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_trailing_metadata(self, trailing_metadata):
    &#34;&#34;&#34;Sends the trailing metadata for the RPC.

    This method need not be called by implementations if they have no
    metadata to add to what the gRPC runtime will transmit.

    Args:
      trailing_metadata: The trailing :term:`metadata`.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grpc.RpcContext" href="#grpc.RpcContext">RpcContext</a></b></code>:
<ul class="hlist">
<li><code><a title="grpc.RpcContext.add_callback" href="#grpc.RpcContext.add_callback">add_callback</a></code></li>
<li><code><a title="grpc.RpcContext.cancel" href="#grpc.RpcContext.cancel">cancel</a></code></li>
<li><code><a title="grpc.RpcContext.is_active" href="#grpc.RpcContext.is_active">is_active</a></code></li>
<li><code><a title="grpc.RpcContext.time_remaining" href="#grpc.RpcContext.time_remaining">time_remaining</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="grpc.Status"><code class="flex name class">
<span>class <span class="ident">Status</span></span>
</code></dt>
<dd>
<section class="desc"><p>Describes the status of an RPC.</p>
<p>This is an EXPERIMENTAL API.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>code</code></strong></dt>
<dd>A StatusCode object to be sent to the client.</dd>
<dt><strong><code>details</code></strong></dt>
<dd>A UTF-8-encodable string to be sent to the client upon
termination of the RPC.</dd>
<dt><strong><code>trailing_metadata</code></strong></dt>
<dd>The trailing :term:<code>metadata</code> in the RPC.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Status(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Describes the status of an RPC.

    This is an EXPERIMENTAL API.

    Attributes:
      code: A StatusCode object to be sent to the client.
      details: A UTF-8-encodable string to be sent to the client upon
        termination of the RPC.
      trailing_metadata: The trailing :term:`metadata` in the RPC.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="grpc.StatusCode"><code class="flex name class">
<span>class <span class="ident">StatusCode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatusCode(enum.Enum):
    &#34;&#34;&#34;Mirrors grpc_status_code in the gRPC Core.

    Attributes:
      OK: Not an error; returned on success
      CANCELLED: The operation was cancelled (typically by the caller).
      UNKNOWN: Unknown error.
      INVALID_ARGUMENT: Client specified an invalid argument.
      DEADLINE_EXCEEDED: Deadline expired before operation could complete.
      NOT_FOUND: Some requested entity (e.g., file or directory) was not found.
      ALREADY_EXISTS: Some entity that we attempted to create (e.g., file or directory)
        already exists.
      PERMISSION_DENIED: The caller does not have permission to execute the specified
        operation.
      UNAUTHENTICATED: The request does not have valid authentication credentials for the
        operation.
      RESOURCE_EXHAUSTED: Some resource has been exhausted, perhaps a per-user quota, or
        perhaps the entire file system is out of space.
      FAILED_PRECONDITION: Operation was rejected because the system is not in a state
        required for the operation&#39;s execution.
      ABORTED: The operation was aborted, typically due to a concurrency issue
        like sequencer check failures, transaction aborts, etc.
      UNIMPLEMENTED: Operation is not implemented or not supported/enabled in this service.
      INTERNAL: Internal errors.  Means some invariants expected by underlying
        system has been broken.
      UNAVAILABLE: The service is currently unavailable.
      DATA_LOSS: Unrecoverable data loss or corruption.
    &#34;&#34;&#34;
    OK = (_cygrpc.StatusCode.ok, &#39;ok&#39;)
    CANCELLED = (_cygrpc.StatusCode.cancelled, &#39;cancelled&#39;)
    UNKNOWN = (_cygrpc.StatusCode.unknown, &#39;unknown&#39;)
    INVALID_ARGUMENT = (_cygrpc.StatusCode.invalid_argument, &#39;invalid argument&#39;)
    DEADLINE_EXCEEDED = (_cygrpc.StatusCode.deadline_exceeded,
                         &#39;deadline exceeded&#39;)
    NOT_FOUND = (_cygrpc.StatusCode.not_found, &#39;not found&#39;)
    ALREADY_EXISTS = (_cygrpc.StatusCode.already_exists, &#39;already exists&#39;)
    PERMISSION_DENIED = (_cygrpc.StatusCode.permission_denied,
                         &#39;permission denied&#39;)
    RESOURCE_EXHAUSTED = (_cygrpc.StatusCode.resource_exhausted,
                          &#39;resource exhausted&#39;)
    FAILED_PRECONDITION = (_cygrpc.StatusCode.failed_precondition,
                           &#39;failed precondition&#39;)
    ABORTED = (_cygrpc.StatusCode.aborted, &#39;aborted&#39;)
    OUT_OF_RANGE = (_cygrpc.StatusCode.out_of_range, &#39;out of range&#39;)
    UNIMPLEMENTED = (_cygrpc.StatusCode.unimplemented, &#39;unimplemented&#39;)
    INTERNAL = (_cygrpc.StatusCode.internal, &#39;internal&#39;)
    UNAVAILABLE = (_cygrpc.StatusCode.unavailable, &#39;unavailable&#39;)
    DATA_LOSS = (_cygrpc.StatusCode.data_loss, &#39;data loss&#39;)
    UNAUTHENTICATED = (_cygrpc.StatusCode.unauthenticated, &#39;unauthenticated&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="grpc.StatusCode.ABORTED"><code class="name">var <span class="ident">ABORTED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.ALREADY_EXISTS"><code class="name">var <span class="ident">ALREADY_EXISTS</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.CANCELLED"><code class="name">var <span class="ident">CANCELLED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.DATA_LOSS"><code class="name">var <span class="ident">DATA_LOSS</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.DEADLINE_EXCEEDED"><code class="name">var <span class="ident">DEADLINE_EXCEEDED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.FAILED_PRECONDITION"><code class="name">var <span class="ident">FAILED_PRECONDITION</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.INTERNAL"><code class="name">var <span class="ident">INTERNAL</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.INVALID_ARGUMENT"><code class="name">var <span class="ident">INVALID_ARGUMENT</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.NOT_FOUND"><code class="name">var <span class="ident">NOT_FOUND</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.OK"><code class="name">var <span class="ident">OK</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.OUT_OF_RANGE"><code class="name">var <span class="ident">OUT_OF_RANGE</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.PERMISSION_DENIED"><code class="name">var <span class="ident">PERMISSION_DENIED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.RESOURCE_EXHAUSTED"><code class="name">var <span class="ident">RESOURCE_EXHAUSTED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.UNAUTHENTICATED"><code class="name">var <span class="ident">UNAUTHENTICATED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.UNAVAILABLE"><code class="name">var <span class="ident">UNAVAILABLE</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.UNIMPLEMENTED"><code class="name">var <span class="ident">UNIMPLEMENTED</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
<dt id="grpc.StatusCode.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<section class="desc"><p>Mirrors grpc_status_code in the gRPC Core.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OK</code></strong></dt>
<dd>Not an error; returned on success</dd>
<dt><strong><code>CANCELLED</code></strong></dt>
<dd>The operation was cancelled (typically by the caller).</dd>
<dt><strong><code>UNKNOWN</code></strong></dt>
<dd>Unknown error.</dd>
<dt><strong><code>INVALID_ARGUMENT</code></strong></dt>
<dd>Client specified an invalid argument.</dd>
<dt><strong><code>DEADLINE_EXCEEDED</code></strong></dt>
<dd>Deadline expired before operation could complete.</dd>
<dt><strong><code>NOT_FOUND</code></strong></dt>
<dd>Some requested entity (e.g., file or directory) was not found.</dd>
<dt><strong><code>ALREADY_EXISTS</code></strong></dt>
<dd>Some entity that we attempted to create (e.g., file or directory)
already exists.</dd>
<dt><strong><code>PERMISSION_DENIED</code></strong></dt>
<dd>The caller does not have permission to execute the specified
operation.</dd>
<dt><strong><code>UNAUTHENTICATED</code></strong></dt>
<dd>The request does not have valid authentication credentials for the
operation.</dd>
<dt><strong><code>RESOURCE_EXHAUSTED</code></strong></dt>
<dd>Some resource has been exhausted, perhaps a per-user quota, or
perhaps the entire file system is out of space.</dd>
<dt><strong><code>FAILED_PRECONDITION</code></strong></dt>
<dd>Operation was rejected because the system is not in a state
required for the operation's execution.</dd>
<dt><strong><code>ABORTED</code></strong></dt>
<dd>The operation was aborted, typically due to a concurrency issue
like sequencer check failures, transaction aborts, etc.</dd>
<dt><strong><code>UNIMPLEMENTED</code></strong></dt>
<dd>Operation is not implemented or not supported/enabled in this service.</dd>
<dt><strong><code>INTERNAL</code></strong></dt>
<dd>Internal errors.
Means some invariants expected by underlying
system has been broken.</dd>
<dt><strong><code>UNAVAILABLE</code></strong></dt>
<dd>The service is currently unavailable.</dd>
<dt><strong><code>DATA_LOSS</code></strong></dt>
<dd>Unrecoverable data loss or corruption.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="grpc.StreamStreamClientInterceptor"><code class="flex name class">
<span>class <span class="ident">StreamStreamClientInterceptor</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords intercepting stream-stream invocations.</p>
<p>This is an EXPERIMENTAL API.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamStreamClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting stream-stream invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_stream_stream(self, continuation, client_call_details,
                                request_iterator):
        &#34;&#34;&#34;Intercepts a stream-stream invocation.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_iterator = continuation(client_call_details, request_iterator)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and an iterator for response values.
            Drawing response values from the returned Call-iterator may
            raise RpcError indicating termination of the RPC with non-OK
            status.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request_iterator: An iterator that yields request values for the RPC.

        Returns:
          An object that is both a Call for the RPC and an iterator of
          response values. Drawing response values from the returned
          Call-iterator may raise RpcError indicating termination of
          the RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.StreamStreamClientInterceptor.intercept_stream_stream"><code class="name flex">
<span>def <span class="ident">intercept_stream_stream</span></span>(<span>self, continuation, client_call_details, request_iterator)</span>
</code></dt>
<dd>
<section class="desc"><p>Intercepts a stream-stream invocation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A function that proceeds with the invocation by
executing the next interceptor in chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>response_iterator = continuation(client_call_details, request_iterator)</code>
to continue with the RPC. <code>continuation</code> returns an object that is
both a Call for the RPC and an iterator for response values.
Drawing response values from the returned Call-iterator may
raise RpcError indicating termination of the RPC with non-OK
status.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request_iterator</code></strong></dt>
<dd>An iterator that yields request values for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An</code> <code>object</code> <code>that</code> <code>is</code> <code>both</code> <code>a</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a> <code>for</code> <code>the</code> <code>RPC</code> <code>and</code> <code>an</code> <code>iterator</code> of</dt>
<dd>&nbsp;</dd>
<dt><code>response</code> <code>values.</code> <code>Drawing</code> <code>response</code> <code>values</code> <code>from</code> <code>the</code> <code>returned</code></dt>
<dd>&nbsp;</dd>
<dt><a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>iterator</code> <code>may</code> <code>raise</code> <a title="grpc.RpcError" href="#grpc.RpcError"><code>RpcError</code></a> <code>indicating</code> <code>termination</code> of</dt>
<dd>&nbsp;</dd>
</dl>
<p>the RPC with non-OK status.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def intercept_stream_stream(self, continuation, client_call_details,
                            request_iterator):
    &#34;&#34;&#34;Intercepts a stream-stream invocation.

    Args:
      continuation: A function that proceeds with the invocation by
        executing the next interceptor in chain or invoking the
        actual RPC on the underlying Channel. It is the interceptor&#39;s
        responsibility to call it if it decides to move the RPC forward.
        The interceptor can use
        `response_iterator = continuation(client_call_details, request_iterator)`
        to continue with the RPC. `continuation` returns an object that is
        both a Call for the RPC and an iterator for response values.
        Drawing response values from the returned Call-iterator may
        raise RpcError indicating termination of the RPC with non-OK
        status.
      client_call_details: A ClientCallDetails object describing the
        outgoing RPC.
      request_iterator: An iterator that yields request values for the RPC.

    Returns:
      An object that is both a Call for the RPC and an iterator of
      response values. Drawing response values from the returned
      Call-iterator may raise RpcError indicating termination of
      the RPC with non-OK status.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.StreamStreamMultiCallable"><code class="flex name class">
<span>class <span class="ident">StreamStreamMultiCallable</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords invoking a stream-stream RPC on client-side.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a stream-stream RPC on client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request_iterator,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Invokes the underlying RPC on the client.

        Args:
          request_iterator: An iterator that yields request values for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If not specified, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and an iterator of
            response values. Drawing response values from the returned
            Call-iterator may raise RpcError indicating termination of the
            RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.StreamUnaryClientInterceptor"><code class="flex name class">
<span>class <span class="ident">StreamUnaryClientInterceptor</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords intercepting stream-unary invocations.</p>
<p>This is an EXPERIMENTAL API.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamUnaryClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting stream-unary invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_stream_unary(self, continuation, client_call_details,
                               request_iterator):
        &#34;&#34;&#34;Intercepts a stream-unary invocation asynchronously.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_future = continuation(client_call_details, request_iterator)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and a Future. In the event of RPC completion,
            the return Call-Future&#39;s result value will be the response message
            of the RPC. Should the event terminate with non-OK status, the
            returned Call-Future&#39;s exception value will be an RpcError.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request_iterator: An iterator that yields request values for the RPC.

        Returns:
          An object that is both a Call for the RPC and a Future.
          In the event of RPC completion, the return Call-Future&#39;s
          result value will be the response message of the RPC.
          Should the event terminate with non-OK status, the returned
          Call-Future&#39;s exception value will be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.StreamUnaryClientInterceptor.intercept_stream_unary"><code class="name flex">
<span>def <span class="ident">intercept_stream_unary</span></span>(<span>self, continuation, client_call_details, request_iterator)</span>
</code></dt>
<dd>
<section class="desc"><p>Intercepts a stream-unary invocation asynchronously.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A function that proceeds with the invocation by
executing the next interceptor in chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>response_future = continuation(client_call_details, request_iterator)</code>
to continue with the RPC. <code>continuation</code> returns an object that is
both a Call for the RPC and a Future. In the event of RPC completion,
the return Call-Future's result value will be the response message
of the RPC. Should the event terminate with non-OK status, the
returned Call-Future's exception value will be an RpcError.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request_iterator</code></strong></dt>
<dd>An iterator that yields request values for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>An object that is both a Call for the RPC and a Future.</dt>
<dt><code>In</code> <code>the</code> <code>event</code> of <code>RPC</code> <code>completion</code>, <code>the</code> <code>return</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>Future's</code></dt>
<dd>&nbsp;</dd>
<dt>result value will be the response message of the RPC.</dt>
<dt><code>Should</code> <code>the</code> <code>event</code> <code>terminate</code> <code>with</code> <code>non</code>-<code>OK</code> <code>status</code>, <code>the</code> <code>returned</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Call-Future's exception value will be an RpcError.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def intercept_stream_unary(self, continuation, client_call_details,
                           request_iterator):
    &#34;&#34;&#34;Intercepts a stream-unary invocation asynchronously.

    Args:
      continuation: A function that proceeds with the invocation by
        executing the next interceptor in chain or invoking the
        actual RPC on the underlying Channel. It is the interceptor&#39;s
        responsibility to call it if it decides to move the RPC forward.
        The interceptor can use
        `response_future = continuation(client_call_details, request_iterator)`
        to continue with the RPC. `continuation` returns an object that is
        both a Call for the RPC and a Future. In the event of RPC completion,
        the return Call-Future&#39;s result value will be the response message
        of the RPC. Should the event terminate with non-OK status, the
        returned Call-Future&#39;s exception value will be an RpcError.
      client_call_details: A ClientCallDetails object describing the
        outgoing RPC.
      request_iterator: An iterator that yields request values for the RPC.

    Returns:
      An object that is both a Call for the RPC and a Future.
      In the event of RPC completion, the return Call-Future&#39;s
      result value will be the response message of the RPC.
      Should the event terminate with non-OK status, the returned
      Call-Future&#39;s exception value will be an RpcError.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.StreamUnaryMultiCallable"><code class="flex name class">
<span>class <span class="ident">StreamUnaryMultiCallable</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords invoking a stream-unary RPC from client-side.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a stream-unary RPC from client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request_iterator,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC.

        Args:
          request_iterator: An iterator that yields request values for
            the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also implement grpc.Call, affording methods
            such as metadata, code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def with_call(self,
                  request_iterator,
                  timeout=None,
                  metadata=None,
                  credentials=None,
                  wait_for_ready=None,
                  compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC on the client.

        Args:
          request_iterator: An iterator that yields request values for
            the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC and a Call object for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def future(self,
               request_iterator,
               timeout=None,
               metadata=None,
               credentials=None,
               wait_for_ready=None,
               compression=None):
        &#34;&#34;&#34;Asynchronously invokes the underlying RPC on the client.

        Args:
          request_iterator: An iterator that yields request values for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and a Future.
            In the event of RPC completion, the return Call-Future&#39;s result value
            will be the response message of the RPC. Should the event terminate
            with non-OK status, the returned Call-Future&#39;s exception value will
            be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.StreamUnaryMultiCallable.future"><code class="name flex">
<span>def <span class="ident">future</span></span>(<span>self, request_iterator, timeout=None, metadata=None, credentials=None, wait_for_ready=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Asynchronously invokes the underlying RPC on the client.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_iterator</code></strong></dt>
<dd>An iterator that yields request values for the RPC.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>An optional duration of time in seconds to allow for
the RPC. If None, the timeout is considered infinite.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional :term:<code>metadata</code> to be transmitted to the
service-side of the RPC.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>An optional CallCredentials for the RPC. Only valid for
secure Channel.</dd>
<dt><strong><code>wait_for_ready</code></strong></dt>
<dd>This is an EXPERIMENTAL argument. An optional
flag to enable wait for ready mechanism</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>An object that is both a Call for the RPC and a Future.</dt>
<dt><code>In</code> <code>the</code> <code>event</code> of <code>RPC</code> <code>completion</code>, <code>the</code> <code>return</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>Future's</code> <code>result</code> <code>value</code></dt>
<dd>&nbsp;</dd>
<dt><code>will</code> <code>be</code> <code>the</code> <code>response</code> <code>message</code> of <code>the</code> <code>RPC.</code> <code>Should</code> <code>the</code> <code>event</code> <code>terminate</code></dt>
<dd>&nbsp;</dd>
<dt><code>with</code> <code>non</code>-<code>OK</code> <code>status</code>, <code>the</code> <code>returned</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>Future's</code> <code>exception</code> <code>value</code> <code>will</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>be an RpcError.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def future(self,
           request_iterator,
           timeout=None,
           metadata=None,
           credentials=None,
           wait_for_ready=None,
           compression=None):
    &#34;&#34;&#34;Asynchronously invokes the underlying RPC on the client.

    Args:
      request_iterator: An iterator that yields request values for the RPC.
      timeout: An optional duration of time in seconds to allow for
        the RPC. If None, the timeout is considered infinite.
      metadata: Optional :term:`metadata` to be transmitted to the
        service-side of the RPC.
      credentials: An optional CallCredentials for the RPC. Only valid for
        secure Channel.
      wait_for_ready: This is an EXPERIMENTAL argument. An optional
        flag to enable wait for ready mechanism
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This is an EXPERIMENTAL option.

    Returns:
        An object that is both a Call for the RPC and a Future.
        In the event of RPC completion, the return Call-Future&#39;s result value
        will be the response message of the RPC. Should the event terminate
        with non-OK status, the returned Call-Future&#39;s exception value will
        be an RpcError.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.StreamUnaryMultiCallable.with_call"><code class="name flex">
<span>def <span class="ident">with_call</span></span>(<span>self, request_iterator, timeout=None, metadata=None, credentials=None, wait_for_ready=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Synchronously invokes the underlying RPC on the client.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_iterator</code></strong></dt>
<dd>An iterator that yields request values for
the RPC.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>An optional duration of time in seconds to allow for
the RPC. If None, the timeout is considered infinite.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional :term:<code>metadata</code> to be transmitted to the
service-side of the RPC.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>An optional CallCredentials for the RPC. Only valid for
secure Channel.</dd>
<dt><strong><code>wait_for_ready</code></strong></dt>
<dd>This is an EXPERIMENTAL argument. An optional
flag to enable wait for ready mechanism</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The response value for the RPC and a Call object for the RPC.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.RpcError" href="#grpc.RpcError"><code>RpcError</code></a></strong></dt>
<dd>Indicating that the RPC terminated with non-OK status. The
raised RpcError will also be a Call for the RPC affording the RPC's
metadata, status code, and details.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def with_call(self,
              request_iterator,
              timeout=None,
              metadata=None,
              credentials=None,
              wait_for_ready=None,
              compression=None):
    &#34;&#34;&#34;Synchronously invokes the underlying RPC on the client.

    Args:
      request_iterator: An iterator that yields request values for
        the RPC.
      timeout: An optional duration of time in seconds to allow for
        the RPC. If None, the timeout is considered infinite.
      metadata: Optional :term:`metadata` to be transmitted to the
        service-side of the RPC.
      credentials: An optional CallCredentials for the RPC. Only valid for
        secure Channel.
      wait_for_ready: This is an EXPERIMENTAL argument. An optional
        flag to enable wait for ready mechanism
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This is an EXPERIMENTAL option.

    Returns:
      The response value for the RPC and a Call object for the RPC.

    Raises:
      RpcError: Indicating that the RPC terminated with non-OK status. The
        raised RpcError will also be a Call for the RPC affording the RPC&#39;s
        metadata, status code, and details.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.UnaryStreamClientInterceptor"><code class="flex name class">
<span>class <span class="ident">UnaryStreamClientInterceptor</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords intercepting unary-stream invocations.</p>
<p>This is an EXPERIMENTAL API.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryStreamClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting unary-stream invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_unary_stream(self, continuation, client_call_details,
                               request):
        &#34;&#34;&#34;Intercepts a unary-stream invocation.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_iterator = continuation(client_call_details, request)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and an iterator for response values.
            Drawing response values from the returned Call-iterator may
            raise RpcError indicating termination of the RPC with non-OK
            status.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request: The request value for the RPC.

        Returns:
            An object that is both a Call for the RPC and an iterator of
            response values. Drawing response values from the returned
            Call-iterator may raise RpcError indicating termination of
            the RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.UnaryStreamClientInterceptor.intercept_unary_stream"><code class="name flex">
<span>def <span class="ident">intercept_unary_stream</span></span>(<span>self, continuation, client_call_details, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Intercepts a unary-stream invocation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A function that proceeds with the invocation by
executing the next interceptor in chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>response_iterator = continuation(client_call_details, request)</code>
to continue with the RPC. <code>continuation</code> returns an object that is
both a Call for the RPC and an iterator for response values.
Drawing response values from the returned Call-iterator may
raise RpcError indicating termination of the RPC with non-OK
status.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The request value for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An</code> <code>object</code> <code>that</code> <code>is</code> <code>both</code> <code>a</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a> <code>for</code> <code>the</code> <code>RPC</code> <code>and</code> <code>an</code> <code>iterator</code> of</dt>
<dd>&nbsp;</dd>
<dt><code>response</code> <code>values.</code> <code>Drawing</code> <code>response</code> <code>values</code> <code>from</code> <code>the</code> <code>returned</code></dt>
<dd>&nbsp;</dd>
<dt><a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>iterator</code> <code>may</code> <code>raise</code> <a title="grpc.RpcError" href="#grpc.RpcError"><code>RpcError</code></a> <code>indicating</code> <code>termination</code> of</dt>
<dd>&nbsp;</dd>
</dl>
<p>the RPC with non-OK status.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def intercept_unary_stream(self, continuation, client_call_details,
                           request):
    &#34;&#34;&#34;Intercepts a unary-stream invocation.

    Args:
      continuation: A function that proceeds with the invocation by
        executing the next interceptor in chain or invoking the
        actual RPC on the underlying Channel. It is the interceptor&#39;s
        responsibility to call it if it decides to move the RPC forward.
        The interceptor can use
        `response_iterator = continuation(client_call_details, request)`
        to continue with the RPC. `continuation` returns an object that is
        both a Call for the RPC and an iterator for response values.
        Drawing response values from the returned Call-iterator may
        raise RpcError indicating termination of the RPC with non-OK
        status.
      client_call_details: A ClientCallDetails object describing the
        outgoing RPC.
      request: The request value for the RPC.

    Returns:
        An object that is both a Call for the RPC and an iterator of
        response values. Drawing response values from the returned
        Call-iterator may raise RpcError indicating termination of
        the RPC with non-OK status.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.UnaryStreamMultiCallable"><code class="flex name class">
<span>class <span class="ident">UnaryStreamMultiCallable</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords invoking a unary-stream RPC from client-side.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a unary-stream RPC from client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC. If None, the timeout is considered infinite.
          metadata: An optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and an iterator of
            response values. Drawing response values from the returned
            Call-iterator may raise RpcError indicating termination of the
            RPC with non-OK status.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.UnaryUnaryClientInterceptor"><code class="flex name class">
<span>class <span class="ident">UnaryUnaryClientInterceptor</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords intercepting unary-unary invocations.</p>
<p>This is an EXPERIMENTAL API.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryUnaryClientInterceptor(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords intercepting unary-unary invocations.

    This is an EXPERIMENTAL API.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def intercept_unary_unary(self, continuation, client_call_details, request):
        &#34;&#34;&#34;Intercepts a unary-unary invocation asynchronously.

        Args:
          continuation: A function that proceeds with the invocation by
            executing the next interceptor in chain or invoking the
            actual RPC on the underlying Channel. It is the interceptor&#39;s
            responsibility to call it if it decides to move the RPC forward.
            The interceptor can use
            `response_future = continuation(client_call_details, request)`
            to continue with the RPC. `continuation` returns an object that is
            both a Call for the RPC and a Future. In the event of RPC
            completion, the return Call-Future&#39;s result value will be
            the response message of the RPC. Should the event terminate
            with non-OK status, the returned Call-Future&#39;s exception value
            will be an RpcError.
          client_call_details: A ClientCallDetails object describing the
            outgoing RPC.
          request: The request value for the RPC.

        Returns:
            An object that is both a Call for the RPC and a Future.
            In the event of RPC completion, the return Call-Future&#39;s
            result value will be the response message of the RPC.
            Should the event terminate with non-OK status, the returned
            Call-Future&#39;s exception value will be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.UnaryUnaryClientInterceptor.intercept_unary_unary"><code class="name flex">
<span>def <span class="ident">intercept_unary_unary</span></span>(<span>self, continuation, client_call_details, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Intercepts a unary-unary invocation asynchronously.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>continuation</code></strong></dt>
<dd>A function that proceeds with the invocation by
executing the next interceptor in chain or invoking the
actual RPC on the underlying Channel. It is the interceptor's
responsibility to call it if it decides to move the RPC forward.
The interceptor can use
<code>response_future = continuation(client_call_details, request)</code>
to continue with the RPC. <code>continuation</code> returns an object that is
both a Call for the RPC and a Future. In the event of RPC
completion, the return Call-Future's result value will be
the response message of the RPC. Should the event terminate
with non-OK status, the returned Call-Future's exception value
will be an RpcError.</dd>
<dt><strong><code>client_call_details</code></strong></dt>
<dd>A ClientCallDetails object describing the
outgoing RPC.</dd>
<dt><strong><code>request</code></strong></dt>
<dd>The request value for the RPC.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>An object that is both a Call for the RPC and a Future.</dt>
<dt><code>In</code> <code>the</code> <code>event</code> of <code>RPC</code> <code>completion</code>, <code>the</code> <code>return</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>Future's</code></dt>
<dd>&nbsp;</dd>
<dt>result value will be the response message of the RPC.</dt>
<dt><code>Should</code> <code>the</code> <code>event</code> <code>terminate</code> <code>with</code> <code>non</code>-<code>OK</code> <code>status</code>, <code>the</code> <code>returned</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Call-Future's exception value will be an RpcError.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def intercept_unary_unary(self, continuation, client_call_details, request):
    &#34;&#34;&#34;Intercepts a unary-unary invocation asynchronously.

    Args:
      continuation: A function that proceeds with the invocation by
        executing the next interceptor in chain or invoking the
        actual RPC on the underlying Channel. It is the interceptor&#39;s
        responsibility to call it if it decides to move the RPC forward.
        The interceptor can use
        `response_future = continuation(client_call_details, request)`
        to continue with the RPC. `continuation` returns an object that is
        both a Call for the RPC and a Future. In the event of RPC
        completion, the return Call-Future&#39;s result value will be
        the response message of the RPC. Should the event terminate
        with non-OK status, the returned Call-Future&#39;s exception value
        will be an RpcError.
      client_call_details: A ClientCallDetails object describing the
        outgoing RPC.
      request: The request value for the RPC.

    Returns:
        An object that is both a Call for the RPC and a Future.
        In the event of RPC completion, the return Call-Future&#39;s
        result value will be the response message of the RPC.
        Should the event terminate with non-OK status, the returned
        Call-Future&#39;s exception value will be an RpcError.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grpc.UnaryUnaryMultiCallable"><code class="flex name class">
<span>class <span class="ident">UnaryUnaryMultiCallable</span></span>
</code></dt>
<dd>
<section class="desc"><p>Affords invoking a unary-unary RPC from client-side.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):
    &#34;&#34;&#34;Affords invoking a unary-unary RPC from client-side.&#34;&#34;&#34;

    @abc.abstractmethod
    def __call__(self,
                 request,
                 timeout=None,
                 metadata=None,
                 credentials=None,
                 wait_for_ready=None,
                 compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow
            for the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def with_call(self,
                  request,
                  timeout=None,
                  metadata=None,
                  credentials=None,
                  wait_for_ready=None,
                  compression=None):
        &#34;&#34;&#34;Synchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional durating of time in seconds to allow for
            the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
          The response value for the RPC and a Call value for the RPC.

        Raises:
          RpcError: Indicating that the RPC terminated with non-OK status. The
            raised RpcError will also be a Call for the RPC affording the RPC&#39;s
            metadata, status code, and details.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @abc.abstractmethod
    def future(self,
               request,
               timeout=None,
               metadata=None,
               credentials=None,
               wait_for_ready=None,
               compression=None):
        &#34;&#34;&#34;Asynchronously invokes the underlying RPC.

        Args:
          request: The request value for the RPC.
          timeout: An optional duration of time in seconds to allow for
            the RPC.
          metadata: Optional :term:`metadata` to be transmitted to the
            service-side of the RPC.
          credentials: An optional CallCredentials for the RPC. Only valid for
            secure Channel.
          wait_for_ready: This is an EXPERIMENTAL argument. An optional
            flag to enable wait for ready mechanism
          compression: An element of grpc.compression, e.g.
            grpc.compression.Gzip. This is an EXPERIMENTAL option.

        Returns:
            An object that is both a Call for the RPC and a Future.
            In the event of RPC completion, the return Call-Future&#39;s result
            value will be the response message of the RPC.
            Should the event terminate with non-OK status,
            the returned Call-Future&#39;s exception value will be an RpcError.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grpc.UnaryUnaryMultiCallable.future"><code class="name flex">
<span>def <span class="ident">future</span></span>(<span>self, request, timeout=None, metadata=None, credentials=None, wait_for_ready=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Asynchronously invokes the underlying RPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>The request value for the RPC.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>An optional duration of time in seconds to allow for
the RPC.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional :term:<code>metadata</code> to be transmitted to the
service-side of the RPC.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>An optional CallCredentials for the RPC. Only valid for
secure Channel.</dd>
<dt><strong><code>wait_for_ready</code></strong></dt>
<dd>This is an EXPERIMENTAL argument. An optional
flag to enable wait for ready mechanism</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>An object that is both a Call for the RPC and a Future.</dt>
<dt><code>In</code> <code>the</code> <code>event</code> of <code>RPC</code> <code>completion</code>, <code>the</code> <code>return</code> <a title="grpc.Call" href="#grpc.Call"><code>Call</code></a>-<code>Future's</code> <code>result</code></dt>
<dd>&nbsp;</dd>
<dt>value will be the response message of the RPC.</dt>
<dt><code>Should</code> <code>the</code> <code>event</code> <code>terminate</code> <code>with</code> <code>non</code>-<code>OK</code> <code>status</code>,</dt>
<dd>&nbsp;</dd>
</dl>
<p>the returned Call-Future's exception value will be an RpcError.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def future(self,
           request,
           timeout=None,
           metadata=None,
           credentials=None,
           wait_for_ready=None,
           compression=None):
    &#34;&#34;&#34;Asynchronously invokes the underlying RPC.

    Args:
      request: The request value for the RPC.
      timeout: An optional duration of time in seconds to allow for
        the RPC.
      metadata: Optional :term:`metadata` to be transmitted to the
        service-side of the RPC.
      credentials: An optional CallCredentials for the RPC. Only valid for
        secure Channel.
      wait_for_ready: This is an EXPERIMENTAL argument. An optional
        flag to enable wait for ready mechanism
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This is an EXPERIMENTAL option.

    Returns:
        An object that is both a Call for the RPC and a Future.
        In the event of RPC completion, the return Call-Future&#39;s result
        value will be the response message of the RPC.
        Should the event terminate with non-OK status,
        the returned Call-Future&#39;s exception value will be an RpcError.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="grpc.UnaryUnaryMultiCallable.with_call"><code class="name flex">
<span>def <span class="ident">with_call</span></span>(<span>self, request, timeout=None, metadata=None, credentials=None, wait_for_ready=None, compression=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Synchronously invokes the underlying RPC.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong></dt>
<dd>The request value for the RPC.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>An optional durating of time in seconds to allow for
the RPC.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Optional :term:<code>metadata</code> to be transmitted to the
service-side of the RPC.</dd>
<dt><strong><code>credentials</code></strong></dt>
<dd>An optional CallCredentials for the RPC. Only valid for
secure Channel.</dd>
<dt><strong><code>wait_for_ready</code></strong></dt>
<dd>This is an EXPERIMENTAL argument. An optional
flag to enable wait for ready mechanism</dd>
<dt><strong><code>compression</code></strong></dt>
<dd>An element of grpc.compression, e.g.
grpc.compression.Gzip. This is an EXPERIMENTAL option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The response value for the RPC and a Call value for the RPC.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="grpc.RpcError" href="#grpc.RpcError"><code>RpcError</code></a></strong></dt>
<dd>Indicating that the RPC terminated with non-OK status. The
raised RpcError will also be a Call for the RPC affording the RPC's
metadata, status code, and details.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def with_call(self,
              request,
              timeout=None,
              metadata=None,
              credentials=None,
              wait_for_ready=None,
              compression=None):
    &#34;&#34;&#34;Synchronously invokes the underlying RPC.

    Args:
      request: The request value for the RPC.
      timeout: An optional durating of time in seconds to allow for
        the RPC.
      metadata: Optional :term:`metadata` to be transmitted to the
        service-side of the RPC.
      credentials: An optional CallCredentials for the RPC. Only valid for
        secure Channel.
      wait_for_ready: This is an EXPERIMENTAL argument. An optional
        flag to enable wait for ready mechanism
      compression: An element of grpc.compression, e.g.
        grpc.compression.Gzip. This is an EXPERIMENTAL option.

    Returns:
      The response value for the RPC and a Call value for the RPC.

    Raises:
      RpcError: Indicating that the RPC terminated with non-OK status. The
        raised RpcError will also be a Call for the RPC affording the RPC&#39;s
        metadata, status code, and details.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="grpc.beta" href="beta/index.html">grpc.beta</a></code></li>
<li><code><a title="grpc.experimental" href="experimental/index.html">grpc.experimental</a></code></li>
<li><code><a title="grpc.framework" href="framework/index.html">grpc.framework</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="grpc.access_token_call_credentials" href="#grpc.access_token_call_credentials">access_token_call_credentials</a></code></li>
<li><code><a title="grpc.channel_ready_future" href="#grpc.channel_ready_future">channel_ready_future</a></code></li>
<li><code><a title="grpc.composite_call_credentials" href="#grpc.composite_call_credentials">composite_call_credentials</a></code></li>
<li><code><a title="grpc.composite_channel_credentials" href="#grpc.composite_channel_credentials">composite_channel_credentials</a></code></li>
<li><code><a title="grpc.dynamic_ssl_server_credentials" href="#grpc.dynamic_ssl_server_credentials">dynamic_ssl_server_credentials</a></code></li>
<li><code><a title="grpc.insecure_channel" href="#grpc.insecure_channel">insecure_channel</a></code></li>
<li><code><a title="grpc.intercept_channel" href="#grpc.intercept_channel">intercept_channel</a></code></li>
<li><code><a title="grpc.local_channel_credentials" href="#grpc.local_channel_credentials">local_channel_credentials</a></code></li>
<li><code><a title="grpc.local_server_credentials" href="#grpc.local_server_credentials">local_server_credentials</a></code></li>
<li><code><a title="grpc.metadata_call_credentials" href="#grpc.metadata_call_credentials">metadata_call_credentials</a></code></li>
<li><code><a title="grpc.method_handlers_generic_handler" href="#grpc.method_handlers_generic_handler">method_handlers_generic_handler</a></code></li>
<li><code><a title="grpc.secure_channel" href="#grpc.secure_channel">secure_channel</a></code></li>
<li><code><a title="grpc.server" href="#grpc.server">server</a></code></li>
<li><code><a title="grpc.ssl_channel_credentials" href="#grpc.ssl_channel_credentials">ssl_channel_credentials</a></code></li>
<li><code><a title="grpc.ssl_server_certificate_configuration" href="#grpc.ssl_server_certificate_configuration">ssl_server_certificate_configuration</a></code></li>
<li><code><a title="grpc.ssl_server_credentials" href="#grpc.ssl_server_credentials">ssl_server_credentials</a></code></li>
<li><code><a title="grpc.stream_stream_rpc_method_handler" href="#grpc.stream_stream_rpc_method_handler">stream_stream_rpc_method_handler</a></code></li>
<li><code><a title="grpc.stream_unary_rpc_method_handler" href="#grpc.stream_unary_rpc_method_handler">stream_unary_rpc_method_handler</a></code></li>
<li><code><a title="grpc.unary_stream_rpc_method_handler" href="#grpc.unary_stream_rpc_method_handler">unary_stream_rpc_method_handler</a></code></li>
<li><code><a title="grpc.unary_unary_rpc_method_handler" href="#grpc.unary_unary_rpc_method_handler">unary_unary_rpc_method_handler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grpc.AuthMetadataContext" href="#grpc.AuthMetadataContext">AuthMetadataContext</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.AuthMetadataPlugin" href="#grpc.AuthMetadataPlugin">AuthMetadataPlugin</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.AuthMetadataPluginCallback" href="#grpc.AuthMetadataPluginCallback">AuthMetadataPluginCallback</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.Call" href="#grpc.Call">Call</a></code></h4>
<ul class="">
<li><code><a title="grpc.Call.code" href="#grpc.Call.code">code</a></code></li>
<li><code><a title="grpc.Call.details" href="#grpc.Call.details">details</a></code></li>
<li><code><a title="grpc.Call.initial_metadata" href="#grpc.Call.initial_metadata">initial_metadata</a></code></li>
<li><code><a title="grpc.Call.trailing_metadata" href="#grpc.Call.trailing_metadata">trailing_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.CallCredentials" href="#grpc.CallCredentials">CallCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.Channel" href="#grpc.Channel">Channel</a></code></h4>
<ul class="two-column">
<li><code><a title="grpc.Channel.close" href="#grpc.Channel.close">close</a></code></li>
<li><code><a title="grpc.Channel.stream_stream" href="#grpc.Channel.stream_stream">stream_stream</a></code></li>
<li><code><a title="grpc.Channel.stream_unary" href="#grpc.Channel.stream_unary">stream_unary</a></code></li>
<li><code><a title="grpc.Channel.subscribe" href="#grpc.Channel.subscribe">subscribe</a></code></li>
<li><code><a title="grpc.Channel.unary_stream" href="#grpc.Channel.unary_stream">unary_stream</a></code></li>
<li><code><a title="grpc.Channel.unary_unary" href="#grpc.Channel.unary_unary">unary_unary</a></code></li>
<li><code><a title="grpc.Channel.unsubscribe" href="#grpc.Channel.unsubscribe">unsubscribe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.ChannelConnectivity" href="#grpc.ChannelConnectivity">ChannelConnectivity</a></code></h4>
<ul class="">
<li><code><a title="grpc.ChannelConnectivity.CONNECTING" href="#grpc.ChannelConnectivity.CONNECTING">CONNECTING</a></code></li>
<li><code><a title="grpc.ChannelConnectivity.IDLE" href="#grpc.ChannelConnectivity.IDLE">IDLE</a></code></li>
<li><code><a title="grpc.ChannelConnectivity.READY" href="#grpc.ChannelConnectivity.READY">READY</a></code></li>
<li><code><a title="grpc.ChannelConnectivity.SHUTDOWN" href="#grpc.ChannelConnectivity.SHUTDOWN">SHUTDOWN</a></code></li>
<li><code><a title="grpc.ChannelConnectivity.TRANSIENT_FAILURE" href="#grpc.ChannelConnectivity.TRANSIENT_FAILURE">TRANSIENT_FAILURE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.ChannelCredentials" href="#grpc.ChannelCredentials">ChannelCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.ClientCallDetails" href="#grpc.ClientCallDetails">ClientCallDetails</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.Compression" href="#grpc.Compression">Compression</a></code></h4>
<ul class="">
<li><code><a title="grpc.Compression.Deflate" href="#grpc.Compression.Deflate">Deflate</a></code></li>
<li><code><a title="grpc.Compression.Gzip" href="#grpc.Compression.Gzip">Gzip</a></code></li>
<li><code><a title="grpc.Compression.NoCompression" href="#grpc.Compression.NoCompression">NoCompression</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.Future" href="#grpc.Future">Future</a></code></h4>
<ul class="two-column">
<li><code><a title="grpc.Future.add_done_callback" href="#grpc.Future.add_done_callback">add_done_callback</a></code></li>
<li><code><a title="grpc.Future.cancel" href="#grpc.Future.cancel">cancel</a></code></li>
<li><code><a title="grpc.Future.cancelled" href="#grpc.Future.cancelled">cancelled</a></code></li>
<li><code><a title="grpc.Future.done" href="#grpc.Future.done">done</a></code></li>
<li><code><a title="grpc.Future.exception" href="#grpc.Future.exception">exception</a></code></li>
<li><code><a title="grpc.Future.result" href="#grpc.Future.result">result</a></code></li>
<li><code><a title="grpc.Future.running" href="#grpc.Future.running">running</a></code></li>
<li><code><a title="grpc.Future.traceback" href="#grpc.Future.traceback">traceback</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.FutureCancelledError" href="#grpc.FutureCancelledError">FutureCancelledError</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.FutureTimeoutError" href="#grpc.FutureTimeoutError">FutureTimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.GenericRpcHandler" href="#grpc.GenericRpcHandler">GenericRpcHandler</a></code></h4>
<ul class="">
<li><code><a title="grpc.GenericRpcHandler.service" href="#grpc.GenericRpcHandler.service">service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.HandlerCallDetails" href="#grpc.HandlerCallDetails">HandlerCallDetails</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.LocalConnectionType" href="#grpc.LocalConnectionType">LocalConnectionType</a></code></h4>
<ul class="">
<li><code><a title="grpc.LocalConnectionType.LOCAL_TCP" href="#grpc.LocalConnectionType.LOCAL_TCP">LOCAL_TCP</a></code></li>
<li><code><a title="grpc.LocalConnectionType.UDS" href="#grpc.LocalConnectionType.UDS">UDS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.RpcContext" href="#grpc.RpcContext">RpcContext</a></code></h4>
<ul class="">
<li><code><a title="grpc.RpcContext.add_callback" href="#grpc.RpcContext.add_callback">add_callback</a></code></li>
<li><code><a title="grpc.RpcContext.cancel" href="#grpc.RpcContext.cancel">cancel</a></code></li>
<li><code><a title="grpc.RpcContext.is_active" href="#grpc.RpcContext.is_active">is_active</a></code></li>
<li><code><a title="grpc.RpcContext.time_remaining" href="#grpc.RpcContext.time_remaining">time_remaining</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.RpcError" href="#grpc.RpcError">RpcError</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.RpcMethodHandler" href="#grpc.RpcMethodHandler">RpcMethodHandler</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.Server" href="#grpc.Server">Server</a></code></h4>
<ul class="">
<li><code><a title="grpc.Server.add_generic_rpc_handlers" href="#grpc.Server.add_generic_rpc_handlers">add_generic_rpc_handlers</a></code></li>
<li><code><a title="grpc.Server.add_insecure_port" href="#grpc.Server.add_insecure_port">add_insecure_port</a></code></li>
<li><code><a title="grpc.Server.add_secure_port" href="#grpc.Server.add_secure_port">add_secure_port</a></code></li>
<li><code><a title="grpc.Server.start" href="#grpc.Server.start">start</a></code></li>
<li><code><a title="grpc.Server.stop" href="#grpc.Server.stop">stop</a></code></li>
<li><code><a title="grpc.Server.wait_for_termination" href="#grpc.Server.wait_for_termination">wait_for_termination</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.ServerCertificateConfiguration" href="#grpc.ServerCertificateConfiguration">ServerCertificateConfiguration</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.ServerCredentials" href="#grpc.ServerCredentials">ServerCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.ServerInterceptor" href="#grpc.ServerInterceptor">ServerInterceptor</a></code></h4>
<ul class="">
<li><code><a title="grpc.ServerInterceptor.intercept_service" href="#grpc.ServerInterceptor.intercept_service">intercept_service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.ServiceRpcHandler" href="#grpc.ServiceRpcHandler">ServiceRpcHandler</a></code></h4>
<ul class="">
<li><code><a title="grpc.ServiceRpcHandler.service_name" href="#grpc.ServiceRpcHandler.service_name">service_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.ServicerContext" href="#grpc.ServicerContext">ServicerContext</a></code></h4>
<ul class="">
<li><code><a title="grpc.ServicerContext.abort" href="#grpc.ServicerContext.abort">abort</a></code></li>
<li><code><a title="grpc.ServicerContext.abort_with_status" href="#grpc.ServicerContext.abort_with_status">abort_with_status</a></code></li>
<li><code><a title="grpc.ServicerContext.auth_context" href="#grpc.ServicerContext.auth_context">auth_context</a></code></li>
<li><code><a title="grpc.ServicerContext.disable_next_message_compression" href="#grpc.ServicerContext.disable_next_message_compression">disable_next_message_compression</a></code></li>
<li><code><a title="grpc.ServicerContext.invocation_metadata" href="#grpc.ServicerContext.invocation_metadata">invocation_metadata</a></code></li>
<li><code><a title="grpc.ServicerContext.peer" href="#grpc.ServicerContext.peer">peer</a></code></li>
<li><code><a title="grpc.ServicerContext.peer_identities" href="#grpc.ServicerContext.peer_identities">peer_identities</a></code></li>
<li><code><a title="grpc.ServicerContext.peer_identity_key" href="#grpc.ServicerContext.peer_identity_key">peer_identity_key</a></code></li>
<li><code><a title="grpc.ServicerContext.send_initial_metadata" href="#grpc.ServicerContext.send_initial_metadata">send_initial_metadata</a></code></li>
<li><code><a title="grpc.ServicerContext.set_code" href="#grpc.ServicerContext.set_code">set_code</a></code></li>
<li><code><a title="grpc.ServicerContext.set_compression" href="#grpc.ServicerContext.set_compression">set_compression</a></code></li>
<li><code><a title="grpc.ServicerContext.set_details" href="#grpc.ServicerContext.set_details">set_details</a></code></li>
<li><code><a title="grpc.ServicerContext.set_trailing_metadata" href="#grpc.ServicerContext.set_trailing_metadata">set_trailing_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.Status" href="#grpc.Status">Status</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.StatusCode" href="#grpc.StatusCode">StatusCode</a></code></h4>
<ul class="two-column">
<li><code><a title="grpc.StatusCode.ABORTED" href="#grpc.StatusCode.ABORTED">ABORTED</a></code></li>
<li><code><a title="grpc.StatusCode.ALREADY_EXISTS" href="#grpc.StatusCode.ALREADY_EXISTS">ALREADY_EXISTS</a></code></li>
<li><code><a title="grpc.StatusCode.CANCELLED" href="#grpc.StatusCode.CANCELLED">CANCELLED</a></code></li>
<li><code><a title="grpc.StatusCode.DATA_LOSS" href="#grpc.StatusCode.DATA_LOSS">DATA_LOSS</a></code></li>
<li><code><a title="grpc.StatusCode.DEADLINE_EXCEEDED" href="#grpc.StatusCode.DEADLINE_EXCEEDED">DEADLINE_EXCEEDED</a></code></li>
<li><code><a title="grpc.StatusCode.FAILED_PRECONDITION" href="#grpc.StatusCode.FAILED_PRECONDITION">FAILED_PRECONDITION</a></code></li>
<li><code><a title="grpc.StatusCode.INTERNAL" href="#grpc.StatusCode.INTERNAL">INTERNAL</a></code></li>
<li><code><a title="grpc.StatusCode.INVALID_ARGUMENT" href="#grpc.StatusCode.INVALID_ARGUMENT">INVALID_ARGUMENT</a></code></li>
<li><code><a title="grpc.StatusCode.NOT_FOUND" href="#grpc.StatusCode.NOT_FOUND">NOT_FOUND</a></code></li>
<li><code><a title="grpc.StatusCode.OK" href="#grpc.StatusCode.OK">OK</a></code></li>
<li><code><a title="grpc.StatusCode.OUT_OF_RANGE" href="#grpc.StatusCode.OUT_OF_RANGE">OUT_OF_RANGE</a></code></li>
<li><code><a title="grpc.StatusCode.PERMISSION_DENIED" href="#grpc.StatusCode.PERMISSION_DENIED">PERMISSION_DENIED</a></code></li>
<li><code><a title="grpc.StatusCode.RESOURCE_EXHAUSTED" href="#grpc.StatusCode.RESOURCE_EXHAUSTED">RESOURCE_EXHAUSTED</a></code></li>
<li><code><a title="grpc.StatusCode.UNAUTHENTICATED" href="#grpc.StatusCode.UNAUTHENTICATED">UNAUTHENTICATED</a></code></li>
<li><code><a title="grpc.StatusCode.UNAVAILABLE" href="#grpc.StatusCode.UNAVAILABLE">UNAVAILABLE</a></code></li>
<li><code><a title="grpc.StatusCode.UNIMPLEMENTED" href="#grpc.StatusCode.UNIMPLEMENTED">UNIMPLEMENTED</a></code></li>
<li><code><a title="grpc.StatusCode.UNKNOWN" href="#grpc.StatusCode.UNKNOWN">UNKNOWN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.StreamStreamClientInterceptor" href="#grpc.StreamStreamClientInterceptor">StreamStreamClientInterceptor</a></code></h4>
<ul class="">
<li><code><a title="grpc.StreamStreamClientInterceptor.intercept_stream_stream" href="#grpc.StreamStreamClientInterceptor.intercept_stream_stream">intercept_stream_stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.StreamStreamMultiCallable" href="#grpc.StreamStreamMultiCallable">StreamStreamMultiCallable</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.StreamUnaryClientInterceptor" href="#grpc.StreamUnaryClientInterceptor">StreamUnaryClientInterceptor</a></code></h4>
<ul class="">
<li><code><a title="grpc.StreamUnaryClientInterceptor.intercept_stream_unary" href="#grpc.StreamUnaryClientInterceptor.intercept_stream_unary">intercept_stream_unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.StreamUnaryMultiCallable" href="#grpc.StreamUnaryMultiCallable">StreamUnaryMultiCallable</a></code></h4>
<ul class="">
<li><code><a title="grpc.StreamUnaryMultiCallable.future" href="#grpc.StreamUnaryMultiCallable.future">future</a></code></li>
<li><code><a title="grpc.StreamUnaryMultiCallable.with_call" href="#grpc.StreamUnaryMultiCallable.with_call">with_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.UnaryStreamClientInterceptor" href="#grpc.UnaryStreamClientInterceptor">UnaryStreamClientInterceptor</a></code></h4>
<ul class="">
<li><code><a title="grpc.UnaryStreamClientInterceptor.intercept_unary_stream" href="#grpc.UnaryStreamClientInterceptor.intercept_unary_stream">intercept_unary_stream</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.UnaryStreamMultiCallable" href="#grpc.UnaryStreamMultiCallable">UnaryStreamMultiCallable</a></code></h4>
</li>
<li>
<h4><code><a title="grpc.UnaryUnaryClientInterceptor" href="#grpc.UnaryUnaryClientInterceptor">UnaryUnaryClientInterceptor</a></code></h4>
<ul class="">
<li><code><a title="grpc.UnaryUnaryClientInterceptor.intercept_unary_unary" href="#grpc.UnaryUnaryClientInterceptor.intercept_unary_unary">intercept_unary_unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grpc.UnaryUnaryMultiCallable" href="#grpc.UnaryUnaryMultiCallable">UnaryUnaryMultiCallable</a></code></h4>
<ul class="">
<li><code><a title="grpc.UnaryUnaryMultiCallable.future" href="#grpc.UnaryUnaryMultiCallable.future">future</a></code></li>
<li><code><a title="grpc.UnaryUnaryMultiCallable.with_call" href="#grpc.UnaryUnaryMultiCallable.with_call">with_call</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>