<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.auth.credentials API documentation</title>
<meta name="description" content="Interfaces for credentials." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.auth.credentials</code></h1>
</header>
<section id="section-intro">
<p>Interfaces for credentials.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


&#34;&#34;&#34;Interfaces for credentials.&#34;&#34;&#34;

import abc

import six

from google.auth import _helpers


@six.add_metaclass(abc.ABCMeta)
class Credentials(object):
    &#34;&#34;&#34;Base class for all credentials.

    All credentials have a :attr:`token` that is used for authentication and
    may also optionally set an :attr:`expiry` to indicate when the token will
    no longer be valid.

    Most credentials will be :attr:`invalid` until :meth:`refresh` is called.
    Credentials can do this automatically before the first HTTP request in
    :meth:`before_request`.

    Although the token and expiration will change as the credentials are
    :meth:`refreshed &lt;refresh&gt;` and used, credentials should be considered
    immutable. Various credentials will accept configuration such as private
    keys, scopes, and other options. These options are not changeable after
    construction. Some classes will provide mechanisms to copy the credentials
    with modifications such as :meth:`ScopedCredentials.with_scopes`.
    &#34;&#34;&#34;

    def __init__(self):
        self.token = None
        &#34;&#34;&#34;str: The bearer token that can be used in HTTP headers to make
        authenticated requests.&#34;&#34;&#34;
        self.expiry = None
        &#34;&#34;&#34;Optional[datetime]: When the token expires and is no longer valid.
        If this is None, the token is assumed to never expire.&#34;&#34;&#34;

    @property
    def expired(self):
        &#34;&#34;&#34;Checks if the credentials are expired.

        Note that credentials can be invalid but not expired because
        Credentials with :attr:`expiry` set to None is considered to never
        expire.
        &#34;&#34;&#34;
        if not self.expiry:
            return False

        # Remove 5 minutes from expiry to err on the side of reporting
        # expiration early so that we avoid the 401-refresh-retry loop.
        skewed_expiry = self.expiry - _helpers.CLOCK_SKEW
        return _helpers.utcnow() &gt;= skewed_expiry

    @property
    def valid(self):
        &#34;&#34;&#34;Checks the validity of the credentials.

        This is True if the credentials have a :attr:`token` and the token
        is not :attr:`expired`.
        &#34;&#34;&#34;
        return self.token is not None and not self.expired

    @abc.abstractmethod
    def refresh(self, request):
        &#34;&#34;&#34;Refreshes the access token.

        Args:
            request (google.auth.transport.Request): The object used to make
                HTTP requests.

        Raises:
            google.auth.exceptions.RefreshError: If the credentials could
                not be refreshed.
        &#34;&#34;&#34;
        # pylint: disable=missing-raises-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Refresh must be implemented&#34;)

    def apply(self, headers, token=None):
        &#34;&#34;&#34;Apply the token to the authentication header.

        Args:
            headers (Mapping): The HTTP request headers.
            token (Optional[str]): If specified, overrides the current access
                token.
        &#34;&#34;&#34;
        headers[&#34;authorization&#34;] = &#34;Bearer {}&#34;.format(
            _helpers.from_bytes(token or self.token)
        )

    def before_request(self, request, method, url, headers):
        &#34;&#34;&#34;Performs credential-specific before request logic.

        Refreshes the credentials if necessary, then calls :meth:`apply` to
        apply the token to the authentication header.

        Args:
            request (google.auth.transport.Request): The object used to make
                HTTP requests.
            method (str): The request&#39;s HTTP method or the RPC method being
                invoked.
            url (str): The request&#39;s URI or the RPC service&#39;s URI.
            headers (Mapping): The request&#39;s headers.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        # (Subclasses may use these arguments to ascertain information about
        # the http request.)
        if not self.valid:
            self.refresh(request)
        self.apply(headers)


class AnonymousCredentials(Credentials):
    &#34;&#34;&#34;Credentials that do not provide any authentication information.

    These are useful in the case of services that support anonymous access or
    local service emulators that do not use credentials.
    &#34;&#34;&#34;

    @property
    def expired(self):
        &#34;&#34;&#34;Returns `False`, anonymous credentials never expire.&#34;&#34;&#34;
        return False

    @property
    def valid(self):
        &#34;&#34;&#34;Returns `True`, anonymous credentials are always valid.&#34;&#34;&#34;
        return True

    def refresh(self, request):
        &#34;&#34;&#34;Raises :class:`ValueError``, anonymous credentials cannot be
        refreshed.&#34;&#34;&#34;
        raise ValueError(&#34;Anonymous credentials cannot be refreshed.&#34;)

    def apply(self, headers, token=None):
        &#34;&#34;&#34;Anonymous credentials do nothing to the request.

        The optional ``token`` argument is not supported.

        Raises:
            ValueError: If a token was specified.
        &#34;&#34;&#34;
        if token is not None:
            raise ValueError(&#34;Anonymous credentials don&#39;t support tokens.&#34;)

    def before_request(self, request, method, url, headers):
        &#34;&#34;&#34;Anonymous credentials do nothing to the request.&#34;&#34;&#34;


@six.add_metaclass(abc.ABCMeta)
class ReadOnlyScoped(object):
    &#34;&#34;&#34;Interface for credentials whose scopes can be queried.

    OAuth 2.0-based credentials allow limiting access using scopes as described
    in `RFC6749 Section 3.3`_.
    If a credential class implements this interface then the credentials either
    use scopes in their implementation.

    Some credentials require scopes in order to obtain a token. You can check
    if scoping is necessary with :attr:`requires_scopes`::

        if credentials.requires_scopes:
            # Scoping is required.
            credentials = credentials.with_scopes(scopes=[&#39;one&#39;, &#39;two&#39;])

    Credentials that require scopes must either be constructed with scopes::

        credentials = SomeScopedCredentials(scopes=[&#39;one&#39;, &#39;two&#39;])

    Or must copy an existing instance using :meth:`with_scopes`::

        scoped_credentials = credentials.with_scopes(scopes=[&#39;one&#39;, &#39;two&#39;])

    Some credentials have scopes but do not allow or require scopes to be set,
    these credentials can be used as-is.

    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3
    &#34;&#34;&#34;

    def __init__(self):
        super(ReadOnlyScoped, self).__init__()
        self._scopes = None

    @property
    def scopes(self):
        &#34;&#34;&#34;Sequence[str]: the credentials&#39; current set of scopes.&#34;&#34;&#34;
        return self._scopes

    @abc.abstractproperty
    def requires_scopes(self):
        &#34;&#34;&#34;True if these credentials require scopes to obtain an access token.
        &#34;&#34;&#34;
        return False

    def has_scopes(self, scopes):
        &#34;&#34;&#34;Checks if the credentials have the given scopes.

        .. warning: This method is not guaranteed to be accurate if the
            credentials are :attr:`~Credentials.invalid`.

        Args:
            scopes (Sequence[str]): The list of scopes to check.

        Returns:
            bool: True if the credentials have the given scopes.
        &#34;&#34;&#34;
        return set(scopes).issubset(set(self._scopes or []))


class Scoped(ReadOnlyScoped):
    &#34;&#34;&#34;Interface for credentials whose scopes can be replaced while copying.

    OAuth 2.0-based credentials allow limiting access using scopes as described
    in `RFC6749 Section 3.3`_.
    If a credential class implements this interface then the credentials either
    use scopes in their implementation.

    Some credentials require scopes in order to obtain a token. You can check
    if scoping is necessary with :attr:`requires_scopes`::

        if credentials.requires_scopes:
            # Scoping is required.
            credentials = credentials.create_scoped([&#39;one&#39;, &#39;two&#39;])

    Credentials that require scopes must either be constructed with scopes::

        credentials = SomeScopedCredentials(scopes=[&#39;one&#39;, &#39;two&#39;])

    Or must copy an existing instance using :meth:`with_scopes`::

        scoped_credentials = credentials.with_scopes(scopes=[&#39;one&#39;, &#39;two&#39;])

    Some credentials have scopes but do not allow or require scopes to be set,
    these credentials can be used as-is.

    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3
    &#34;&#34;&#34;

    @abc.abstractmethod
    def with_scopes(self, scopes):
        &#34;&#34;&#34;Create a copy of these credentials with the specified scopes.

        Args:
            scopes (Sequence[str]): The list of scopes to attach to the
                current credentials.

        Raises:
            NotImplementedError: If the credentials&#39; scopes can not be changed.
                This can be avoided by checking :attr:`requires_scopes` before
                calling this method.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This class does not require scoping.&#34;)


def with_scopes_if_required(credentials, scopes):
    &#34;&#34;&#34;Creates a copy of the credentials with scopes if scoping is required.

    This helper function is useful when you do not know (or care to know) the
    specific type of credentials you are using (such as when you use
    :func:`google.auth.default`). This function will call
    :meth:`Scoped.with_scopes` if the credentials are scoped credentials and if
    the credentials require scoping. Otherwise, it will return the credentials
    as-is.

    Args:
        credentials (google.auth.credentials.Credentials): The credentials to
            scope if necessary.
        scopes (Sequence[str]): The list of scopes to use.

    Returns:
        google.auth.credentials.Credentials: Either a new set of scoped
            credentials, or the passed in credentials instance if no scoping
            was required.
    &#34;&#34;&#34;
    if isinstance(credentials, Scoped) and credentials.requires_scopes:
        return credentials.with_scopes(scopes)
    else:
        return credentials


@six.add_metaclass(abc.ABCMeta)
class Signing(object):
    &#34;&#34;&#34;Interface for credentials that can cryptographically sign messages.&#34;&#34;&#34;

    @abc.abstractmethod
    def sign_bytes(self, message):
        &#34;&#34;&#34;Signs the given message.

        Args:
            message (bytes): The message to sign.

        Returns:
            bytes: The message&#39;s cryptographic signature.
        &#34;&#34;&#34;
        # pylint: disable=missing-raises-doc,redundant-returns-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Sign bytes must be implemented.&#34;)

    @abc.abstractproperty
    def signer_email(self):
        &#34;&#34;&#34;Optional[str]: An email address that identifies the signer.&#34;&#34;&#34;
        # pylint: disable=missing-raises-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Signer email must be implemented.&#34;)

    @abc.abstractproperty
    def signer(self):
        &#34;&#34;&#34;google.auth.crypt.Signer: The signer used to sign bytes.&#34;&#34;&#34;
        # pylint: disable=missing-raises-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Signer must be implemented.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="google.auth.credentials.with_scopes_if_required"><code class="name flex">
<span>def <span class="ident">with_scopes_if_required</span></span>(<span>credentials, scopes)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a copy of the credentials with scopes if scoping is required.</p>
<p>This helper function is useful when you do not know (or care to know) the
specific type of credentials you are using (such as when you use
:func:<a title="google.auth.default" href="index.html#google.auth.default"><code>default()</code></a>). This function will call
:meth:<a title="google.auth.credentials.Scoped.with_scopes" href="#google.auth.credentials.Scoped.with_scopes"><code>Scoped.with_scopes()</code></a> if the credentials are scoped credentials and if
the credentials require scoping. Otherwise, it will return the credentials
as-is.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>credentials</code></strong> :&ensp;<a title="google.auth.credentials.Credentials" href="#google.auth.credentials.Credentials"><code>Credentials</code></a></dt>
<dd>The credentials to
scope if necessary.</dd>
<dt><strong><code>scopes</code></strong> :&ensp;<code>Sequence</code>[<code>str</code>]</dt>
<dd>The list of scopes to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="google.auth.credentials.Credentials" href="#google.auth.credentials.Credentials"><code>Credentials</code></a>: <code>Either</code> <code>a</code> <code>new</code> <code>set</code> of <code>scoped</code></dt>
<dd>credentials, or the passed in credentials instance if no scoping
was required.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_scopes_if_required(credentials, scopes):
    &#34;&#34;&#34;Creates a copy of the credentials with scopes if scoping is required.

    This helper function is useful when you do not know (or care to know) the
    specific type of credentials you are using (such as when you use
    :func:`google.auth.default`). This function will call
    :meth:`Scoped.with_scopes` if the credentials are scoped credentials and if
    the credentials require scoping. Otherwise, it will return the credentials
    as-is.

    Args:
        credentials (google.auth.credentials.Credentials): The credentials to
            scope if necessary.
        scopes (Sequence[str]): The list of scopes to use.

    Returns:
        google.auth.credentials.Credentials: Either a new set of scoped
            credentials, or the passed in credentials instance if no scoping
            was required.
    &#34;&#34;&#34;
    if isinstance(credentials, Scoped) and credentials.requires_scopes:
        return credentials.with_scopes(scopes)
    else:
        return credentials</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.auth.credentials.AnonymousCredentials"><code class="flex name class">
<span>class <span class="ident">AnonymousCredentials</span></span>
</code></dt>
<dd>
<section class="desc"><p>Credentials that do not provide any authentication information.</p>
<p>These are useful in the case of services that support anonymous access or
local service emulators that do not use credentials.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnonymousCredentials(Credentials):
    &#34;&#34;&#34;Credentials that do not provide any authentication information.

    These are useful in the case of services that support anonymous access or
    local service emulators that do not use credentials.
    &#34;&#34;&#34;

    @property
    def expired(self):
        &#34;&#34;&#34;Returns `False`, anonymous credentials never expire.&#34;&#34;&#34;
        return False

    @property
    def valid(self):
        &#34;&#34;&#34;Returns `True`, anonymous credentials are always valid.&#34;&#34;&#34;
        return True

    def refresh(self, request):
        &#34;&#34;&#34;Raises :class:`ValueError``, anonymous credentials cannot be
        refreshed.&#34;&#34;&#34;
        raise ValueError(&#34;Anonymous credentials cannot be refreshed.&#34;)

    def apply(self, headers, token=None):
        &#34;&#34;&#34;Anonymous credentials do nothing to the request.

        The optional ``token`` argument is not supported.

        Raises:
            ValueError: If a token was specified.
        &#34;&#34;&#34;
        if token is not None:
            raise ValueError(&#34;Anonymous credentials don&#39;t support tokens.&#34;)

    def before_request(self, request, method, url, headers):
        &#34;&#34;&#34;Anonymous credentials do nothing to the request.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.auth.credentials.Credentials" href="#google.auth.credentials.Credentials">Credentials</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="google.auth.credentials.AnonymousCredentials.expired"><code class="name">var <span class="ident">expired</span></code></dt>
<dd>
<section class="desc"><p>Returns <code>False</code>, anonymous credentials never expire.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def expired(self):
    &#34;&#34;&#34;Returns `False`, anonymous credentials never expire.&#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.AnonymousCredentials.valid"><code class="name">var <span class="ident">valid</span></code></dt>
<dd>
<section class="desc"><p>Returns <code>True</code>, anonymous credentials are always valid.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def valid(self):
    &#34;&#34;&#34;Returns `True`, anonymous credentials are always valid.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.auth.credentials.AnonymousCredentials.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, headers, token=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Anonymous credentials do nothing to the request.</p>
<p>The optional <code>token</code> argument is not supported.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>If a token was specified.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, headers, token=None):
    &#34;&#34;&#34;Anonymous credentials do nothing to the request.

    The optional ``token`` argument is not supported.

    Raises:
        ValueError: If a token was specified.
    &#34;&#34;&#34;
    if token is not None:
        raise ValueError(&#34;Anonymous credentials don&#39;t support tokens.&#34;)</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.AnonymousCredentials.before_request"><code class="name flex">
<span>def <span class="ident">before_request</span></span>(<span>self, request, method, url, headers)</span>
</code></dt>
<dd>
<section class="desc"><p>Anonymous credentials do nothing to the request.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_request(self, request, method, url, headers):
    &#34;&#34;&#34;Anonymous credentials do nothing to the request.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.AnonymousCredentials.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Raises :class:`ValueError``, anonymous credentials cannot be
refreshed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, request):
    &#34;&#34;&#34;Raises :class:`ValueError``, anonymous credentials cannot be
    refreshed.&#34;&#34;&#34;
    raise ValueError(&#34;Anonymous credentials cannot be refreshed.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.auth.credentials.Credentials" href="#google.auth.credentials.Credentials">Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Credentials.expiry" href="#google.auth.credentials.Credentials.expiry">expiry</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.token" href="#google.auth.credentials.Credentials.token">token</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.auth.credentials.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for all credentials.</p>
<p>All credentials have a :attr:<code>token</code> that is used for authentication and
may also optionally set an :attr:<code>expiry</code> to indicate when the token will
no longer be valid.</p>
<p>Most credentials will be :attr:<code>invalid</code> until :meth:<code>refresh</code> is called.
Credentials can do this automatically before the first HTTP request in
:meth:<code>before_request</code>.</p>
<p>Although the token and expiration will change as the credentials are
:meth:<code>refreshed &lt;refresh&gt;</code> and used, credentials should be considered
immutable. Various credentials will accept configuration such as private
keys, scopes, and other options. These options are not changeable after
construction. Some classes will provide mechanisms to copy the credentials
with modifications such as :meth:<code>ScopedCredentials.with_scopes</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(object):
    &#34;&#34;&#34;Base class for all credentials.

    All credentials have a :attr:`token` that is used for authentication and
    may also optionally set an :attr:`expiry` to indicate when the token will
    no longer be valid.

    Most credentials will be :attr:`invalid` until :meth:`refresh` is called.
    Credentials can do this automatically before the first HTTP request in
    :meth:`before_request`.

    Although the token and expiration will change as the credentials are
    :meth:`refreshed &lt;refresh&gt;` and used, credentials should be considered
    immutable. Various credentials will accept configuration such as private
    keys, scopes, and other options. These options are not changeable after
    construction. Some classes will provide mechanisms to copy the credentials
    with modifications such as :meth:`ScopedCredentials.with_scopes`.
    &#34;&#34;&#34;

    def __init__(self):
        self.token = None
        &#34;&#34;&#34;str: The bearer token that can be used in HTTP headers to make
        authenticated requests.&#34;&#34;&#34;
        self.expiry = None
        &#34;&#34;&#34;Optional[datetime]: When the token expires and is no longer valid.
        If this is None, the token is assumed to never expire.&#34;&#34;&#34;

    @property
    def expired(self):
        &#34;&#34;&#34;Checks if the credentials are expired.

        Note that credentials can be invalid but not expired because
        Credentials with :attr:`expiry` set to None is considered to never
        expire.
        &#34;&#34;&#34;
        if not self.expiry:
            return False

        # Remove 5 minutes from expiry to err on the side of reporting
        # expiration early so that we avoid the 401-refresh-retry loop.
        skewed_expiry = self.expiry - _helpers.CLOCK_SKEW
        return _helpers.utcnow() &gt;= skewed_expiry

    @property
    def valid(self):
        &#34;&#34;&#34;Checks the validity of the credentials.

        This is True if the credentials have a :attr:`token` and the token
        is not :attr:`expired`.
        &#34;&#34;&#34;
        return self.token is not None and not self.expired

    @abc.abstractmethod
    def refresh(self, request):
        &#34;&#34;&#34;Refreshes the access token.

        Args:
            request (google.auth.transport.Request): The object used to make
                HTTP requests.

        Raises:
            google.auth.exceptions.RefreshError: If the credentials could
                not be refreshed.
        &#34;&#34;&#34;
        # pylint: disable=missing-raises-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Refresh must be implemented&#34;)

    def apply(self, headers, token=None):
        &#34;&#34;&#34;Apply the token to the authentication header.

        Args:
            headers (Mapping): The HTTP request headers.
            token (Optional[str]): If specified, overrides the current access
                token.
        &#34;&#34;&#34;
        headers[&#34;authorization&#34;] = &#34;Bearer {}&#34;.format(
            _helpers.from_bytes(token or self.token)
        )

    def before_request(self, request, method, url, headers):
        &#34;&#34;&#34;Performs credential-specific before request logic.

        Refreshes the credentials if necessary, then calls :meth:`apply` to
        apply the token to the authentication header.

        Args:
            request (google.auth.transport.Request): The object used to make
                HTTP requests.
            method (str): The request&#39;s HTTP method or the RPC method being
                invoked.
            url (str): The request&#39;s URI or the RPC service&#39;s URI.
            headers (Mapping): The request&#39;s headers.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        # (Subclasses may use these arguments to ascertain information about
        # the http request.)
        if not self.valid:
            self.refresh(request)
        self.apply(headers)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.auth.app_engine.Credentials" href="app_engine.html#google.auth.app_engine.Credentials">Credentials</a></li>
<li><a title="google.auth.compute_engine.credentials.Credentials" href="compute_engine/credentials.html#google.auth.compute_engine.credentials.Credentials">Credentials</a></li>
<li><a title="google.auth.compute_engine.credentials.IDTokenCredentials" href="compute_engine/credentials.html#google.auth.compute_engine.credentials.IDTokenCredentials">IDTokenCredentials</a></li>
<li><a title="google.auth.credentials.AnonymousCredentials" href="#google.auth.credentials.AnonymousCredentials">AnonymousCredentials</a></li>
<li><a title="google.auth.impersonated_credentials.Credentials" href="impersonated_credentials.html#google.auth.impersonated_credentials.Credentials">Credentials</a></li>
<li><a title="google.auth.impersonated_credentials.IDTokenCredentials" href="impersonated_credentials.html#google.auth.impersonated_credentials.IDTokenCredentials">IDTokenCredentials</a></li>
<li><a title="google.auth.jwt.Credentials" href="jwt.html#google.auth.jwt.Credentials">Credentials</a></li>
<li><a title="google.auth.jwt.OnDemandCredentials" href="jwt.html#google.auth.jwt.OnDemandCredentials">OnDemandCredentials</a></li>
<li><a title="google.oauth2.credentials.Credentials" href="../oauth2/credentials.html#google.oauth2.credentials.Credentials">Credentials</a></li>
<li><a title="google.oauth2.service_account.Credentials" href="../oauth2/service_account.html#google.oauth2.service_account.Credentials">Credentials</a></li>
<li><a title="google.oauth2.service_account.IDTokenCredentials" href="../oauth2/service_account.html#google.oauth2.service_account.IDTokenCredentials">IDTokenCredentials</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="google.auth.credentials.Credentials.expired"><code class="name">var <span class="ident">expired</span></code></dt>
<dd>
<section class="desc"><p>Checks if the credentials are expired.</p>
<p>Note that credentials can be invalid but not expired because
Credentials with :attr:<code>expiry</code> set to None is considered to never
expire.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def expired(self):
    &#34;&#34;&#34;Checks if the credentials are expired.

    Note that credentials can be invalid but not expired because
    Credentials with :attr:`expiry` set to None is considered to never
    expire.
    &#34;&#34;&#34;
    if not self.expiry:
        return False

    # Remove 5 minutes from expiry to err on the side of reporting
    # expiration early so that we avoid the 401-refresh-retry loop.
    skewed_expiry = self.expiry - _helpers.CLOCK_SKEW
    return _helpers.utcnow() &gt;= skewed_expiry</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.Credentials.expiry"><code class="name">var <span class="ident">expiry</span></code></dt>
<dd>
<section class="desc"><p>Optional[datetime]: When the token expires and is no longer valid.
If this is None, the token is assumed to never expire.</p></section>
</dd>
<dt id="google.auth.credentials.Credentials.token"><code class="name">var <span class="ident">token</span></code></dt>
<dd>
<section class="desc"><p>str: The bearer token that can be used in HTTP headers to make
authenticated requests.</p></section>
</dd>
<dt id="google.auth.credentials.Credentials.valid"><code class="name">var <span class="ident">valid</span></code></dt>
<dd>
<section class="desc"><p>Checks the validity of the credentials.</p>
<p>This is True if the credentials have a :attr:<code>token</code> and the token
is not :attr:<code>expired</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def valid(self):
    &#34;&#34;&#34;Checks the validity of the credentials.

    This is True if the credentials have a :attr:`token` and the token
    is not :attr:`expired`.
    &#34;&#34;&#34;
    return self.token is not None and not self.expired</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.auth.credentials.Credentials.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, headers, token=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Apply the token to the authentication header.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>headers</code></strong> :&ensp;<code>Mapping</code></dt>
<dd>The HTTP request headers.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code>Optional</code>[<code>str</code>]</dt>
<dd>If specified, overrides the current access
token.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, headers, token=None):
    &#34;&#34;&#34;Apply the token to the authentication header.

    Args:
        headers (Mapping): The HTTP request headers.
        token (Optional[str]): If specified, overrides the current access
            token.
    &#34;&#34;&#34;
    headers[&#34;authorization&#34;] = &#34;Bearer {}&#34;.format(
        _helpers.from_bytes(token or self.token)
    )</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.Credentials.before_request"><code class="name flex">
<span>def <span class="ident">before_request</span></span>(<span>self, request, method, url, headers)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs credential-specific before request logic.</p>
<p>Refreshes the credentials if necessary, then calls :meth:<code>apply</code> to
apply the token to the authentication header.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<a title="google.auth.transport.Request" href="transport/index.html#google.auth.transport.Request"><code>Request</code></a></dt>
<dd>The object used to make
HTTP requests.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>The request's HTTP method or the RPC method being
invoked.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The request's URI or the RPC service's URI.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Mapping</code></dt>
<dd>The request's headers.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_request(self, request, method, url, headers):
    &#34;&#34;&#34;Performs credential-specific before request logic.

    Refreshes the credentials if necessary, then calls :meth:`apply` to
    apply the token to the authentication header.

    Args:
        request (google.auth.transport.Request): The object used to make
            HTTP requests.
        method (str): The request&#39;s HTTP method or the RPC method being
            invoked.
        url (str): The request&#39;s URI or the RPC service&#39;s URI.
        headers (Mapping): The request&#39;s headers.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    # (Subclasses may use these arguments to ascertain information about
    # the http request.)
    if not self.valid:
        self.refresh(request)
    self.apply(headers)</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.Credentials.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<section class="desc"><p>Refreshes the access token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<a title="google.auth.transport.Request" href="transport/index.html#google.auth.transport.Request"><code>Request</code></a></dt>
<dd>The object used to make
HTTP requests.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="google.auth.exceptions.RefreshError" href="exceptions.html#google.auth.exceptions.RefreshError"><code>RefreshError</code></a>: <code>If</code> <code>the</code> <code>credentials</code> <code>could</code></dt>
<dd>not be refreshed.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def refresh(self, request):
    &#34;&#34;&#34;Refreshes the access token.

    Args:
        request (google.auth.transport.Request): The object used to make
            HTTP requests.

    Raises:
        google.auth.exceptions.RefreshError: If the credentials could
            not be refreshed.
    &#34;&#34;&#34;
    # pylint: disable=missing-raises-doc
    # (pylint doesn&#39;t recognize that this is abstract)
    raise NotImplementedError(&#34;Refresh must be implemented&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.auth.credentials.ReadOnlyScoped"><code class="flex name class">
<span>class <span class="ident">ReadOnlyScoped</span></span>
</code></dt>
<dd>
<section class="desc"><p>Interface for credentials whose scopes can be queried.</p>
<p>OAuth 2.0-based credentials allow limiting access using scopes as described
in <code>RFC6749 Section 3.3</code>_.
If a credential class implements this interface then the credentials either
use scopes in their implementation.</p>
<p>Some credentials require scopes in order to obtain a token. You can check
if scoping is necessary with :attr:<code>requires_scopes</code>::</p>
<pre><code>if credentials.requires_scopes:
    # Scoping is required.
    credentials = credentials.with_scopes(scopes=['one', 'two'])
</code></pre>
<p>Credentials that require scopes must either be constructed with scopes::</p>
<pre><code>credentials = SomeScopedCredentials(scopes=['one', 'two'])
</code></pre>
<p>Or must copy an existing instance using :meth:<code>with_scopes</code>::</p>
<pre><code>scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])
</code></pre>
<p>Some credentials have scopes but do not allow or require scopes to be set,
these credentials can be used as-is.</p>
<p>.. _RFC6749 Section 3.3: <a href="https://tools.ietf.org/html/rfc6749#section-3.3">https://tools.ietf.org/html/rfc6749#section-3.3</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadOnlyScoped(object):
    &#34;&#34;&#34;Interface for credentials whose scopes can be queried.

    OAuth 2.0-based credentials allow limiting access using scopes as described
    in `RFC6749 Section 3.3`_.
    If a credential class implements this interface then the credentials either
    use scopes in their implementation.

    Some credentials require scopes in order to obtain a token. You can check
    if scoping is necessary with :attr:`requires_scopes`::

        if credentials.requires_scopes:
            # Scoping is required.
            credentials = credentials.with_scopes(scopes=[&#39;one&#39;, &#39;two&#39;])

    Credentials that require scopes must either be constructed with scopes::

        credentials = SomeScopedCredentials(scopes=[&#39;one&#39;, &#39;two&#39;])

    Or must copy an existing instance using :meth:`with_scopes`::

        scoped_credentials = credentials.with_scopes(scopes=[&#39;one&#39;, &#39;two&#39;])

    Some credentials have scopes but do not allow or require scopes to be set,
    these credentials can be used as-is.

    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3
    &#34;&#34;&#34;

    def __init__(self):
        super(ReadOnlyScoped, self).__init__()
        self._scopes = None

    @property
    def scopes(self):
        &#34;&#34;&#34;Sequence[str]: the credentials&#39; current set of scopes.&#34;&#34;&#34;
        return self._scopes

    @abc.abstractproperty
    def requires_scopes(self):
        &#34;&#34;&#34;True if these credentials require scopes to obtain an access token.
        &#34;&#34;&#34;
        return False

    def has_scopes(self, scopes):
        &#34;&#34;&#34;Checks if the credentials have the given scopes.

        .. warning: This method is not guaranteed to be accurate if the
            credentials are :attr:`~Credentials.invalid`.

        Args:
            scopes (Sequence[str]): The list of scopes to check.

        Returns:
            bool: True if the credentials have the given scopes.
        &#34;&#34;&#34;
        return set(scopes).issubset(set(self._scopes or []))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.auth.compute_engine.credentials.Credentials" href="compute_engine/credentials.html#google.auth.compute_engine.credentials.Credentials">Credentials</a></li>
<li><a title="google.auth.credentials.Scoped" href="#google.auth.credentials.Scoped">Scoped</a></li>
<li><a title="google.oauth2.credentials.Credentials" href="../oauth2/credentials.html#google.oauth2.credentials.Credentials">Credentials</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="google.auth.credentials.ReadOnlyScoped.requires_scopes"><code class="name">var <span class="ident">requires_scopes</span></code></dt>
<dd>
<section class="desc"><p>True if these credentials require scopes to obtain an access token.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def requires_scopes(self):
    &#34;&#34;&#34;True if these credentials require scopes to obtain an access token.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.ReadOnlyScoped.scopes"><code class="name">var <span class="ident">scopes</span></code></dt>
<dd>
<section class="desc"><p>Sequence[str]: the credentials' current set of scopes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scopes(self):
    &#34;&#34;&#34;Sequence[str]: the credentials&#39; current set of scopes.&#34;&#34;&#34;
    return self._scopes</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.auth.credentials.ReadOnlyScoped.has_scopes"><code class="name flex">
<span>def <span class="ident">has_scopes</span></span>(<span>self, scopes)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the credentials have the given scopes.</p>
<p>.. warning: This method is not guaranteed to be accurate if the
credentials are :attr:<code>~Credentials.invalid</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scopes</code></strong> :&ensp;<code>Sequence</code>[<code>str</code>]</dt>
<dd>The list of scopes to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if the credentials have the given scopes.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_scopes(self, scopes):
    &#34;&#34;&#34;Checks if the credentials have the given scopes.

    .. warning: This method is not guaranteed to be accurate if the
        credentials are :attr:`~Credentials.invalid`.

    Args:
        scopes (Sequence[str]): The list of scopes to check.

    Returns:
        bool: True if the credentials have the given scopes.
    &#34;&#34;&#34;
    return set(scopes).issubset(set(self._scopes or []))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.auth.credentials.Scoped"><code class="flex name class">
<span>class <span class="ident">Scoped</span></span>
</code></dt>
<dd>
<section class="desc"><p>Interface for credentials whose scopes can be replaced while copying.</p>
<p>OAuth 2.0-based credentials allow limiting access using scopes as described
in <code>RFC6749 Section 3.3</code>_.
If a credential class implements this interface then the credentials either
use scopes in their implementation.</p>
<p>Some credentials require scopes in order to obtain a token. You can check
if scoping is necessary with :attr:<code>requires_scopes</code>::</p>
<pre><code>if credentials.requires_scopes:
    # Scoping is required.
    credentials = credentials.create_scoped(['one', 'two'])
</code></pre>
<p>Credentials that require scopes must either be constructed with scopes::</p>
<pre><code>credentials = SomeScopedCredentials(scopes=['one', 'two'])
</code></pre>
<p>Or must copy an existing instance using :meth:<code>with_scopes</code>::</p>
<pre><code>scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])
</code></pre>
<p>Some credentials have scopes but do not allow or require scopes to be set,
these credentials can be used as-is.</p>
<p>.. _RFC6749 Section 3.3: <a href="https://tools.ietf.org/html/rfc6749#section-3.3">https://tools.ietf.org/html/rfc6749#section-3.3</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scoped(ReadOnlyScoped):
    &#34;&#34;&#34;Interface for credentials whose scopes can be replaced while copying.

    OAuth 2.0-based credentials allow limiting access using scopes as described
    in `RFC6749 Section 3.3`_.
    If a credential class implements this interface then the credentials either
    use scopes in their implementation.

    Some credentials require scopes in order to obtain a token. You can check
    if scoping is necessary with :attr:`requires_scopes`::

        if credentials.requires_scopes:
            # Scoping is required.
            credentials = credentials.create_scoped([&#39;one&#39;, &#39;two&#39;])

    Credentials that require scopes must either be constructed with scopes::

        credentials = SomeScopedCredentials(scopes=[&#39;one&#39;, &#39;two&#39;])

    Or must copy an existing instance using :meth:`with_scopes`::

        scoped_credentials = credentials.with_scopes(scopes=[&#39;one&#39;, &#39;two&#39;])

    Some credentials have scopes but do not allow or require scopes to be set,
    these credentials can be used as-is.

    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3
    &#34;&#34;&#34;

    @abc.abstractmethod
    def with_scopes(self, scopes):
        &#34;&#34;&#34;Create a copy of these credentials with the specified scopes.

        Args:
            scopes (Sequence[str]): The list of scopes to attach to the
                current credentials.

        Raises:
            NotImplementedError: If the credentials&#39; scopes can not be changed.
                This can be avoided by checking :attr:`requires_scopes` before
                calling this method.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This class does not require scoping.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.auth.credentials.ReadOnlyScoped" href="#google.auth.credentials.ReadOnlyScoped">ReadOnlyScoped</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.auth.app_engine.Credentials" href="app_engine.html#google.auth.app_engine.Credentials">Credentials</a></li>
<li><a title="google.oauth2.service_account.Credentials" href="../oauth2/service_account.html#google.oauth2.service_account.Credentials">Credentials</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.auth.credentials.Scoped.with_scopes"><code class="name flex">
<span>def <span class="ident">with_scopes</span></span>(<span>self, scopes)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a copy of these credentials with the specified scopes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scopes</code></strong> :&ensp;<code>Sequence</code>[<code>str</code>]</dt>
<dd>The list of scopes to attach to the
current credentials.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>NotImplementedError</code></strong></dt>
<dd>If the credentials' scopes can not be changed.
This can be avoided by checking :attr:<code>requires_scopes</code> before
calling this method.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def with_scopes(self, scopes):
    &#34;&#34;&#34;Create a copy of these credentials with the specified scopes.

    Args:
        scopes (Sequence[str]): The list of scopes to attach to the
            current credentials.

    Raises:
        NotImplementedError: If the credentials&#39; scopes can not be changed.
            This can be avoided by checking :attr:`requires_scopes` before
            calling this method.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This class does not require scoping.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.auth.credentials.ReadOnlyScoped" href="#google.auth.credentials.ReadOnlyScoped">ReadOnlyScoped</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.ReadOnlyScoped.has_scopes" href="#google.auth.credentials.ReadOnlyScoped.has_scopes">has_scopes</a></code></li>
<li><code><a title="google.auth.credentials.ReadOnlyScoped.requires_scopes" href="#google.auth.credentials.ReadOnlyScoped.requires_scopes">requires_scopes</a></code></li>
<li><code><a title="google.auth.credentials.ReadOnlyScoped.scopes" href="#google.auth.credentials.ReadOnlyScoped.scopes">scopes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.auth.credentials.Signing"><code class="flex name class">
<span>class <span class="ident">Signing</span></span>
</code></dt>
<dd>
<section class="desc"><p>Interface for credentials that can cryptographically sign messages.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signing(object):
    &#34;&#34;&#34;Interface for credentials that can cryptographically sign messages.&#34;&#34;&#34;

    @abc.abstractmethod
    def sign_bytes(self, message):
        &#34;&#34;&#34;Signs the given message.

        Args:
            message (bytes): The message to sign.

        Returns:
            bytes: The message&#39;s cryptographic signature.
        &#34;&#34;&#34;
        # pylint: disable=missing-raises-doc,redundant-returns-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Sign bytes must be implemented.&#34;)

    @abc.abstractproperty
    def signer_email(self):
        &#34;&#34;&#34;Optional[str]: An email address that identifies the signer.&#34;&#34;&#34;
        # pylint: disable=missing-raises-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Signer email must be implemented.&#34;)

    @abc.abstractproperty
    def signer(self):
        &#34;&#34;&#34;google.auth.crypt.Signer: The signer used to sign bytes.&#34;&#34;&#34;
        # pylint: disable=missing-raises-doc
        # (pylint doesn&#39;t recognize that this is abstract)
        raise NotImplementedError(&#34;Signer must be implemented.&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.auth.app_engine.Credentials" href="app_engine.html#google.auth.app_engine.Credentials">Credentials</a></li>
<li><a title="google.auth.compute_engine.credentials.IDTokenCredentials" href="compute_engine/credentials.html#google.auth.compute_engine.credentials.IDTokenCredentials">IDTokenCredentials</a></li>
<li><a title="google.auth.impersonated_credentials.Credentials" href="impersonated_credentials.html#google.auth.impersonated_credentials.Credentials">Credentials</a></li>
<li><a title="google.auth.jwt.Credentials" href="jwt.html#google.auth.jwt.Credentials">Credentials</a></li>
<li><a title="google.auth.jwt.OnDemandCredentials" href="jwt.html#google.auth.jwt.OnDemandCredentials">OnDemandCredentials</a></li>
<li><a title="google.oauth2.service_account.Credentials" href="../oauth2/service_account.html#google.oauth2.service_account.Credentials">Credentials</a></li>
<li><a title="google.oauth2.service_account.IDTokenCredentials" href="../oauth2/service_account.html#google.oauth2.service_account.IDTokenCredentials">IDTokenCredentials</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="google.auth.credentials.Signing.signer"><code class="name">var <span class="ident">signer</span></code></dt>
<dd>
<section class="desc"><p>google.auth.crypt.Signer: The signer used to sign bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def signer(self):
    &#34;&#34;&#34;google.auth.crypt.Signer: The signer used to sign bytes.&#34;&#34;&#34;
    # pylint: disable=missing-raises-doc
    # (pylint doesn&#39;t recognize that this is abstract)
    raise NotImplementedError(&#34;Signer must be implemented.&#34;)</code></pre>
</details>
</dd>
<dt id="google.auth.credentials.Signing.signer_email"><code class="name">var <span class="ident">signer_email</span></code></dt>
<dd>
<section class="desc"><p>Optional[str]: An email address that identifies the signer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractproperty
def signer_email(self):
    &#34;&#34;&#34;Optional[str]: An email address that identifies the signer.&#34;&#34;&#34;
    # pylint: disable=missing-raises-doc
    # (pylint doesn&#39;t recognize that this is abstract)
    raise NotImplementedError(&#34;Signer email must be implemented.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.auth.credentials.Signing.sign_bytes"><code class="name flex">
<span>def <span class="ident">sign_bytes</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<section class="desc"><p>Signs the given message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The message to sign.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong></dt>
<dd>The message's cryptographic signature.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def sign_bytes(self, message):
    &#34;&#34;&#34;Signs the given message.

    Args:
        message (bytes): The message to sign.

    Returns:
        bytes: The message&#39;s cryptographic signature.
    &#34;&#34;&#34;
    # pylint: disable=missing-raises-doc,redundant-returns-doc
    # (pylint doesn&#39;t recognize that this is abstract)
    raise NotImplementedError(&#34;Sign bytes must be implemented.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.auth" href="index.html">google.auth</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="google.auth.credentials.with_scopes_if_required" href="#google.auth.credentials.with_scopes_if_required">with_scopes_if_required</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.auth.credentials.AnonymousCredentials" href="#google.auth.credentials.AnonymousCredentials">AnonymousCredentials</a></code></h4>
<ul class="">
<li><code><a title="google.auth.credentials.AnonymousCredentials.apply" href="#google.auth.credentials.AnonymousCredentials.apply">apply</a></code></li>
<li><code><a title="google.auth.credentials.AnonymousCredentials.before_request" href="#google.auth.credentials.AnonymousCredentials.before_request">before_request</a></code></li>
<li><code><a title="google.auth.credentials.AnonymousCredentials.expired" href="#google.auth.credentials.AnonymousCredentials.expired">expired</a></code></li>
<li><code><a title="google.auth.credentials.AnonymousCredentials.refresh" href="#google.auth.credentials.AnonymousCredentials.refresh">refresh</a></code></li>
<li><code><a title="google.auth.credentials.AnonymousCredentials.valid" href="#google.auth.credentials.AnonymousCredentials.valid">valid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.auth.credentials.Credentials" href="#google.auth.credentials.Credentials">Credentials</a></code></h4>
<ul class="two-column">
<li><code><a title="google.auth.credentials.Credentials.apply" href="#google.auth.credentials.Credentials.apply">apply</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.before_request" href="#google.auth.credentials.Credentials.before_request">before_request</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.expired" href="#google.auth.credentials.Credentials.expired">expired</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.expiry" href="#google.auth.credentials.Credentials.expiry">expiry</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.refresh" href="#google.auth.credentials.Credentials.refresh">refresh</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.token" href="#google.auth.credentials.Credentials.token">token</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.valid" href="#google.auth.credentials.Credentials.valid">valid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.auth.credentials.ReadOnlyScoped" href="#google.auth.credentials.ReadOnlyScoped">ReadOnlyScoped</a></code></h4>
<ul class="">
<li><code><a title="google.auth.credentials.ReadOnlyScoped.has_scopes" href="#google.auth.credentials.ReadOnlyScoped.has_scopes">has_scopes</a></code></li>
<li><code><a title="google.auth.credentials.ReadOnlyScoped.requires_scopes" href="#google.auth.credentials.ReadOnlyScoped.requires_scopes">requires_scopes</a></code></li>
<li><code><a title="google.auth.credentials.ReadOnlyScoped.scopes" href="#google.auth.credentials.ReadOnlyScoped.scopes">scopes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.auth.credentials.Scoped" href="#google.auth.credentials.Scoped">Scoped</a></code></h4>
<ul class="">
<li><code><a title="google.auth.credentials.Scoped.with_scopes" href="#google.auth.credentials.Scoped.with_scopes">with_scopes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.auth.credentials.Signing" href="#google.auth.credentials.Signing">Signing</a></code></h4>
<ul class="">
<li><code><a title="google.auth.credentials.Signing.sign_bytes" href="#google.auth.credentials.Signing.sign_bytes">sign_bytes</a></code></li>
<li><code><a title="google.auth.credentials.Signing.signer" href="#google.auth.credentials.Signing.signer">signer</a></code></li>
<li><code><a title="google.auth.credentials.Signing.signer_email" href="#google.auth.credentials.Signing.signer_email">signer_email</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>