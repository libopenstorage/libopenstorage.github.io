<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.protobuf.service API documentation</title>
<meta name="description" content="DEPRECATED:
Declares the RPC service interfaces â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.protobuf.service</code></h1>
</header>
<section id="section-intro">
<p>DEPRECATED:
Declares the RPC service interfaces.</p>
<p>This module declares the abstract interfaces underlying proto2 RPC
services.
These are intended to be independent of any particular RPC
implementation, so that proto2 services can be used on top of a variety
of implementations.
Starting with version 2.3.0, RPC implementations should
not try to build on these, but should instead provide code generator plugins
which generate code specific to the particular RPC implementation.
This way
the generated code can be more appropriate for the implementation in use
and can avoid unnecessary layers of indirection.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Protocol Buffers - Google&#39;s data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

&#34;&#34;&#34;DEPRECATED:  Declares the RPC service interfaces.

This module declares the abstract interfaces underlying proto2 RPC
services.  These are intended to be independent of any particular RPC
implementation, so that proto2 services can be used on top of a variety
of implementations.  Starting with version 2.3.0, RPC implementations should
not try to build on these, but should instead provide code generator plugins
which generate code specific to the particular RPC implementation.  This way
the generated code can be more appropriate for the implementation in use
and can avoid unnecessary layers of indirection.
&#34;&#34;&#34;

__author__ = &#39;petar@google.com (Petar Petrov)&#39;


class RpcException(Exception):
  &#34;&#34;&#34;Exception raised on failed blocking RPC method call.&#34;&#34;&#34;
  pass


class Service(object):

  &#34;&#34;&#34;Abstract base interface for protocol-buffer-based RPC services.

  Services themselves are abstract classes (implemented either by servers or as
  stubs), but they subclass this base interface. The methods of this
  interface can be used to call the methods of the service without knowing
  its exact type at compile time (analogous to the Message interface).
  &#34;&#34;&#34;

  def GetDescriptor():
    &#34;&#34;&#34;Retrieves this service&#39;s descriptor.&#34;&#34;&#34;
    raise NotImplementedError

  def CallMethod(self, method_descriptor, rpc_controller,
                 request, done):
    &#34;&#34;&#34;Calls a method of the service specified by method_descriptor.

    If &#34;done&#34; is None then the call is blocking and the response
    message will be returned directly.  Otherwise the call is asynchronous
    and &#34;done&#34; will later be called with the response value.

    In the blocking case, RpcException will be raised on error.

    Preconditions:
    * method_descriptor.service == GetDescriptor
    * request is of the exact same classes as returned by
      GetRequestClass(method).
    * After the call has started, the request must not be modified.
    * &#34;rpc_controller&#34; is of the correct type for the RPC implementation being
      used by this Service.  For stubs, the &#34;correct type&#34; depends on the
      RpcChannel which the stub is using.

    Postconditions:
    * &#34;done&#34; will be called when the method is complete.  This may be
      before CallMethod() returns or it may be at some point in the future.
    * If the RPC failed, the response value passed to &#34;done&#34; will be None.
      Further details about the failure can be found by querying the
      RpcController.
    &#34;&#34;&#34;
    raise NotImplementedError

  def GetRequestClass(self, method_descriptor):
    &#34;&#34;&#34;Returns the class of the request message for the specified method.

    CallMethod() requires that the request is of a particular subclass of
    Message. GetRequestClass() gets the default instance of this required
    type.

    Example:
      method = service.GetDescriptor().FindMethodByName(&#34;Foo&#34;)
      request = stub.GetRequestClass(method)()
      request.ParseFromString(input)
      service.CallMethod(method, request, callback)
    &#34;&#34;&#34;
    raise NotImplementedError

  def GetResponseClass(self, method_descriptor):
    &#34;&#34;&#34;Returns the class of the response message for the specified method.

    This method isn&#39;t really needed, as the RpcChannel&#39;s CallMethod constructs
    the response protocol message. It&#39;s provided anyway in case it is useful
    for the caller to know the response type in advance.
    &#34;&#34;&#34;
    raise NotImplementedError


class RpcController(object):

  &#34;&#34;&#34;An RpcController mediates a single method call.

  The primary purpose of the controller is to provide a way to manipulate
  settings specific to the RPC implementation and to find out about RPC-level
  errors. The methods provided by the RpcController interface are intended
  to be a &#34;least common denominator&#34; set of features which we expect all
  implementations to support.  Specific implementations may provide more
  advanced features (e.g. deadline propagation).
  &#34;&#34;&#34;

  # Client-side methods below

  def Reset(self):
    &#34;&#34;&#34;Resets the RpcController to its initial state.

    After the RpcController has been reset, it may be reused in
    a new call. Must not be called while an RPC is in progress.
    &#34;&#34;&#34;
    raise NotImplementedError

  def Failed(self):
    &#34;&#34;&#34;Returns true if the call failed.

    After a call has finished, returns true if the call failed.  The possible
    reasons for failure depend on the RPC implementation.  Failed() must not
    be called before a call has finished.  If Failed() returns true, the
    contents of the response message are undefined.
    &#34;&#34;&#34;
    raise NotImplementedError

  def ErrorText(self):
    &#34;&#34;&#34;If Failed is true, returns a human-readable description of the error.&#34;&#34;&#34;
    raise NotImplementedError

  def StartCancel(self):
    &#34;&#34;&#34;Initiate cancellation.

    Advises the RPC system that the caller desires that the RPC call be
    canceled.  The RPC system may cancel it immediately, may wait awhile and
    then cancel it, or may not even cancel the call at all.  If the call is
    canceled, the &#34;done&#34; callback will still be called and the RpcController
    will indicate that the call failed at that time.
    &#34;&#34;&#34;
    raise NotImplementedError

  # Server-side methods below

  def SetFailed(self, reason):
    &#34;&#34;&#34;Sets a failure reason.

    Causes Failed() to return true on the client side.  &#34;reason&#34; will be
    incorporated into the message returned by ErrorText().  If you find
    you need to return machine-readable information about failures, you
    should incorporate it into your response protocol buffer and should
    NOT call SetFailed().
    &#34;&#34;&#34;
    raise NotImplementedError

  def IsCanceled(self):
    &#34;&#34;&#34;Checks if the client cancelled the RPC.

    If true, indicates that the client canceled the RPC, so the server may
    as well give up on replying to it.  The server should still call the
    final &#34;done&#34; callback.
    &#34;&#34;&#34;
    raise NotImplementedError

  def NotifyOnCancel(self, callback):
    &#34;&#34;&#34;Sets a callback to invoke on cancel.

    Asks that the given callback be called when the RPC is canceled.  The
    callback will always be called exactly once.  If the RPC completes without
    being canceled, the callback will be called after completion.  If the RPC
    has already been canceled when NotifyOnCancel() is called, the callback
    will be called immediately.

    NotifyOnCancel() must be called no more than once per request.
    &#34;&#34;&#34;
    raise NotImplementedError


class RpcChannel(object):

  &#34;&#34;&#34;Abstract interface for an RPC channel.

  An RpcChannel represents a communication line to a service which can be used
  to call that service&#39;s methods.  The service may be running on another
  machine. Normally, you should not use an RpcChannel directly, but instead
  construct a stub {@link Service} wrapping it.  Example:

  Example:
    RpcChannel channel = rpcImpl.Channel(&#34;remotehost.example.com:1234&#34;)
    RpcController controller = rpcImpl.Controller()
    MyService service = MyService_Stub(channel)
    service.MyMethod(controller, request, callback)
  &#34;&#34;&#34;

  def CallMethod(self, method_descriptor, rpc_controller,
                 request, response_class, done):
    &#34;&#34;&#34;Calls the method identified by the descriptor.

    Call the given method of the remote service.  The signature of this
    procedure looks the same as Service.CallMethod(), but the requirements
    are less strict in one important way:  the request object doesn&#39;t have to
    be of any specific class as long as its descriptor is method.input_type.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.protobuf.service.RpcChannel"><code class="flex name class">
<span>class <span class="ident">RpcChannel</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract interface for an RPC channel.</p>
<p>An RpcChannel represents a communication line to a service which can be used
to call that service's methods.
The service may be running on another
machine. Normally, you should not use an RpcChannel directly, but instead
construct a stub {@link Service} wrapping it.
Example:</p>
<h2 id="example">Example</h2>
<p>RpcChannel channel = rpcImpl.Channel("remotehost.example.com:1234")
RpcController controller = rpcImpl.Controller()
MyService service = MyService_Stub(channel)
service.MyMethod(controller, request, callback)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcChannel(object):

  &#34;&#34;&#34;Abstract interface for an RPC channel.

  An RpcChannel represents a communication line to a service which can be used
  to call that service&#39;s methods.  The service may be running on another
  machine. Normally, you should not use an RpcChannel directly, but instead
  construct a stub {@link Service} wrapping it.  Example:

  Example:
    RpcChannel channel = rpcImpl.Channel(&#34;remotehost.example.com:1234&#34;)
    RpcController controller = rpcImpl.Controller()
    MyService service = MyService_Stub(channel)
    service.MyMethod(controller, request, callback)
  &#34;&#34;&#34;

  def CallMethod(self, method_descriptor, rpc_controller,
                 request, response_class, done):
    &#34;&#34;&#34;Calls the method identified by the descriptor.

    Call the given method of the remote service.  The signature of this
    procedure looks the same as Service.CallMethod(), but the requirements
    are less strict in one important way:  the request object doesn&#39;t have to
    be of any specific class as long as its descriptor is method.input_type.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.service.RpcChannel.CallMethod"><code class="name flex">
<span>def <span class="ident">CallMethod</span></span>(<span>self, method_descriptor, rpc_controller, request, response_class, done)</span>
</code></dt>
<dd>
<section class="desc"><p>Calls the method identified by the descriptor.</p>
<p>Call the given method of the remote service.
The signature of this
procedure looks the same as Service.CallMethod(), but the requirements
are less strict in one important way:
the request object doesn't have to
be of any specific class as long as its descriptor is method.input_type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CallMethod(self, method_descriptor, rpc_controller,
               request, response_class, done):
  &#34;&#34;&#34;Calls the method identified by the descriptor.

  Call the given method of the remote service.  The signature of this
  procedure looks the same as Service.CallMethod(), but the requirements
  are less strict in one important way:  the request object doesn&#39;t have to
  be of any specific class as long as its descriptor is method.input_type.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.service.RpcController"><code class="flex name class">
<span>class <span class="ident">RpcController</span></span>
</code></dt>
<dd>
<section class="desc"><p>An RpcController mediates a single method call.</p>
<p>The primary purpose of the controller is to provide a way to manipulate
settings specific to the RPC implementation and to find out about RPC-level
errors. The methods provided by the RpcController interface are intended
to be a "least common denominator" set of features which we expect all
implementations to support.
Specific implementations may provide more
advanced features (e.g. deadline propagation).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcController(object):

  &#34;&#34;&#34;An RpcController mediates a single method call.

  The primary purpose of the controller is to provide a way to manipulate
  settings specific to the RPC implementation and to find out about RPC-level
  errors. The methods provided by the RpcController interface are intended
  to be a &#34;least common denominator&#34; set of features which we expect all
  implementations to support.  Specific implementations may provide more
  advanced features (e.g. deadline propagation).
  &#34;&#34;&#34;

  # Client-side methods below

  def Reset(self):
    &#34;&#34;&#34;Resets the RpcController to its initial state.

    After the RpcController has been reset, it may be reused in
    a new call. Must not be called while an RPC is in progress.
    &#34;&#34;&#34;
    raise NotImplementedError

  def Failed(self):
    &#34;&#34;&#34;Returns true if the call failed.

    After a call has finished, returns true if the call failed.  The possible
    reasons for failure depend on the RPC implementation.  Failed() must not
    be called before a call has finished.  If Failed() returns true, the
    contents of the response message are undefined.
    &#34;&#34;&#34;
    raise NotImplementedError

  def ErrorText(self):
    &#34;&#34;&#34;If Failed is true, returns a human-readable description of the error.&#34;&#34;&#34;
    raise NotImplementedError

  def StartCancel(self):
    &#34;&#34;&#34;Initiate cancellation.

    Advises the RPC system that the caller desires that the RPC call be
    canceled.  The RPC system may cancel it immediately, may wait awhile and
    then cancel it, or may not even cancel the call at all.  If the call is
    canceled, the &#34;done&#34; callback will still be called and the RpcController
    will indicate that the call failed at that time.
    &#34;&#34;&#34;
    raise NotImplementedError

  # Server-side methods below

  def SetFailed(self, reason):
    &#34;&#34;&#34;Sets a failure reason.

    Causes Failed() to return true on the client side.  &#34;reason&#34; will be
    incorporated into the message returned by ErrorText().  If you find
    you need to return machine-readable information about failures, you
    should incorporate it into your response protocol buffer and should
    NOT call SetFailed().
    &#34;&#34;&#34;
    raise NotImplementedError

  def IsCanceled(self):
    &#34;&#34;&#34;Checks if the client cancelled the RPC.

    If true, indicates that the client canceled the RPC, so the server may
    as well give up on replying to it.  The server should still call the
    final &#34;done&#34; callback.
    &#34;&#34;&#34;
    raise NotImplementedError

  def NotifyOnCancel(self, callback):
    &#34;&#34;&#34;Sets a callback to invoke on cancel.

    Asks that the given callback be called when the RPC is canceled.  The
    callback will always be called exactly once.  If the RPC completes without
    being canceled, the callback will be called after completion.  If the RPC
    has already been canceled when NotifyOnCancel() is called, the callback
    will be called immediately.

    NotifyOnCancel() must be called no more than once per request.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.service.RpcController.ErrorText"><code class="name flex">
<span>def <span class="ident">ErrorText</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>If Failed is true, returns a human-readable description of the error.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ErrorText(self):
  &#34;&#34;&#34;If Failed is true, returns a human-readable description of the error.&#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.RpcController.Failed"><code class="name flex">
<span>def <span class="ident">Failed</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns true if the call failed.</p>
<p>After a call has finished, returns true if the call failed.
The possible
reasons for failure depend on the RPC implementation.
Failed() must not
be called before a call has finished.
If Failed() returns true, the
contents of the response message are undefined.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Failed(self):
  &#34;&#34;&#34;Returns true if the call failed.

  After a call has finished, returns true if the call failed.  The possible
  reasons for failure depend on the RPC implementation.  Failed() must not
  be called before a call has finished.  If Failed() returns true, the
  contents of the response message are undefined.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.RpcController.IsCanceled"><code class="name flex">
<span>def <span class="ident">IsCanceled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the client cancelled the RPC.</p>
<p>If true, indicates that the client canceled the RPC, so the server may
as well give up on replying to it.
The server should still call the
final "done" callback.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsCanceled(self):
  &#34;&#34;&#34;Checks if the client cancelled the RPC.

  If true, indicates that the client canceled the RPC, so the server may
  as well give up on replying to it.  The server should still call the
  final &#34;done&#34; callback.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.RpcController.NotifyOnCancel"><code class="name flex">
<span>def <span class="ident">NotifyOnCancel</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets a callback to invoke on cancel.</p>
<p>Asks that the given callback be called when the RPC is canceled.
The
callback will always be called exactly once.
If the RPC completes without
being canceled, the callback will be called after completion.
If the RPC
has already been canceled when NotifyOnCancel() is called, the callback
will be called immediately.</p>
<p>NotifyOnCancel() must be called no more than once per request.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NotifyOnCancel(self, callback):
  &#34;&#34;&#34;Sets a callback to invoke on cancel.

  Asks that the given callback be called when the RPC is canceled.  The
  callback will always be called exactly once.  If the RPC completes without
  being canceled, the callback will be called after completion.  If the RPC
  has already been canceled when NotifyOnCancel() is called, the callback
  will be called immediately.

  NotifyOnCancel() must be called no more than once per request.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.RpcController.Reset"><code class="name flex">
<span>def <span class="ident">Reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Resets the RpcController to its initial state.</p>
<p>After the RpcController has been reset, it may be reused in
a new call. Must not be called while an RPC is in progress.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Reset(self):
  &#34;&#34;&#34;Resets the RpcController to its initial state.

  After the RpcController has been reset, it may be reused in
  a new call. Must not be called while an RPC is in progress.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.RpcController.SetFailed"><code class="name flex">
<span>def <span class="ident">SetFailed</span></span>(<span>self, reason)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets a failure reason.</p>
<p>Causes Failed() to return true on the client side.
"reason" will be
incorporated into the message returned by ErrorText().
If you find
you need to return machine-readable information about failures, you
should incorporate it into your response protocol buffer and should
NOT call SetFailed().</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetFailed(self, reason):
  &#34;&#34;&#34;Sets a failure reason.

  Causes Failed() to return true on the client side.  &#34;reason&#34; will be
  incorporated into the message returned by ErrorText().  If you find
  you need to return machine-readable information about failures, you
  should incorporate it into your response protocol buffer and should
  NOT call SetFailed().
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.RpcController.StartCancel"><code class="name flex">
<span>def <span class="ident">StartCancel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initiate cancellation.</p>
<p>Advises the RPC system that the caller desires that the RPC call be
canceled.
The RPC system may cancel it immediately, may wait awhile and
then cancel it, or may not even cancel the call at all.
If the call is
canceled, the "done" callback will still be called and the RpcController
will indicate that the call failed at that time.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartCancel(self):
  &#34;&#34;&#34;Initiate cancellation.

  Advises the RPC system that the caller desires that the RPC call be
  canceled.  The RPC system may cancel it immediately, may wait awhile and
  then cancel it, or may not even cancel the call at all.  If the call is
  canceled, the &#34;done&#34; callback will still be called and the RpcController
  will indicate that the call failed at that time.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.service.RpcException"><code class="flex name class">
<span>class <span class="ident">RpcException</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Exception raised on failed blocking RPC method call.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcException(Exception):
  &#34;&#34;&#34;Exception raised on failed blocking RPC method call.&#34;&#34;&#34;
  pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="google.protobuf.service.Service"><code class="flex name class">
<span>class <span class="ident">Service</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base interface for protocol-buffer-based RPC services.</p>
<p>Services themselves are abstract classes (implemented either by servers or as
stubs), but they subclass this base interface. The methods of this
interface can be used to call the methods of the service without knowing
its exact type at compile time (analogous to the Message interface).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Service(object):

  &#34;&#34;&#34;Abstract base interface for protocol-buffer-based RPC services.

  Services themselves are abstract classes (implemented either by servers or as
  stubs), but they subclass this base interface. The methods of this
  interface can be used to call the methods of the service without knowing
  its exact type at compile time (analogous to the Message interface).
  &#34;&#34;&#34;

  def GetDescriptor():
    &#34;&#34;&#34;Retrieves this service&#39;s descriptor.&#34;&#34;&#34;
    raise NotImplementedError

  def CallMethod(self, method_descriptor, rpc_controller,
                 request, done):
    &#34;&#34;&#34;Calls a method of the service specified by method_descriptor.

    If &#34;done&#34; is None then the call is blocking and the response
    message will be returned directly.  Otherwise the call is asynchronous
    and &#34;done&#34; will later be called with the response value.

    In the blocking case, RpcException will be raised on error.

    Preconditions:
    * method_descriptor.service == GetDescriptor
    * request is of the exact same classes as returned by
      GetRequestClass(method).
    * After the call has started, the request must not be modified.
    * &#34;rpc_controller&#34; is of the correct type for the RPC implementation being
      used by this Service.  For stubs, the &#34;correct type&#34; depends on the
      RpcChannel which the stub is using.

    Postconditions:
    * &#34;done&#34; will be called when the method is complete.  This may be
      before CallMethod() returns or it may be at some point in the future.
    * If the RPC failed, the response value passed to &#34;done&#34; will be None.
      Further details about the failure can be found by querying the
      RpcController.
    &#34;&#34;&#34;
    raise NotImplementedError

  def GetRequestClass(self, method_descriptor):
    &#34;&#34;&#34;Returns the class of the request message for the specified method.

    CallMethod() requires that the request is of a particular subclass of
    Message. GetRequestClass() gets the default instance of this required
    type.

    Example:
      method = service.GetDescriptor().FindMethodByName(&#34;Foo&#34;)
      request = stub.GetRequestClass(method)()
      request.ParseFromString(input)
      service.CallMethod(method, request, callback)
    &#34;&#34;&#34;
    raise NotImplementedError

  def GetResponseClass(self, method_descriptor):
    &#34;&#34;&#34;Returns the class of the response message for the specified method.

    This method isn&#39;t really needed, as the RpcChannel&#39;s CallMethod constructs
    the response protocol message. It&#39;s provided anyway in case it is useful
    for the caller to know the response type in advance.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.internal.test_bad_identifiers_pb2.AnotherService" href="internal/test_bad_identifiers_pb2.html#google.protobuf.internal.test_bad_identifiers_pb2.AnotherService">AnotherService</a></li>
<li><a title="google.protobuf.unittest_custom_options_pb2.AggregateService" href="unittest_custom_options_pb2.html#google.protobuf.unittest_custom_options_pb2.AggregateService">AggregateService</a></li>
<li><a title="google.protobuf.unittest_custom_options_pb2.TestServiceWithCustomOptions" href="unittest_custom_options_pb2.html#google.protobuf.unittest_custom_options_pb2.TestServiceWithCustomOptions">TestServiceWithCustomOptions</a></li>
<li><a title="google.protobuf.unittest_pb2.TestService" href="unittest_pb2.html#google.protobuf.unittest_pb2.TestService">TestService</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.service.Service.CallMethod"><code class="name flex">
<span>def <span class="ident">CallMethod</span></span>(<span>self, method_descriptor, rpc_controller, request, done)</span>
</code></dt>
<dd>
<section class="desc"><p>Calls a method of the service specified by method_descriptor.</p>
<p>If "done" is None then the call is blocking and the response
message will be returned directly.
Otherwise the call is asynchronous
and "done" will later be called with the response value.</p>
<p>In the blocking case, RpcException will be raised on error.</p>
<p>Preconditions:
* method_descriptor.service == GetDescriptor
* request is of the exact same classes as returned by
GetRequestClass(method).
* After the call has started, the request must not be modified.
* "rpc_controller" is of the correct type for the RPC implementation being
used by this Service.
For stubs, the "correct type" depends on the
RpcChannel which the stub is using.</p>
<p>Postconditions:
* "done" will be called when the method is complete.
This may be
before CallMethod() returns or it may be at some point in the future.
* If the RPC failed, the response value passed to "done" will be None.
Further details about the failure can be found by querying the
RpcController.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CallMethod(self, method_descriptor, rpc_controller,
               request, done):
  &#34;&#34;&#34;Calls a method of the service specified by method_descriptor.

  If &#34;done&#34; is None then the call is blocking and the response
  message will be returned directly.  Otherwise the call is asynchronous
  and &#34;done&#34; will later be called with the response value.

  In the blocking case, RpcException will be raised on error.

  Preconditions:
  * method_descriptor.service == GetDescriptor
  * request is of the exact same classes as returned by
    GetRequestClass(method).
  * After the call has started, the request must not be modified.
  * &#34;rpc_controller&#34; is of the correct type for the RPC implementation being
    used by this Service.  For stubs, the &#34;correct type&#34; depends on the
    RpcChannel which the stub is using.

  Postconditions:
  * &#34;done&#34; will be called when the method is complete.  This may be
    before CallMethod() returns or it may be at some point in the future.
  * If the RPC failed, the response value passed to &#34;done&#34; will be None.
    Further details about the failure can be found by querying the
    RpcController.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.Service.GetDescriptor"><code class="name flex">
<span>def <span class="ident">GetDescriptor</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves this service's descriptor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDescriptor():
  &#34;&#34;&#34;Retrieves this service&#39;s descriptor.&#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.Service.GetRequestClass"><code class="name flex">
<span>def <span class="ident">GetRequestClass</span></span>(<span>self, method_descriptor)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the class of the request message for the specified method.</p>
<p>CallMethod() requires that the request is of a particular subclass of
Message. GetRequestClass() gets the default instance of this required
type.</p>
<h2 id="example">Example</h2>
<p>method = service.GetDescriptor().FindMethodByName("Foo")
request = stub.GetRequestClass(method)()
request.ParseFromString(input)
service.CallMethod(method, request, callback)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetRequestClass(self, method_descriptor):
  &#34;&#34;&#34;Returns the class of the request message for the specified method.

  CallMethod() requires that the request is of a particular subclass of
  Message. GetRequestClass() gets the default instance of this required
  type.

  Example:
    method = service.GetDescriptor().FindMethodByName(&#34;Foo&#34;)
    request = stub.GetRequestClass(method)()
    request.ParseFromString(input)
    service.CallMethod(method, request, callback)
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="google.protobuf.service.Service.GetResponseClass"><code class="name flex">
<span>def <span class="ident">GetResponseClass</span></span>(<span>self, method_descriptor)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the class of the response message for the specified method.</p>
<p>This method isn't really needed, as the RpcChannel's CallMethod constructs
the response protocol message. It's provided anyway in case it is useful
for the caller to know the response type in advance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetResponseClass(self, method_descriptor):
  &#34;&#34;&#34;Returns the class of the response message for the specified method.

  This method isn&#39;t really needed, as the RpcChannel&#39;s CallMethod constructs
  the response protocol message. It&#39;s provided anyway in case it is useful
  for the caller to know the response type in advance.
  &#34;&#34;&#34;
  raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.protobuf" href="index.html">google.protobuf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.protobuf.service.RpcChannel" href="#google.protobuf.service.RpcChannel">RpcChannel</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.service.RpcChannel.CallMethod" href="#google.protobuf.service.RpcChannel.CallMethod">CallMethod</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.service.RpcController" href="#google.protobuf.service.RpcController">RpcController</a></code></h4>
<ul class="two-column">
<li><code><a title="google.protobuf.service.RpcController.ErrorText" href="#google.protobuf.service.RpcController.ErrorText">ErrorText</a></code></li>
<li><code><a title="google.protobuf.service.RpcController.Failed" href="#google.protobuf.service.RpcController.Failed">Failed</a></code></li>
<li><code><a title="google.protobuf.service.RpcController.IsCanceled" href="#google.protobuf.service.RpcController.IsCanceled">IsCanceled</a></code></li>
<li><code><a title="google.protobuf.service.RpcController.NotifyOnCancel" href="#google.protobuf.service.RpcController.NotifyOnCancel">NotifyOnCancel</a></code></li>
<li><code><a title="google.protobuf.service.RpcController.Reset" href="#google.protobuf.service.RpcController.Reset">Reset</a></code></li>
<li><code><a title="google.protobuf.service.RpcController.SetFailed" href="#google.protobuf.service.RpcController.SetFailed">SetFailed</a></code></li>
<li><code><a title="google.protobuf.service.RpcController.StartCancel" href="#google.protobuf.service.RpcController.StartCancel">StartCancel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.service.RpcException" href="#google.protobuf.service.RpcException">RpcException</a></code></h4>
</li>
<li>
<h4><code><a title="google.protobuf.service.Service" href="#google.protobuf.service.Service">Service</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.service.Service.CallMethod" href="#google.protobuf.service.Service.CallMethod">CallMethod</a></code></li>
<li><code><a title="google.protobuf.service.Service.GetDescriptor" href="#google.protobuf.service.Service.GetDescriptor">GetDescriptor</a></code></li>
<li><code><a title="google.protobuf.service.Service.GetRequestClass" href="#google.protobuf.service.Service.GetRequestClass">GetRequestClass</a></code></li>
<li><code><a title="google.protobuf.service.Service.GetResponseClass" href="#google.protobuf.service.Service.GetResponseClass">GetResponseClass</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>