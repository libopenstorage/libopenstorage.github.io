<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.protobuf.descriptor API documentation</title>
<meta name="description" content="Descriptors essentially contain exactly the information found in a .proto
file, in types that make this information accessible in Python." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.protobuf.descriptor</code></h1>
</header>
<section id="section-intro">
<p>Descriptors essentially contain exactly the information found in a .proto
file, in types that make this information accessible in Python.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Protocol Buffers - Google&#39;s data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

&#34;&#34;&#34;Descriptors essentially contain exactly the information found in a .proto
file, in types that make this information accessible in Python.
&#34;&#34;&#34;

__author__ = &#39;robinson@google.com (Will Robinson)&#39;

import threading
import six

from google.protobuf.internal import api_implementation

_USE_C_DESCRIPTORS = False
if api_implementation.Type() == &#39;cpp&#39;:
  # Used by MakeDescriptor in cpp mode
  import binascii
  import os
  from google.protobuf.pyext import _message
  _USE_C_DESCRIPTORS = True


class Error(Exception):
  &#34;&#34;&#34;Base error for this module.&#34;&#34;&#34;


class TypeTransformationError(Error):
  &#34;&#34;&#34;Error transforming between python proto type and corresponding C++ type.&#34;&#34;&#34;


if _USE_C_DESCRIPTORS:
  # This metaclass allows to override the behavior of code like
  #     isinstance(my_descriptor, FieldDescriptor)
  # and make it return True when the descriptor is an instance of the extension
  # type written in C++.
  class DescriptorMetaclass(type):
    def __instancecheck__(cls, obj):
      if super(DescriptorMetaclass, cls).__instancecheck__(obj):
        return True
      if isinstance(obj, cls._C_DESCRIPTOR_CLASS):
        return True
      return False
else:
  # The standard metaclass; nothing changes.
  DescriptorMetaclass = type


class _Lock(object):
  &#34;&#34;&#34;Wrapper class of threading.Lock(), which is allowed by &#39;with&#39;.&#34;&#34;&#34;

  def __new__(cls):
    self = object.__new__(cls)
    self._lock = threading.Lock()  # pylint: disable=protected-access
    return self

  def __enter__(self):
    self._lock.acquire()

  def __exit__(self, exc_type, exc_value, exc_tb):
    self._lock.release()


_lock = threading.Lock()


class DescriptorBase(six.with_metaclass(DescriptorMetaclass)):

  &#34;&#34;&#34;Descriptors base class.

  This class is the base of all descriptor classes. It provides common options
  related functionality.

  Attributes:
    has_options:  True if the descriptor has non-default options.  Usually it
        is not necessary to read this -- just call GetOptions() which will
        happily return the default instance.  However, it&#39;s sometimes useful
        for efficiency, and also useful inside the protobuf implementation to
        avoid some bootstrapping issues.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    # The class, or tuple of classes, that are considered as &#34;virtual
    # subclasses&#34; of this descriptor class.
    _C_DESCRIPTOR_CLASS = ()

  def __init__(self, options, serialized_options, options_class_name):
    &#34;&#34;&#34;Initialize the descriptor given its options message and the name of the
    class of the options message. The name of the class is required in case
    the options message is None and has to be created.
    &#34;&#34;&#34;
    self._options = options
    self._options_class_name = options_class_name
    self._serialized_options = serialized_options

    # Does this descriptor have non-default options?
    self.has_options = (options is not None) or (serialized_options is not None)

  def _SetOptions(self, options, options_class_name):
    &#34;&#34;&#34;Sets the descriptor&#39;s options

    This function is used in generated proto2 files to update descriptor
    options. It must not be used outside proto2.
    &#34;&#34;&#34;
    self._options = options
    self._options_class_name = options_class_name

    # Does this descriptor have non-default options?
    self.has_options = options is not None

  def GetOptions(self):
    &#34;&#34;&#34;Retrieves descriptor options.

    This method returns the options set or creates the default options for the
    descriptor.
    &#34;&#34;&#34;
    if self._options:
      return self._options

    from google.protobuf import descriptor_pb2
    try:
      options_class = getattr(descriptor_pb2,
                              self._options_class_name)
    except AttributeError:
      raise RuntimeError(&#39;Unknown options class name %s!&#39; %
                         (self._options_class_name))

    with _lock:
      if self._serialized_options is None:
        self._options = options_class()
      else:
        self._options = _ParseOptions(options_class(),
                                      self._serialized_options)

      return self._options


class _NestedDescriptorBase(DescriptorBase):
  &#34;&#34;&#34;Common class for descriptors that can be nested.&#34;&#34;&#34;

  def __init__(self, options, options_class_name, name, full_name,
               file, containing_type, serialized_start=None,
               serialized_end=None, serialized_options=None):
    &#34;&#34;&#34;Constructor.

    Args:
      options: Protocol message options or None
        to use default message options.
      options_class_name: (str) The class name of the above options.

      name: (str) Name of this protocol message type.
      full_name: (str) Fully-qualified name of this protocol message type,
        which will include protocol &#34;package&#34; name and the name of any
        enclosing types.
      file: (FileDescriptor) Reference to file info.
      containing_type: if provided, this is a nested descriptor, with this
        descriptor as parent, otherwise None.
      serialized_start: The start index (inclusive) in block in the
        file.serialized_pb that describes this descriptor.
      serialized_end: The end index (exclusive) in block in the
        file.serialized_pb that describes this descriptor.
      serialized_options: Protocol message serilized options or None.
    &#34;&#34;&#34;
    super(_NestedDescriptorBase, self).__init__(
        options, serialized_options, options_class_name)

    self.name = name
    # TODO(falk): Add function to calculate full_name instead of having it in
    #             memory?
    self.full_name = full_name
    self.file = file
    self.containing_type = containing_type

    self._serialized_start = serialized_start
    self._serialized_end = serialized_end

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to the matching proto in descriptor_pb2.

    Args:
      proto: An empty proto instance from descriptor_pb2.

    Raises:
      Error: If self couldnt be serialized, due to to few constructor arguments.
    &#34;&#34;&#34;
    if (self.file is not None and
        self._serialized_start is not None and
        self._serialized_end is not None):
      proto.ParseFromString(self.file.serialized_pb[
          self._serialized_start:self._serialized_end])
    else:
      raise Error(&#39;Descriptor does not contain serialization.&#39;)


class Descriptor(_NestedDescriptorBase):

  &#34;&#34;&#34;Descriptor for a protocol message type.

  A Descriptor instance has the following attributes:

    name: (str) Name of this protocol message type.
    full_name: (str) Fully-qualified name of this protocol message type,
      which will include protocol &#34;package&#34; name and the name of any
      enclosing types.

    containing_type: (Descriptor) Reference to the descriptor of the
      type containing us, or None if this is top-level.

    fields: (list of FieldDescriptors) Field descriptors for all
      fields in this type.
    fields_by_number: (dict int -&gt; FieldDescriptor) Same FieldDescriptor
      objects as in |fields|, but indexed by &#34;number&#34; attribute in each
      FieldDescriptor.
    fields_by_name: (dict str -&gt; FieldDescriptor) Same FieldDescriptor
      objects as in |fields|, but indexed by &#34;name&#34; attribute in each
      FieldDescriptor.
    fields_by_camelcase_name: (dict str -&gt; FieldDescriptor) Same
      FieldDescriptor objects as in |fields|, but indexed by
      &#34;camelcase_name&#34; attribute in each FieldDescriptor.

    nested_types: (list of Descriptors) Descriptor references
      for all protocol message types nested within this one.
    nested_types_by_name: (dict str -&gt; Descriptor) Same Descriptor
      objects as in |nested_types|, but indexed by &#34;name&#34; attribute
      in each Descriptor.

    enum_types: (list of EnumDescriptors) EnumDescriptor references
      for all enums contained within this type.
    enum_types_by_name: (dict str -&gt;EnumDescriptor) Same EnumDescriptor
      objects as in |enum_types|, but indexed by &#34;name&#34; attribute
      in each EnumDescriptor.
    enum_values_by_name: (dict str -&gt; EnumValueDescriptor) Dict mapping
      from enum value name to EnumValueDescriptor for that value.

    extensions: (list of FieldDescriptor) All extensions defined directly
      within this message type (NOT within a nested type).
    extensions_by_name: (dict, string -&gt; FieldDescriptor) Same FieldDescriptor
      objects as |extensions|, but indexed by &#34;name&#34; attribute of each
      FieldDescriptor.

    is_extendable:  Does this type define any extension ranges?

    oneofs: (list of OneofDescriptor) The list of descriptors for oneof fields
      in this message.
    oneofs_by_name: (dict str -&gt; OneofDescriptor) Same objects as in |oneofs|,
      but indexed by &#34;name&#34; attribute.

    file: (FileDescriptor) Reference to file descriptor.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.Descriptor

    def __new__(cls, name, full_name, filename, containing_type, fields,
                nested_types, enum_types, extensions, options=None,
                serialized_options=None,
                is_extendable=True, extension_ranges=None, oneofs=None,
                file=None, serialized_start=None, serialized_end=None,  # pylint: disable=redefined-builtin
                syntax=None):
      _message.Message._CheckCalledFromGeneratedFile()
      return _message.default_pool.FindMessageTypeByName(full_name)

  # NOTE(tmarek): The file argument redefining a builtin is nothing we can
  # fix right now since we don&#39;t know how many clients already rely on the
  # name of the argument.
  def __init__(self, name, full_name, filename, containing_type, fields,
               nested_types, enum_types, extensions, options=None,
               serialized_options=None,
               is_extendable=True, extension_ranges=None, oneofs=None,
               file=None, serialized_start=None, serialized_end=None,  # pylint: disable=redefined-builtin
               syntax=None):
    &#34;&#34;&#34;Arguments to __init__() are as described in the description
    of Descriptor fields above.

    Note that filename is an obsolete argument, that is not used anymore.
    Please use file.name to access this as an attribute.
    &#34;&#34;&#34;
    super(Descriptor, self).__init__(
        options, &#39;MessageOptions&#39;, name, full_name, file,
        containing_type, serialized_start=serialized_start,
        serialized_end=serialized_end, serialized_options=serialized_options)

    # We have fields in addition to fields_by_name and fields_by_number,
    # so that:
    #   1. Clients can index fields by &#34;order in which they&#39;re listed.&#34;
    #   2. Clients can easily iterate over all fields with the terse
    #      syntax: for f in descriptor.fields: ...
    self.fields = fields
    for field in self.fields:
      field.containing_type = self
    self.fields_by_number = dict((f.number, f) for f in fields)
    self.fields_by_name = dict((f.name, f) for f in fields)
    self._fields_by_camelcase_name = None

    self.nested_types = nested_types
    for nested_type in nested_types:
      nested_type.containing_type = self
    self.nested_types_by_name = dict((t.name, t) for t in nested_types)

    self.enum_types = enum_types
    for enum_type in self.enum_types:
      enum_type.containing_type = self
    self.enum_types_by_name = dict((t.name, t) for t in enum_types)
    self.enum_values_by_name = dict(
        (v.name, v) for t in enum_types for v in t.values)

    self.extensions = extensions
    for extension in self.extensions:
      extension.extension_scope = self
    self.extensions_by_name = dict((f.name, f) for f in extensions)
    self.is_extendable = is_extendable
    self.extension_ranges = extension_ranges
    self.oneofs = oneofs if oneofs is not None else []
    self.oneofs_by_name = dict((o.name, o) for o in self.oneofs)
    for oneof in self.oneofs:
      oneof.containing_type = self
    self.syntax = syntax or &#34;proto2&#34;

  @property
  def fields_by_camelcase_name(self):
    if self._fields_by_camelcase_name is None:
      self._fields_by_camelcase_name = dict(
          (f.camelcase_name, f) for f in self.fields)
    return self._fields_by_camelcase_name

  def EnumValueName(self, enum, value):
    &#34;&#34;&#34;Returns the string name of an enum value.

    This is just a small helper method to simplify a common operation.

    Args:
      enum: string name of the Enum.
      value: int, value of the enum.

    Returns:
      string name of the enum value.

    Raises:
      KeyError if either the Enum doesn&#39;t exist or the value is not a valid
        value for the enum.
    &#34;&#34;&#34;
    return self.enum_types_by_name[enum].values_by_number[value].name

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.DescriptorProto.

    Args:
      proto: An empty descriptor_pb2.DescriptorProto.
    &#34;&#34;&#34;
    # This function is overridden to give a better doc comment.
    super(Descriptor, self).CopyToProto(proto)


# TODO(robinson): We should have aggressive checking here,
# for example:
#   * If you specify a repeated field, you should not be allowed
#     to specify a default value.
#   * [Other examples here as needed].
#
# TODO(robinson): for this and other *Descriptor classes, we
# might also want to lock things down aggressively (e.g.,
# prevent clients from setting the attributes).  Having
# stronger invariants here in general will reduce the number
# of runtime checks we must do in reflection.py...
class FieldDescriptor(DescriptorBase):

  &#34;&#34;&#34;Descriptor for a single field in a .proto file.

  A FieldDescriptor instance has the following attributes:

    name: (str) Name of this field, exactly as it appears in .proto.
    full_name: (str) Name of this field, including containing scope.  This is
      particularly relevant for extensions.
    camelcase_name: (str) Camelcase name of this field.
    index: (int) Dense, 0-indexed index giving the order that this
      field textually appears within its message in the .proto file.
    number: (int) Tag number declared for this field in the .proto file.

    type: (One of the TYPE_* constants below) Declared type.
    cpp_type: (One of the CPPTYPE_* constants below) C++ type used to
      represent this field.

    label: (One of the LABEL_* constants below) Tells whether this
      field is optional, required, or repeated.
    has_default_value: (bool) True if this field has a default value defined,
      otherwise false.
    default_value: (Varies) Default value of this field.  Only
      meaningful for non-repeated scalar fields.  Repeated fields
      should always set this to [], and non-repeated composite
      fields should always set this to None.

    containing_type: (Descriptor) Descriptor of the protocol message
      type that contains this field.  Set by the Descriptor constructor
      if we&#39;re passed into one.
      Somewhat confusingly, for extension fields, this is the
      descriptor of the EXTENDED message, not the descriptor
      of the message containing this field.  (See is_extension and
      extension_scope below).
    message_type: (Descriptor) If a composite field, a descriptor
      of the message type contained in this field.  Otherwise, this is None.
    enum_type: (EnumDescriptor) If this field contains an enum, a
      descriptor of that enum.  Otherwise, this is None.

    is_extension: True iff this describes an extension field.
    extension_scope: (Descriptor) Only meaningful if is_extension is True.
      Gives the message that immediately contains this extension field.
      Will be None iff we&#39;re a top-level (file-level) extension field.

    options: (descriptor_pb2.FieldOptions) Protocol message field options or
      None to use default field options.

    containing_oneof: (OneofDescriptor) If the field is a member of a oneof
      union, contains its descriptor. Otherwise, None.

    file: (FileDescriptor) Reference to file descriptor.
  &#34;&#34;&#34;

  # Must be consistent with C++ FieldDescriptor::Type enum in
  # descriptor.h.
  #
  # TODO(robinson): Find a way to eliminate this repetition.
  TYPE_DOUBLE         = 1
  TYPE_FLOAT          = 2
  TYPE_INT64          = 3
  TYPE_UINT64         = 4
  TYPE_INT32          = 5
  TYPE_FIXED64        = 6
  TYPE_FIXED32        = 7
  TYPE_BOOL           = 8
  TYPE_STRING         = 9
  TYPE_GROUP          = 10
  TYPE_MESSAGE        = 11
  TYPE_BYTES          = 12
  TYPE_UINT32         = 13
  TYPE_ENUM           = 14
  TYPE_SFIXED32       = 15
  TYPE_SFIXED64       = 16
  TYPE_SINT32         = 17
  TYPE_SINT64         = 18
  MAX_TYPE            = 18

  # Must be consistent with C++ FieldDescriptor::CppType enum in
  # descriptor.h.
  #
  # TODO(robinson): Find a way to eliminate this repetition.
  CPPTYPE_INT32       = 1
  CPPTYPE_INT64       = 2
  CPPTYPE_UINT32      = 3
  CPPTYPE_UINT64      = 4
  CPPTYPE_DOUBLE      = 5
  CPPTYPE_FLOAT       = 6
  CPPTYPE_BOOL        = 7
  CPPTYPE_ENUM        = 8
  CPPTYPE_STRING      = 9
  CPPTYPE_MESSAGE     = 10
  MAX_CPPTYPE         = 10

  _PYTHON_TO_CPP_PROTO_TYPE_MAP = {
      TYPE_DOUBLE: CPPTYPE_DOUBLE,
      TYPE_FLOAT: CPPTYPE_FLOAT,
      TYPE_ENUM: CPPTYPE_ENUM,
      TYPE_INT64: CPPTYPE_INT64,
      TYPE_SINT64: CPPTYPE_INT64,
      TYPE_SFIXED64: CPPTYPE_INT64,
      TYPE_UINT64: CPPTYPE_UINT64,
      TYPE_FIXED64: CPPTYPE_UINT64,
      TYPE_INT32: CPPTYPE_INT32,
      TYPE_SFIXED32: CPPTYPE_INT32,
      TYPE_SINT32: CPPTYPE_INT32,
      TYPE_UINT32: CPPTYPE_UINT32,
      TYPE_FIXED32: CPPTYPE_UINT32,
      TYPE_BYTES: CPPTYPE_STRING,
      TYPE_STRING: CPPTYPE_STRING,
      TYPE_BOOL: CPPTYPE_BOOL,
      TYPE_MESSAGE: CPPTYPE_MESSAGE,
      TYPE_GROUP: CPPTYPE_MESSAGE
      }

  # Must be consistent with C++ FieldDescriptor::Label enum in
  # descriptor.h.
  #
  # TODO(robinson): Find a way to eliminate this repetition.
  LABEL_OPTIONAL      = 1
  LABEL_REQUIRED      = 2
  LABEL_REPEATED      = 3
  MAX_LABEL           = 3

  # Must be consistent with C++ constants kMaxNumber, kFirstReservedNumber,
  # and kLastReservedNumber in descriptor.h
  MAX_FIELD_NUMBER = (1 &lt;&lt; 29) - 1
  FIRST_RESERVED_FIELD_NUMBER = 19000
  LAST_RESERVED_FIELD_NUMBER = 19999

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.FieldDescriptor

    def __new__(cls, name, full_name, index, number, type, cpp_type, label,
                default_value, message_type, enum_type, containing_type,
                is_extension, extension_scope, options=None,
                serialized_options=None,
                has_default_value=True, containing_oneof=None, json_name=None,
                file=None):  # pylint: disable=redefined-builtin
      _message.Message._CheckCalledFromGeneratedFile()
      if is_extension:
        return _message.default_pool.FindExtensionByName(full_name)
      else:
        return _message.default_pool.FindFieldByName(full_name)

  def __init__(self, name, full_name, index, number, type, cpp_type, label,
               default_value, message_type, enum_type, containing_type,
               is_extension, extension_scope, options=None,
               serialized_options=None,
               has_default_value=True, containing_oneof=None, json_name=None,
               file=None):  # pylint: disable=redefined-builtin
    &#34;&#34;&#34;The arguments are as described in the description of FieldDescriptor
    attributes above.

    Note that containing_type may be None, and may be set later if necessary
    (to deal with circular references between message types, for example).
    Likewise for extension_scope.
    &#34;&#34;&#34;
    super(FieldDescriptor, self).__init__(
        options, serialized_options, &#39;FieldOptions&#39;)
    self.name = name
    self.full_name = full_name
    self.file = file
    self._camelcase_name = None
    if json_name is None:
      self.json_name = _ToJsonName(name)
    else:
      self.json_name = json_name
    self.index = index
    self.number = number
    self.type = type
    self.cpp_type = cpp_type
    self.label = label
    self.has_default_value = has_default_value
    self.default_value = default_value
    self.containing_type = containing_type
    self.message_type = message_type
    self.enum_type = enum_type
    self.is_extension = is_extension
    self.extension_scope = extension_scope
    self.containing_oneof = containing_oneof
    if api_implementation.Type() == &#39;cpp&#39;:
      if is_extension:
        self._cdescriptor = _message.default_pool.FindExtensionByName(full_name)
      else:
        self._cdescriptor = _message.default_pool.FindFieldByName(full_name)
    else:
      self._cdescriptor = None

  @property
  def camelcase_name(self):
    if self._camelcase_name is None:
      self._camelcase_name = _ToCamelCase(self.name)
    return self._camelcase_name

  @staticmethod
  def ProtoTypeToCppProtoType(proto_type):
    &#34;&#34;&#34;Converts from a Python proto type to a C++ Proto Type.

    The Python ProtocolBuffer classes specify both the &#39;Python&#39; datatype and the
    &#39;C++&#39; datatype - and they&#39;re not the same. This helper method should
    translate from one to another.

    Args:
      proto_type: the Python proto type (descriptor.FieldDescriptor.TYPE_*)
    Returns:
      descriptor.FieldDescriptor.CPPTYPE_*, the C++ type.
    Raises:
      TypeTransformationError: when the Python proto type isn&#39;t known.
    &#34;&#34;&#34;
    try:
      return FieldDescriptor._PYTHON_TO_CPP_PROTO_TYPE_MAP[proto_type]
    except KeyError:
      raise TypeTransformationError(&#39;Unknown proto_type: %s&#39; % proto_type)


class EnumDescriptor(_NestedDescriptorBase):

  &#34;&#34;&#34;Descriptor for an enum defined in a .proto file.

  An EnumDescriptor instance has the following attributes:

    name: (str) Name of the enum type.
    full_name: (str) Full name of the type, including package name
      and any enclosing type(s).

    values: (list of EnumValueDescriptors) List of the values
      in this enum.
    values_by_name: (dict str -&gt; EnumValueDescriptor) Same as |values|,
      but indexed by the &#34;name&#34; field of each EnumValueDescriptor.
    values_by_number: (dict int -&gt; EnumValueDescriptor) Same as |values|,
      but indexed by the &#34;number&#34; field of each EnumValueDescriptor.
    containing_type: (Descriptor) Descriptor of the immediate containing
      type of this enum, or None if this is an enum defined at the
      top level in a .proto file.  Set by Descriptor&#39;s constructor
      if we&#39;re passed into one.
    file: (FileDescriptor) Reference to file descriptor.
    options: (descriptor_pb2.EnumOptions) Enum options message or
      None to use default enum options.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.EnumDescriptor

    def __new__(cls, name, full_name, filename, values,
                containing_type=None, options=None,
                serialized_options=None, file=None,  # pylint: disable=redefined-builtin
                serialized_start=None, serialized_end=None):
      _message.Message._CheckCalledFromGeneratedFile()
      return _message.default_pool.FindEnumTypeByName(full_name)

  def __init__(self, name, full_name, filename, values,
               containing_type=None, options=None,
               serialized_options=None, file=None,  # pylint: disable=redefined-builtin
               serialized_start=None, serialized_end=None):
    &#34;&#34;&#34;Arguments are as described in the attribute description above.

    Note that filename is an obsolete argument, that is not used anymore.
    Please use file.name to access this as an attribute.
    &#34;&#34;&#34;
    super(EnumDescriptor, self).__init__(
        options, &#39;EnumOptions&#39;, name, full_name, file,
        containing_type, serialized_start=serialized_start,
        serialized_end=serialized_end, serialized_options=serialized_options)

    self.values = values
    for value in self.values:
      value.type = self
    self.values_by_name = dict((v.name, v) for v in values)
    # Values are reversed to ensure that the first alias is retained.
    self.values_by_number = dict((v.number, v) for v in reversed(values))

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.EnumDescriptorProto.

    Args:
      proto: An empty descriptor_pb2.EnumDescriptorProto.
    &#34;&#34;&#34;
    # This function is overridden to give a better doc comment.
    super(EnumDescriptor, self).CopyToProto(proto)


class EnumValueDescriptor(DescriptorBase):

  &#34;&#34;&#34;Descriptor for a single value within an enum.

    name: (str) Name of this value.
    index: (int) Dense, 0-indexed index giving the order that this
      value appears textually within its enum in the .proto file.
    number: (int) Actual number assigned to this enum value.
    type: (EnumDescriptor) EnumDescriptor to which this value
      belongs.  Set by EnumDescriptor&#39;s constructor if we&#39;re
      passed into one.
    options: (descriptor_pb2.EnumValueOptions) Enum value options message or
      None to use default enum value options options.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.EnumValueDescriptor

    def __new__(cls, name, index, number,
                type=None,  # pylint: disable=redefined-builtin
                options=None, serialized_options=None):
      _message.Message._CheckCalledFromGeneratedFile()
      # There is no way we can build a complete EnumValueDescriptor with the
      # given parameters (the name of the Enum is not known, for example).
      # Fortunately generated files just pass it to the EnumDescriptor()
      # constructor, which will ignore it, so returning None is good enough.
      return None

  def __init__(self, name, index, number,
               type=None,  # pylint: disable=redefined-builtin
               options=None, serialized_options=None):
    &#34;&#34;&#34;Arguments are as described in the attribute description above.&#34;&#34;&#34;
    super(EnumValueDescriptor, self).__init__(
        options, serialized_options, &#39;EnumValueOptions&#39;)
    self.name = name
    self.index = index
    self.number = number
    self.type = type


class OneofDescriptor(DescriptorBase):
  &#34;&#34;&#34;Descriptor for a oneof field.

    name: (str) Name of the oneof field.
    full_name: (str) Full name of the oneof field, including package name.
    index: (int) 0-based index giving the order of the oneof field inside
      its containing type.
    containing_type: (Descriptor) Descriptor of the protocol message
      type that contains this field.  Set by the Descriptor constructor
      if we&#39;re passed into one.
    fields: (list of FieldDescriptor) The list of field descriptors this
      oneof can contain.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.OneofDescriptor

    def __new__(
        cls, name, full_name, index, containing_type, fields, options=None,
        serialized_options=None):
      _message.Message._CheckCalledFromGeneratedFile()
      return _message.default_pool.FindOneofByName(full_name)

  def __init__(
      self, name, full_name, index, containing_type, fields, options=None,
      serialized_options=None):
    &#34;&#34;&#34;Arguments are as described in the attribute description above.&#34;&#34;&#34;
    super(OneofDescriptor, self).__init__(
        options, serialized_options, &#39;OneofOptions&#39;)
    self.name = name
    self.full_name = full_name
    self.index = index
    self.containing_type = containing_type
    self.fields = fields


class ServiceDescriptor(_NestedDescriptorBase):

  &#34;&#34;&#34;Descriptor for a service.

    name: (str) Name of the service.
    full_name: (str) Full name of the service, including package name.
    index: (int) 0-indexed index giving the order that this services
      definition appears withing the .proto file.
    methods: (list of MethodDescriptor) List of methods provided by this
      service.
    methods_by_name: (dict str -&gt; MethodDescriptor) Same MethodDescriptor
      objects as in |methods_by_name|, but indexed by &#34;name&#34; attribute in each
      MethodDescriptor.
    options: (descriptor_pb2.ServiceOptions) Service options message or
      None to use default service options.
    file: (FileDescriptor) Reference to file info.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.ServiceDescriptor

    def __new__(cls, name, full_name, index, methods, options=None,
                serialized_options=None, file=None,  # pylint: disable=redefined-builtin
                serialized_start=None, serialized_end=None):
      _message.Message._CheckCalledFromGeneratedFile()  # pylint: disable=protected-access
      return _message.default_pool.FindServiceByName(full_name)

  def __init__(self, name, full_name, index, methods, options=None,
               serialized_options=None, file=None,  # pylint: disable=redefined-builtin
               serialized_start=None, serialized_end=None):
    super(ServiceDescriptor, self).__init__(
        options, &#39;ServiceOptions&#39;, name, full_name, file,
        None, serialized_start=serialized_start,
        serialized_end=serialized_end, serialized_options=serialized_options)
    self.index = index
    self.methods = methods
    self.methods_by_name = dict((m.name, m) for m in methods)
    # Set the containing service for each method in this service.
    for method in self.methods:
      method.containing_service = self

  def FindMethodByName(self, name):
    &#34;&#34;&#34;Searches for the specified method, and returns its descriptor.&#34;&#34;&#34;
    return self.methods_by_name.get(name, None)

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.ServiceDescriptorProto.

    Args:
      proto: An empty descriptor_pb2.ServiceDescriptorProto.
    &#34;&#34;&#34;
    # This function is overridden to give a better doc comment.
    super(ServiceDescriptor, self).CopyToProto(proto)


class MethodDescriptor(DescriptorBase):

  &#34;&#34;&#34;Descriptor for a method in a service.

  name: (str) Name of the method within the service.
  full_name: (str) Full name of method.
  index: (int) 0-indexed index of the method inside the service.
  containing_service: (ServiceDescriptor) The service that contains this
    method.
  input_type: The descriptor of the message that this method accepts.
  output_type: The descriptor of the message that this method returns.
  options: (descriptor_pb2.MethodOptions) Method options message or
    None to use default method options.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.MethodDescriptor

    def __new__(cls, name, full_name, index, containing_service,
                input_type, output_type, options=None, serialized_options=None):
      _message.Message._CheckCalledFromGeneratedFile()  # pylint: disable=protected-access
      return _message.default_pool.FindMethodByName(full_name)

  def __init__(self, name, full_name, index, containing_service,
               input_type, output_type, options=None, serialized_options=None):
    &#34;&#34;&#34;The arguments are as described in the description of MethodDescriptor
    attributes above.

    Note that containing_service may be None, and may be set later if necessary.
    &#34;&#34;&#34;
    super(MethodDescriptor, self).__init__(
        options, serialized_options, &#39;MethodOptions&#39;)
    self.name = name
    self.full_name = full_name
    self.index = index
    self.containing_service = containing_service
    self.input_type = input_type
    self.output_type = output_type


class FileDescriptor(DescriptorBase):
  &#34;&#34;&#34;Descriptor for a file. Mimics the descriptor_pb2.FileDescriptorProto.

  Note that enum_types_by_name, extensions_by_name, and dependencies
  fields are only set by the message_factory module, and not by the
  generated proto code.

  name: name of file, relative to root of source tree.
  package: name of the package
  syntax: string indicating syntax of the file (can be &#34;proto2&#34; or &#34;proto3&#34;)
  serialized_pb: (str) Byte string of serialized
    descriptor_pb2.FileDescriptorProto.
  dependencies: List of other FileDescriptors this FileDescriptor depends on.
  public_dependencies: A list of FileDescriptors, subset of the dependencies
    above, which were declared as &#34;public&#34;.
  message_types_by_name: Dict of message names and their descriptors.
  enum_types_by_name: Dict of enum names and their descriptors.
  extensions_by_name: Dict of extension names and their descriptors.
  services_by_name: Dict of services names and their descriptors.
  pool: the DescriptorPool this descriptor belongs to.  When not passed to the
    constructor, the global default pool is used.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.FileDescriptor

    def __new__(cls, name, package, options=None,
                serialized_options=None, serialized_pb=None,
                dependencies=None, public_dependencies=None,
                syntax=None, pool=None):
      # FileDescriptor() is called from various places, not only from generated
      # files, to register dynamic proto files and messages.
      # pylint: disable=g-explicit-bool-comparison
      if serialized_pb == &#39;&#39;:
        # Cpp generated code must be linked in if serialized_pb is &#39;&#39;
        try:
          return _message.default_pool.FindFileByName(name)
        except KeyError:
          raise RuntimeError(&#39;Please link in cpp generated lib for %s&#39; % (name))
      elif serialized_pb:
        return _message.default_pool.AddSerializedFile(serialized_pb)
      else:
        return super(FileDescriptor, cls).__new__(cls)

  def __init__(self, name, package, options=None,
               serialized_options=None, serialized_pb=None,
               dependencies=None, public_dependencies=None,
               syntax=None, pool=None):
    &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
    super(FileDescriptor, self).__init__(
        options, serialized_options, &#39;FileOptions&#39;)

    if pool is None:
      from google.protobuf import descriptor_pool
      pool = descriptor_pool.Default()
    self.pool = pool
    self.message_types_by_name = {}
    self.name = name
    self.package = package
    self.syntax = syntax or &#34;proto2&#34;
    self.serialized_pb = serialized_pb

    self.enum_types_by_name = {}
    self.extensions_by_name = {}
    self.services_by_name = {}
    self.dependencies = (dependencies or [])
    self.public_dependencies = (public_dependencies or [])

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.FileDescriptorProto.

    Args:
      proto: An empty descriptor_pb2.FileDescriptorProto.
    &#34;&#34;&#34;
    proto.ParseFromString(self.serialized_pb)


def _ParseOptions(message, string):
  &#34;&#34;&#34;Parses serialized options.

  This helper function is used to parse serialized options in generated
  proto2 files. It must not be used outside proto2.
  &#34;&#34;&#34;
  message.ParseFromString(string)
  return message


def _ToCamelCase(name):
  &#34;&#34;&#34;Converts name to camel-case and returns it.&#34;&#34;&#34;
  capitalize_next = False
  result = []

  for c in name:
    if c == &#39;_&#39;:
      if result:
        capitalize_next = True
    elif capitalize_next:
      result.append(c.upper())
      capitalize_next = False
    else:
      result += c

  # Lower-case the first letter.
  if result and result[0].isupper():
    result[0] = result[0].lower()
  return &#39;&#39;.join(result)


def _OptionsOrNone(descriptor_proto):
  &#34;&#34;&#34;Returns the value of the field `options`, or None if it is not set.&#34;&#34;&#34;
  if descriptor_proto.HasField(&#39;options&#39;):
    return descriptor_proto.options
  else:
    return None


def _ToJsonName(name):
  &#34;&#34;&#34;Converts name to Json name and returns it.&#34;&#34;&#34;
  capitalize_next = False
  result = []

  for c in name:
    if c == &#39;_&#39;:
      capitalize_next = True
    elif capitalize_next:
      result.append(c.upper())
      capitalize_next = False
    else:
      result += c

  return &#39;&#39;.join(result)


def MakeDescriptor(desc_proto, package=&#39;&#39;, build_file_if_cpp=True,
                   syntax=None):
  &#34;&#34;&#34;Make a protobuf Descriptor given a DescriptorProto protobuf.

  Handles nested descriptors. Note that this is limited to the scope of defining
  a message inside of another message. Composite fields can currently only be
  resolved if the message is defined in the same scope as the field.

  Args:
    desc_proto: The descriptor_pb2.DescriptorProto protobuf message.
    package: Optional package name for the new message Descriptor (string).
    build_file_if_cpp: Update the C++ descriptor pool if api matches.
                       Set to False on recursion, so no duplicates are created.
    syntax: The syntax/semantics that should be used.  Set to &#34;proto3&#34; to get
            proto3 field presence semantics.
  Returns:
    A Descriptor for protobuf messages.
  &#34;&#34;&#34;
  if api_implementation.Type() == &#39;cpp&#39; and build_file_if_cpp:
    # The C++ implementation requires all descriptors to be backed by the same
    # definition in the C++ descriptor pool. To do this, we build a
    # FileDescriptorProto with the same definition as this descriptor and build
    # it into the pool.
    from google.protobuf import descriptor_pb2
    file_descriptor_proto = descriptor_pb2.FileDescriptorProto()
    file_descriptor_proto.message_type.add().MergeFrom(desc_proto)

    # Generate a random name for this proto file to prevent conflicts with any
    # imported ones. We need to specify a file name so the descriptor pool
    # accepts our FileDescriptorProto, but it is not important what that file
    # name is actually set to.
    proto_name = binascii.hexlify(os.urandom(16)).decode(&#39;ascii&#39;)

    if package:
      file_descriptor_proto.name = os.path.join(package.replace(&#39;.&#39;, &#39;/&#39;),
                                                proto_name + &#39;.proto&#39;)
      file_descriptor_proto.package = package
    else:
      file_descriptor_proto.name = proto_name + &#39;.proto&#39;

    _message.default_pool.Add(file_descriptor_proto)
    result = _message.default_pool.FindFileByName(file_descriptor_proto.name)

    if _USE_C_DESCRIPTORS:
      return result.message_types_by_name[desc_proto.name]

  full_message_name = [desc_proto.name]
  if package: full_message_name.insert(0, package)

  # Create Descriptors for enum types
  enum_types = {}
  for enum_proto in desc_proto.enum_type:
    full_name = &#39;.&#39;.join(full_message_name + [enum_proto.name])
    enum_desc = EnumDescriptor(
      enum_proto.name, full_name, None, [
          EnumValueDescriptor(enum_val.name, ii, enum_val.number)
          for ii, enum_val in enumerate(enum_proto.value)])
    enum_types[full_name] = enum_desc

  # Create Descriptors for nested types
  nested_types = {}
  for nested_proto in desc_proto.nested_type:
    full_name = &#39;.&#39;.join(full_message_name + [nested_proto.name])
    # Nested types are just those defined inside of the message, not all types
    # used by fields in the message, so no loops are possible here.
    nested_desc = MakeDescriptor(nested_proto,
                                 package=&#39;.&#39;.join(full_message_name),
                                 build_file_if_cpp=False,
                                 syntax=syntax)
    nested_types[full_name] = nested_desc

  fields = []
  for field_proto in desc_proto.field:
    full_name = &#39;.&#39;.join(full_message_name + [field_proto.name])
    enum_desc = None
    nested_desc = None
    if field_proto.json_name:
      json_name = field_proto.json_name
    else:
      json_name = None
    if field_proto.HasField(&#39;type_name&#39;):
      type_name = field_proto.type_name
      full_type_name = &#39;.&#39;.join(full_message_name +
                                [type_name[type_name.rfind(&#39;.&#39;)+1:]])
      if full_type_name in nested_types:
        nested_desc = nested_types[full_type_name]
      elif full_type_name in enum_types:
        enum_desc = enum_types[full_type_name]
      # Else type_name references a non-local type, which isn&#39;t implemented
    field = FieldDescriptor(
        field_proto.name, full_name, field_proto.number - 1,
        field_proto.number, field_proto.type,
        FieldDescriptor.ProtoTypeToCppProtoType(field_proto.type),
        field_proto.label, None, nested_desc, enum_desc, None, False, None,
        options=_OptionsOrNone(field_proto), has_default_value=False,
        json_name=json_name)
    fields.append(field)

  desc_name = &#39;.&#39;.join(full_message_name)
  return Descriptor(desc_proto.name, desc_name, None, None, fields,
                    list(nested_types.values()), list(enum_types.values()), [],
                    options=_OptionsOrNone(desc_proto))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="google.protobuf.descriptor.MakeDescriptor"><code class="name flex">
<span>def <span class="ident">MakeDescriptor</span></span>(<span>desc_proto, package='', build_file_if_cpp=True, syntax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Make a protobuf Descriptor given a DescriptorProto protobuf.</p>
<p>Handles nested descriptors. Note that this is limited to the scope of defining
a message inside of another message. Composite fields can currently only be
resolved if the message is defined in the same scope as the field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>desc_proto</code></strong></dt>
<dd>The descriptor_pb2.DescriptorProto protobuf message.</dd>
<dt><strong><code>package</code></strong></dt>
<dd>Optional package name for the new message Descriptor (string).</dd>
<dt><strong><code>build_file_if_cpp</code></strong></dt>
<dd>Update the C++ descriptor pool if api matches.
Set to False on recursion, so no duplicates are created.</dd>
<dt><strong><code>syntax</code></strong></dt>
<dd>The syntax/semantics that should be used.
Set to "proto3" to get
proto3 field presence semantics.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Descriptor for protobuf messages.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeDescriptor(desc_proto, package=&#39;&#39;, build_file_if_cpp=True,
                   syntax=None):
  &#34;&#34;&#34;Make a protobuf Descriptor given a DescriptorProto protobuf.

  Handles nested descriptors. Note that this is limited to the scope of defining
  a message inside of another message. Composite fields can currently only be
  resolved if the message is defined in the same scope as the field.

  Args:
    desc_proto: The descriptor_pb2.DescriptorProto protobuf message.
    package: Optional package name for the new message Descriptor (string).
    build_file_if_cpp: Update the C++ descriptor pool if api matches.
                       Set to False on recursion, so no duplicates are created.
    syntax: The syntax/semantics that should be used.  Set to &#34;proto3&#34; to get
            proto3 field presence semantics.
  Returns:
    A Descriptor for protobuf messages.
  &#34;&#34;&#34;
  if api_implementation.Type() == &#39;cpp&#39; and build_file_if_cpp:
    # The C++ implementation requires all descriptors to be backed by the same
    # definition in the C++ descriptor pool. To do this, we build a
    # FileDescriptorProto with the same definition as this descriptor and build
    # it into the pool.
    from google.protobuf import descriptor_pb2
    file_descriptor_proto = descriptor_pb2.FileDescriptorProto()
    file_descriptor_proto.message_type.add().MergeFrom(desc_proto)

    # Generate a random name for this proto file to prevent conflicts with any
    # imported ones. We need to specify a file name so the descriptor pool
    # accepts our FileDescriptorProto, but it is not important what that file
    # name is actually set to.
    proto_name = binascii.hexlify(os.urandom(16)).decode(&#39;ascii&#39;)

    if package:
      file_descriptor_proto.name = os.path.join(package.replace(&#39;.&#39;, &#39;/&#39;),
                                                proto_name + &#39;.proto&#39;)
      file_descriptor_proto.package = package
    else:
      file_descriptor_proto.name = proto_name + &#39;.proto&#39;

    _message.default_pool.Add(file_descriptor_proto)
    result = _message.default_pool.FindFileByName(file_descriptor_proto.name)

    if _USE_C_DESCRIPTORS:
      return result.message_types_by_name[desc_proto.name]

  full_message_name = [desc_proto.name]
  if package: full_message_name.insert(0, package)

  # Create Descriptors for enum types
  enum_types = {}
  for enum_proto in desc_proto.enum_type:
    full_name = &#39;.&#39;.join(full_message_name + [enum_proto.name])
    enum_desc = EnumDescriptor(
      enum_proto.name, full_name, None, [
          EnumValueDescriptor(enum_val.name, ii, enum_val.number)
          for ii, enum_val in enumerate(enum_proto.value)])
    enum_types[full_name] = enum_desc

  # Create Descriptors for nested types
  nested_types = {}
  for nested_proto in desc_proto.nested_type:
    full_name = &#39;.&#39;.join(full_message_name + [nested_proto.name])
    # Nested types are just those defined inside of the message, not all types
    # used by fields in the message, so no loops are possible here.
    nested_desc = MakeDescriptor(nested_proto,
                                 package=&#39;.&#39;.join(full_message_name),
                                 build_file_if_cpp=False,
                                 syntax=syntax)
    nested_types[full_name] = nested_desc

  fields = []
  for field_proto in desc_proto.field:
    full_name = &#39;.&#39;.join(full_message_name + [field_proto.name])
    enum_desc = None
    nested_desc = None
    if field_proto.json_name:
      json_name = field_proto.json_name
    else:
      json_name = None
    if field_proto.HasField(&#39;type_name&#39;):
      type_name = field_proto.type_name
      full_type_name = &#39;.&#39;.join(full_message_name +
                                [type_name[type_name.rfind(&#39;.&#39;)+1:]])
      if full_type_name in nested_types:
        nested_desc = nested_types[full_type_name]
      elif full_type_name in enum_types:
        enum_desc = enum_types[full_type_name]
      # Else type_name references a non-local type, which isn&#39;t implemented
    field = FieldDescriptor(
        field_proto.name, full_name, field_proto.number - 1,
        field_proto.number, field_proto.type,
        FieldDescriptor.ProtoTypeToCppProtoType(field_proto.type),
        field_proto.label, None, nested_desc, enum_desc, None, False, None,
        options=_OptionsOrNone(field_proto), has_default_value=False,
        json_name=json_name)
    fields.append(field)

  desc_name = &#39;.&#39;.join(full_message_name)
  return Descriptor(desc_proto.name, desc_name, None, None, fields,
                    list(nested_types.values()), list(enum_types.values()), [],
                    options=_OptionsOrNone(desc_proto))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.protobuf.descriptor.Descriptor"><code class="flex name class">
<span>class <span class="ident">Descriptor</span></span>
<span>(</span><span>name, full_name, filename, containing_type, fields, nested_types, enum_types, extensions, options=None, serialized_options=None, is_extendable=True, extension_ranges=None, oneofs=None, file=None, serialized_start=None, serialized_end=None, syntax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a protocol message type.</p>
<p>A Descriptor instance has the following attributes:</p>
<p>name: (str) Name of this protocol message type.
full_name: (str) Fully-qualified name of this protocol message type,
which will include protocol "package" name and the name of any
enclosing types.</p>
<p>containing_type: (Descriptor) Reference to the descriptor of the
type containing us, or None if this is top-level.</p>
<p>fields: (list of FieldDescriptors) Field descriptors for all
fields in this type.
fields_by_number: (dict int -&gt; FieldDescriptor) Same FieldDescriptor
objects as in |fields|, but indexed by "number" attribute in each
FieldDescriptor.
fields_by_name: (dict str -&gt; FieldDescriptor) Same FieldDescriptor
objects as in |fields|, but indexed by "name" attribute in each
FieldDescriptor.
fields_by_camelcase_name: (dict str -&gt; FieldDescriptor) Same
FieldDescriptor objects as in |fields|, but indexed by
"camelcase_name" attribute in each FieldDescriptor.</p>
<p>nested_types: (list of Descriptors) Descriptor references
for all protocol message types nested within this one.
nested_types_by_name: (dict str -&gt; Descriptor) Same Descriptor
objects as in |nested_types|, but indexed by "name" attribute
in each Descriptor.</p>
<p>enum_types: (list of EnumDescriptors) EnumDescriptor references
for all enums contained within this type.
enum_types_by_name: (dict str -&gt;EnumDescriptor) Same EnumDescriptor
objects as in |enum_types|, but indexed by "name" attribute
in each EnumDescriptor.
enum_values_by_name: (dict str -&gt; EnumValueDescriptor) Dict mapping
from enum value name to EnumValueDescriptor for that value.</p>
<p>extensions: (list of FieldDescriptor) All extensions defined directly
within this message type (NOT within a nested type).
extensions_by_name: (dict, string -&gt; FieldDescriptor) Same FieldDescriptor
objects as |extensions|, but indexed by "name" attribute of each
FieldDescriptor.</p>
<p>is_extendable:
Does this type define any extension ranges?</p>
<p>oneofs: (list of OneofDescriptor) The list of descriptors for oneof fields
in this message.
oneofs_by_name: (dict str -&gt; OneofDescriptor) Same objects as in |oneofs|,
but indexed by "name" attribute.</p>
<p>file: (FileDescriptor) Reference to file descriptor.</p>
<p>Arguments to <strong>init</strong>() are as described in the description
of Descriptor fields above.</p>
<p>Note that filename is an obsolete argument, that is not used anymore.
Please use file.name to access this as an attribute.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Descriptor(_NestedDescriptorBase):

  &#34;&#34;&#34;Descriptor for a protocol message type.

  A Descriptor instance has the following attributes:

    name: (str) Name of this protocol message type.
    full_name: (str) Fully-qualified name of this protocol message type,
      which will include protocol &#34;package&#34; name and the name of any
      enclosing types.

    containing_type: (Descriptor) Reference to the descriptor of the
      type containing us, or None if this is top-level.

    fields: (list of FieldDescriptors) Field descriptors for all
      fields in this type.
    fields_by_number: (dict int -&gt; FieldDescriptor) Same FieldDescriptor
      objects as in |fields|, but indexed by &#34;number&#34; attribute in each
      FieldDescriptor.
    fields_by_name: (dict str -&gt; FieldDescriptor) Same FieldDescriptor
      objects as in |fields|, but indexed by &#34;name&#34; attribute in each
      FieldDescriptor.
    fields_by_camelcase_name: (dict str -&gt; FieldDescriptor) Same
      FieldDescriptor objects as in |fields|, but indexed by
      &#34;camelcase_name&#34; attribute in each FieldDescriptor.

    nested_types: (list of Descriptors) Descriptor references
      for all protocol message types nested within this one.
    nested_types_by_name: (dict str -&gt; Descriptor) Same Descriptor
      objects as in |nested_types|, but indexed by &#34;name&#34; attribute
      in each Descriptor.

    enum_types: (list of EnumDescriptors) EnumDescriptor references
      for all enums contained within this type.
    enum_types_by_name: (dict str -&gt;EnumDescriptor) Same EnumDescriptor
      objects as in |enum_types|, but indexed by &#34;name&#34; attribute
      in each EnumDescriptor.
    enum_values_by_name: (dict str -&gt; EnumValueDescriptor) Dict mapping
      from enum value name to EnumValueDescriptor for that value.

    extensions: (list of FieldDescriptor) All extensions defined directly
      within this message type (NOT within a nested type).
    extensions_by_name: (dict, string -&gt; FieldDescriptor) Same FieldDescriptor
      objects as |extensions|, but indexed by &#34;name&#34; attribute of each
      FieldDescriptor.

    is_extendable:  Does this type define any extension ranges?

    oneofs: (list of OneofDescriptor) The list of descriptors for oneof fields
      in this message.
    oneofs_by_name: (dict str -&gt; OneofDescriptor) Same objects as in |oneofs|,
      but indexed by &#34;name&#34; attribute.

    file: (FileDescriptor) Reference to file descriptor.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.Descriptor

    def __new__(cls, name, full_name, filename, containing_type, fields,
                nested_types, enum_types, extensions, options=None,
                serialized_options=None,
                is_extendable=True, extension_ranges=None, oneofs=None,
                file=None, serialized_start=None, serialized_end=None,  # pylint: disable=redefined-builtin
                syntax=None):
      _message.Message._CheckCalledFromGeneratedFile()
      return _message.default_pool.FindMessageTypeByName(full_name)

  # NOTE(tmarek): The file argument redefining a builtin is nothing we can
  # fix right now since we don&#39;t know how many clients already rely on the
  # name of the argument.
  def __init__(self, name, full_name, filename, containing_type, fields,
               nested_types, enum_types, extensions, options=None,
               serialized_options=None,
               is_extendable=True, extension_ranges=None, oneofs=None,
               file=None, serialized_start=None, serialized_end=None,  # pylint: disable=redefined-builtin
               syntax=None):
    &#34;&#34;&#34;Arguments to __init__() are as described in the description
    of Descriptor fields above.

    Note that filename is an obsolete argument, that is not used anymore.
    Please use file.name to access this as an attribute.
    &#34;&#34;&#34;
    super(Descriptor, self).__init__(
        options, &#39;MessageOptions&#39;, name, full_name, file,
        containing_type, serialized_start=serialized_start,
        serialized_end=serialized_end, serialized_options=serialized_options)

    # We have fields in addition to fields_by_name and fields_by_number,
    # so that:
    #   1. Clients can index fields by &#34;order in which they&#39;re listed.&#34;
    #   2. Clients can easily iterate over all fields with the terse
    #      syntax: for f in descriptor.fields: ...
    self.fields = fields
    for field in self.fields:
      field.containing_type = self
    self.fields_by_number = dict((f.number, f) for f in fields)
    self.fields_by_name = dict((f.name, f) for f in fields)
    self._fields_by_camelcase_name = None

    self.nested_types = nested_types
    for nested_type in nested_types:
      nested_type.containing_type = self
    self.nested_types_by_name = dict((t.name, t) for t in nested_types)

    self.enum_types = enum_types
    for enum_type in self.enum_types:
      enum_type.containing_type = self
    self.enum_types_by_name = dict((t.name, t) for t in enum_types)
    self.enum_values_by_name = dict(
        (v.name, v) for t in enum_types for v in t.values)

    self.extensions = extensions
    for extension in self.extensions:
      extension.extension_scope = self
    self.extensions_by_name = dict((f.name, f) for f in extensions)
    self.is_extendable = is_extendable
    self.extension_ranges = extension_ranges
    self.oneofs = oneofs if oneofs is not None else []
    self.oneofs_by_name = dict((o.name, o) for o in self.oneofs)
    for oneof in self.oneofs:
      oneof.containing_type = self
    self.syntax = syntax or &#34;proto2&#34;

  @property
  def fields_by_camelcase_name(self):
    if self._fields_by_camelcase_name is None:
      self._fields_by_camelcase_name = dict(
          (f.camelcase_name, f) for f in self.fields)
    return self._fields_by_camelcase_name

  def EnumValueName(self, enum, value):
    &#34;&#34;&#34;Returns the string name of an enum value.

    This is just a small helper method to simplify a common operation.

    Args:
      enum: string name of the Enum.
      value: int, value of the enum.

    Returns:
      string name of the enum value.

    Raises:
      KeyError if either the Enum doesn&#39;t exist or the value is not a valid
        value for the enum.
    &#34;&#34;&#34;
    return self.enum_types_by_name[enum].values_by_number[value].name

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.DescriptorProto.

    Args:
      proto: An empty descriptor_pb2.DescriptorProto.
    &#34;&#34;&#34;
    # This function is overridden to give a better doc comment.
    super(Descriptor, self).CopyToProto(proto)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.descriptor._NestedDescriptorBase</li>
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="google.protobuf.descriptor.Descriptor.fields_by_camelcase_name"><code class="name">var <span class="ident">fields_by_camelcase_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fields_by_camelcase_name(self):
  if self._fields_by_camelcase_name is None:
    self._fields_by_camelcase_name = dict(
        (f.camelcase_name, f) for f in self.fields)
  return self._fields_by_camelcase_name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.descriptor.Descriptor.CopyToProto"><code class="name flex">
<span>def <span class="ident">CopyToProto</span></span>(<span>self, proto)</span>
</code></dt>
<dd>
<section class="desc"><p>Copies this to a descriptor_pb2.DescriptorProto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proto</code></strong></dt>
<dd>An empty descriptor_pb2.DescriptorProto.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CopyToProto(self, proto):
  &#34;&#34;&#34;Copies this to a descriptor_pb2.DescriptorProto.

  Args:
    proto: An empty descriptor_pb2.DescriptorProto.
  &#34;&#34;&#34;
  # This function is overridden to give a better doc comment.
  super(Descriptor, self).CopyToProto(proto)</code></pre>
</details>
</dd>
<dt id="google.protobuf.descriptor.Descriptor.EnumValueName"><code class="name flex">
<span>def <span class="ident">EnumValueName</span></span>(<span>self, enum, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the string name of an enum value.</p>
<p>This is just a small helper method to simplify a common operation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>enum</code></strong></dt>
<dd>string name of the Enum.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>int, value of the enum.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>string name of the enum value.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code> <code>if</code> <code>either</code> <code>the</code> <code>Enum</code> <code>doesn't</code> <code>exist</code> or <code>the</code> <code>value</code> <code>is</code> <code>not</code> <code>a</code> <code>valid</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>value for the enum.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EnumValueName(self, enum, value):
  &#34;&#34;&#34;Returns the string name of an enum value.

  This is just a small helper method to simplify a common operation.

  Args:
    enum: string name of the Enum.
    value: int, value of the enum.

  Returns:
    string name of the enum value.

  Raises:
    KeyError if either the Enum doesn&#39;t exist or the value is not a valid
      value for the enum.
  &#34;&#34;&#34;
  return self.enum_types_by_name[enum].values_by_number[value].name</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.DescriptorBase"><code class="flex name class">
<span>class <span class="ident">DescriptorBase</span></span>
<span>(</span><span>options, serialized_options, options_class_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptors base class.</p>
<p>This class is the base of all descriptor classes. It provides common options
related functionality.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>has_options</code></strong></dt>
<dd>True if the descriptor has non-default options.
Usually it
is not necessary to read this &ndash; just call GetOptions() which will
happily return the default instance.
However, it's sometimes useful
for efficiency, and also useful inside the protobuf implementation to
avoid some bootstrapping issues.</dd>
</dl>
<p>Initialize the descriptor given its options message and the name of the
class of the options message. The name of the class is required in case
the options message is None and has to be created.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DescriptorBase(six.with_metaclass(DescriptorMetaclass)):

  &#34;&#34;&#34;Descriptors base class.

  This class is the base of all descriptor classes. It provides common options
  related functionality.

  Attributes:
    has_options:  True if the descriptor has non-default options.  Usually it
        is not necessary to read this -- just call GetOptions() which will
        happily return the default instance.  However, it&#39;s sometimes useful
        for efficiency, and also useful inside the protobuf implementation to
        avoid some bootstrapping issues.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    # The class, or tuple of classes, that are considered as &#34;virtual
    # subclasses&#34; of this descriptor class.
    _C_DESCRIPTOR_CLASS = ()

  def __init__(self, options, serialized_options, options_class_name):
    &#34;&#34;&#34;Initialize the descriptor given its options message and the name of the
    class of the options message. The name of the class is required in case
    the options message is None and has to be created.
    &#34;&#34;&#34;
    self._options = options
    self._options_class_name = options_class_name
    self._serialized_options = serialized_options

    # Does this descriptor have non-default options?
    self.has_options = (options is not None) or (serialized_options is not None)

  def _SetOptions(self, options, options_class_name):
    &#34;&#34;&#34;Sets the descriptor&#39;s options

    This function is used in generated proto2 files to update descriptor
    options. It must not be used outside proto2.
    &#34;&#34;&#34;
    self._options = options
    self._options_class_name = options_class_name

    # Does this descriptor have non-default options?
    self.has_options = options is not None

  def GetOptions(self):
    &#34;&#34;&#34;Retrieves descriptor options.

    This method returns the options set or creates the default options for the
    descriptor.
    &#34;&#34;&#34;
    if self._options:
      return self._options

    from google.protobuf import descriptor_pb2
    try:
      options_class = getattr(descriptor_pb2,
                              self._options_class_name)
    except AttributeError:
      raise RuntimeError(&#39;Unknown options class name %s!&#39; %
                         (self._options_class_name))

    with _lock:
      if self._serialized_options is None:
        self._options = options_class()
      else:
        self._options = _ParseOptions(options_class(),
                                      self._serialized_options)

      return self._options</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.EnumValueDescriptor" href="#google.protobuf.descriptor.EnumValueDescriptor">EnumValueDescriptor</a></li>
<li><a title="google.protobuf.descriptor.FieldDescriptor" href="#google.protobuf.descriptor.FieldDescriptor">FieldDescriptor</a></li>
<li><a title="google.protobuf.descriptor.FileDescriptor" href="#google.protobuf.descriptor.FileDescriptor">FileDescriptor</a></li>
<li><a title="google.protobuf.descriptor.MethodDescriptor" href="#google.protobuf.descriptor.MethodDescriptor">MethodDescriptor</a></li>
<li><a title="google.protobuf.descriptor.OneofDescriptor" href="#google.protobuf.descriptor.OneofDescriptor">OneofDescriptor</a></li>
<li>google.protobuf.descriptor._NestedDescriptorBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.descriptor.DescriptorBase.GetOptions"><code class="name flex">
<span>def <span class="ident">GetOptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves descriptor options.</p>
<p>This method returns the options set or creates the default options for the
descriptor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetOptions(self):
  &#34;&#34;&#34;Retrieves descriptor options.

  This method returns the options set or creates the default options for the
  descriptor.
  &#34;&#34;&#34;
  if self._options:
    return self._options

  from google.protobuf import descriptor_pb2
  try:
    options_class = getattr(descriptor_pb2,
                            self._options_class_name)
  except AttributeError:
    raise RuntimeError(&#39;Unknown options class name %s!&#39; %
                       (self._options_class_name))

  with _lock:
    if self._serialized_options is None:
      self._options = options_class()
    else:
      self._options = _ParseOptions(options_class(),
                                    self._serialized_options)

    return self._options</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.descriptor.DescriptorMetaclass"><code class="flex name class">
<span>class <span class="ident">DescriptorMetaclass</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>type(object_or_name, bases, dict)
type(object) -&gt; the object's type
type(name, bases, dict) -&gt; a new type</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DescriptorMetaclass(type):
  def __instancecheck__(cls, obj):
    if super(DescriptorMetaclass, cls).__instancecheck__(obj):
      return True
    if isinstance(obj, cls._C_DESCRIPTOR_CLASS):
      return True
    return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.EnumDescriptor"><code class="flex name class">
<span>class <span class="ident">EnumDescriptor</span></span>
<span>(</span><span>name, full_name, filename, values, containing_type=None, options=None, serialized_options=None, file=None, serialized_start=None, serialized_end=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for an enum defined in a .proto file.</p>
<p>An EnumDescriptor instance has the following attributes:</p>
<p>name: (str) Name of the enum type.
full_name: (str) Full name of the type, including package name
and any enclosing type(s).</p>
<p>values: (list of EnumValueDescriptors) List of the values
in this enum.
values_by_name: (dict str -&gt; EnumValueDescriptor) Same as |values|,
but indexed by the "name" field of each EnumValueDescriptor.
values_by_number: (dict int -&gt; EnumValueDescriptor) Same as |values|,
but indexed by the "number" field of each EnumValueDescriptor.
containing_type: (Descriptor) Descriptor of the immediate containing
type of this enum, or None if this is an enum defined at the
top level in a .proto file.
Set by Descriptor's constructor
if we're passed into one.
file: (FileDescriptor) Reference to file descriptor.
options: (descriptor_pb2.EnumOptions) Enum options message or
None to use default enum options.</p>
<p>Arguments are as described in the attribute description above.</p>
<p>Note that filename is an obsolete argument, that is not used anymore.
Please use file.name to access this as an attribute.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumDescriptor(_NestedDescriptorBase):

  &#34;&#34;&#34;Descriptor for an enum defined in a .proto file.

  An EnumDescriptor instance has the following attributes:

    name: (str) Name of the enum type.
    full_name: (str) Full name of the type, including package name
      and any enclosing type(s).

    values: (list of EnumValueDescriptors) List of the values
      in this enum.
    values_by_name: (dict str -&gt; EnumValueDescriptor) Same as |values|,
      but indexed by the &#34;name&#34; field of each EnumValueDescriptor.
    values_by_number: (dict int -&gt; EnumValueDescriptor) Same as |values|,
      but indexed by the &#34;number&#34; field of each EnumValueDescriptor.
    containing_type: (Descriptor) Descriptor of the immediate containing
      type of this enum, or None if this is an enum defined at the
      top level in a .proto file.  Set by Descriptor&#39;s constructor
      if we&#39;re passed into one.
    file: (FileDescriptor) Reference to file descriptor.
    options: (descriptor_pb2.EnumOptions) Enum options message or
      None to use default enum options.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.EnumDescriptor

    def __new__(cls, name, full_name, filename, values,
                containing_type=None, options=None,
                serialized_options=None, file=None,  # pylint: disable=redefined-builtin
                serialized_start=None, serialized_end=None):
      _message.Message._CheckCalledFromGeneratedFile()
      return _message.default_pool.FindEnumTypeByName(full_name)

  def __init__(self, name, full_name, filename, values,
               containing_type=None, options=None,
               serialized_options=None, file=None,  # pylint: disable=redefined-builtin
               serialized_start=None, serialized_end=None):
    &#34;&#34;&#34;Arguments are as described in the attribute description above.

    Note that filename is an obsolete argument, that is not used anymore.
    Please use file.name to access this as an attribute.
    &#34;&#34;&#34;
    super(EnumDescriptor, self).__init__(
        options, &#39;EnumOptions&#39;, name, full_name, file,
        containing_type, serialized_start=serialized_start,
        serialized_end=serialized_end, serialized_options=serialized_options)

    self.values = values
    for value in self.values:
      value.type = self
    self.values_by_name = dict((v.name, v) for v in values)
    # Values are reversed to ensure that the first alias is retained.
    self.values_by_number = dict((v.number, v) for v in reversed(values))

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.EnumDescriptorProto.

    Args:
      proto: An empty descriptor_pb2.EnumDescriptorProto.
    &#34;&#34;&#34;
    # This function is overridden to give a better doc comment.
    super(EnumDescriptor, self).CopyToProto(proto)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.descriptor._NestedDescriptorBase</li>
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.descriptor.EnumDescriptor.CopyToProto"><code class="name flex">
<span>def <span class="ident">CopyToProto</span></span>(<span>self, proto)</span>
</code></dt>
<dd>
<section class="desc"><p>Copies this to a descriptor_pb2.EnumDescriptorProto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proto</code></strong></dt>
<dd>An empty descriptor_pb2.EnumDescriptorProto.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CopyToProto(self, proto):
  &#34;&#34;&#34;Copies this to a descriptor_pb2.EnumDescriptorProto.

  Args:
    proto: An empty descriptor_pb2.EnumDescriptorProto.
  &#34;&#34;&#34;
  # This function is overridden to give a better doc comment.
  super(EnumDescriptor, self).CopyToProto(proto)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.EnumValueDescriptor"><code class="flex name class">
<span>class <span class="ident">EnumValueDescriptor</span></span>
<span>(</span><span>name, index, number, type=None, options=None, serialized_options=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a single value within an enum.</p>
<p>name: (str) Name of this value.
index: (int) Dense, 0-indexed index giving the order that this
value appears textually within its enum in the .proto file.
number: (int) Actual number assigned to this enum value.
type: (EnumDescriptor) EnumDescriptor to which this value
belongs.
Set by EnumDescriptor's constructor if we're
passed into one.
options: (descriptor_pb2.EnumValueOptions) Enum value options message or
None to use default enum value options options.</p>
<p>Arguments are as described in the attribute description above.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumValueDescriptor(DescriptorBase):

  &#34;&#34;&#34;Descriptor for a single value within an enum.

    name: (str) Name of this value.
    index: (int) Dense, 0-indexed index giving the order that this
      value appears textually within its enum in the .proto file.
    number: (int) Actual number assigned to this enum value.
    type: (EnumDescriptor) EnumDescriptor to which this value
      belongs.  Set by EnumDescriptor&#39;s constructor if we&#39;re
      passed into one.
    options: (descriptor_pb2.EnumValueOptions) Enum value options message or
      None to use default enum value options options.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.EnumValueDescriptor

    def __new__(cls, name, index, number,
                type=None,  # pylint: disable=redefined-builtin
                options=None, serialized_options=None):
      _message.Message._CheckCalledFromGeneratedFile()
      # There is no way we can build a complete EnumValueDescriptor with the
      # given parameters (the name of the Enum is not known, for example).
      # Fortunately generated files just pass it to the EnumDescriptor()
      # constructor, which will ignore it, so returning None is good enough.
      return None

  def __init__(self, name, index, number,
               type=None,  # pylint: disable=redefined-builtin
               options=None, serialized_options=None):
    &#34;&#34;&#34;Arguments are as described in the attribute description above.&#34;&#34;&#34;
    super(EnumValueDescriptor, self).__init__(
        options, serialized_options, &#39;EnumValueOptions&#39;)
    self.name = name
    self.index = index
    self.number = number
    self.type = type</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Base error for this module.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error(Exception):
  &#34;&#34;&#34;Base error for this module.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.TypeTransformationError" href="#google.protobuf.descriptor.TypeTransformationError">TypeTransformationError</a></li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor"><code class="flex name class">
<span>class <span class="ident">FieldDescriptor</span></span>
<span>(</span><span>name, full_name, index, number, type, cpp_type, label, default_value, message_type, enum_type, containing_type, is_extension, extension_scope, options=None, serialized_options=None, has_default_value=True, containing_oneof=None, json_name=None, file=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a single field in a .proto file.</p>
<p>A FieldDescriptor instance has the following attributes:</p>
<p>name: (str) Name of this field, exactly as it appears in .proto.
full_name: (str) Name of this field, including containing scope.
This is
particularly relevant for extensions.
camelcase_name: (str) Camelcase name of this field.
index: (int) Dense, 0-indexed index giving the order that this
field textually appears within its message in the .proto file.
number: (int) Tag number declared for this field in the .proto file.</p>
<p>type: (One of the TYPE_<em> constants below) Declared type.
cpp_type: (One of the CPPTYPE_</em> constants below) C++ type used to
represent this field.</p>
<p>label: (One of the LABEL_* constants below) Tells whether this
field is optional, required, or repeated.
has_default_value: (bool) True if this field has a default value defined,
otherwise false.
default_value: (Varies) Default value of this field.
Only
meaningful for non-repeated scalar fields.
Repeated fields
should always set this to [], and non-repeated composite
fields should always set this to None.</p>
<p>containing_type: (Descriptor) Descriptor of the protocol message
type that contains this field.
Set by the Descriptor constructor
if we're passed into one.
Somewhat confusingly, for extension fields, this is the
descriptor of the EXTENDED message, not the descriptor
of the message containing this field.
(See is_extension and
extension_scope below).
message_type: (Descriptor) If a composite field, a descriptor
of the message type contained in this field.
Otherwise, this is None.
enum_type: (EnumDescriptor) If this field contains an enum, a
descriptor of that enum.
Otherwise, this is None.</p>
<p>is_extension: True iff this describes an extension field.
extension_scope: (Descriptor) Only meaningful if is_extension is True.
Gives the message that immediately contains this extension field.
Will be None iff we're a top-level (file-level) extension field.</p>
<p>options: (descriptor_pb2.FieldOptions) Protocol message field options or
None to use default field options.</p>
<p>containing_oneof: (OneofDescriptor) If the field is a member of a oneof
union, contains its descriptor. Otherwise, None.</p>
<p>file: (FileDescriptor) Reference to file descriptor.</p>
<p>The arguments are as described in the description of FieldDescriptor
attributes above.</p>
<p>Note that containing_type may be None, and may be set later if necessary
(to deal with circular references between message types, for example).
Likewise for extension_scope.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldDescriptor(DescriptorBase):

  &#34;&#34;&#34;Descriptor for a single field in a .proto file.

  A FieldDescriptor instance has the following attributes:

    name: (str) Name of this field, exactly as it appears in .proto.
    full_name: (str) Name of this field, including containing scope.  This is
      particularly relevant for extensions.
    camelcase_name: (str) Camelcase name of this field.
    index: (int) Dense, 0-indexed index giving the order that this
      field textually appears within its message in the .proto file.
    number: (int) Tag number declared for this field in the .proto file.

    type: (One of the TYPE_* constants below) Declared type.
    cpp_type: (One of the CPPTYPE_* constants below) C++ type used to
      represent this field.

    label: (One of the LABEL_* constants below) Tells whether this
      field is optional, required, or repeated.
    has_default_value: (bool) True if this field has a default value defined,
      otherwise false.
    default_value: (Varies) Default value of this field.  Only
      meaningful for non-repeated scalar fields.  Repeated fields
      should always set this to [], and non-repeated composite
      fields should always set this to None.

    containing_type: (Descriptor) Descriptor of the protocol message
      type that contains this field.  Set by the Descriptor constructor
      if we&#39;re passed into one.
      Somewhat confusingly, for extension fields, this is the
      descriptor of the EXTENDED message, not the descriptor
      of the message containing this field.  (See is_extension and
      extension_scope below).
    message_type: (Descriptor) If a composite field, a descriptor
      of the message type contained in this field.  Otherwise, this is None.
    enum_type: (EnumDescriptor) If this field contains an enum, a
      descriptor of that enum.  Otherwise, this is None.

    is_extension: True iff this describes an extension field.
    extension_scope: (Descriptor) Only meaningful if is_extension is True.
      Gives the message that immediately contains this extension field.
      Will be None iff we&#39;re a top-level (file-level) extension field.

    options: (descriptor_pb2.FieldOptions) Protocol message field options or
      None to use default field options.

    containing_oneof: (OneofDescriptor) If the field is a member of a oneof
      union, contains its descriptor. Otherwise, None.

    file: (FileDescriptor) Reference to file descriptor.
  &#34;&#34;&#34;

  # Must be consistent with C++ FieldDescriptor::Type enum in
  # descriptor.h.
  #
  # TODO(robinson): Find a way to eliminate this repetition.
  TYPE_DOUBLE         = 1
  TYPE_FLOAT          = 2
  TYPE_INT64          = 3
  TYPE_UINT64         = 4
  TYPE_INT32          = 5
  TYPE_FIXED64        = 6
  TYPE_FIXED32        = 7
  TYPE_BOOL           = 8
  TYPE_STRING         = 9
  TYPE_GROUP          = 10
  TYPE_MESSAGE        = 11
  TYPE_BYTES          = 12
  TYPE_UINT32         = 13
  TYPE_ENUM           = 14
  TYPE_SFIXED32       = 15
  TYPE_SFIXED64       = 16
  TYPE_SINT32         = 17
  TYPE_SINT64         = 18
  MAX_TYPE            = 18

  # Must be consistent with C++ FieldDescriptor::CppType enum in
  # descriptor.h.
  #
  # TODO(robinson): Find a way to eliminate this repetition.
  CPPTYPE_INT32       = 1
  CPPTYPE_INT64       = 2
  CPPTYPE_UINT32      = 3
  CPPTYPE_UINT64      = 4
  CPPTYPE_DOUBLE      = 5
  CPPTYPE_FLOAT       = 6
  CPPTYPE_BOOL        = 7
  CPPTYPE_ENUM        = 8
  CPPTYPE_STRING      = 9
  CPPTYPE_MESSAGE     = 10
  MAX_CPPTYPE         = 10

  _PYTHON_TO_CPP_PROTO_TYPE_MAP = {
      TYPE_DOUBLE: CPPTYPE_DOUBLE,
      TYPE_FLOAT: CPPTYPE_FLOAT,
      TYPE_ENUM: CPPTYPE_ENUM,
      TYPE_INT64: CPPTYPE_INT64,
      TYPE_SINT64: CPPTYPE_INT64,
      TYPE_SFIXED64: CPPTYPE_INT64,
      TYPE_UINT64: CPPTYPE_UINT64,
      TYPE_FIXED64: CPPTYPE_UINT64,
      TYPE_INT32: CPPTYPE_INT32,
      TYPE_SFIXED32: CPPTYPE_INT32,
      TYPE_SINT32: CPPTYPE_INT32,
      TYPE_UINT32: CPPTYPE_UINT32,
      TYPE_FIXED32: CPPTYPE_UINT32,
      TYPE_BYTES: CPPTYPE_STRING,
      TYPE_STRING: CPPTYPE_STRING,
      TYPE_BOOL: CPPTYPE_BOOL,
      TYPE_MESSAGE: CPPTYPE_MESSAGE,
      TYPE_GROUP: CPPTYPE_MESSAGE
      }

  # Must be consistent with C++ FieldDescriptor::Label enum in
  # descriptor.h.
  #
  # TODO(robinson): Find a way to eliminate this repetition.
  LABEL_OPTIONAL      = 1
  LABEL_REQUIRED      = 2
  LABEL_REPEATED      = 3
  MAX_LABEL           = 3

  # Must be consistent with C++ constants kMaxNumber, kFirstReservedNumber,
  # and kLastReservedNumber in descriptor.h
  MAX_FIELD_NUMBER = (1 &lt;&lt; 29) - 1
  FIRST_RESERVED_FIELD_NUMBER = 19000
  LAST_RESERVED_FIELD_NUMBER = 19999

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.FieldDescriptor

    def __new__(cls, name, full_name, index, number, type, cpp_type, label,
                default_value, message_type, enum_type, containing_type,
                is_extension, extension_scope, options=None,
                serialized_options=None,
                has_default_value=True, containing_oneof=None, json_name=None,
                file=None):  # pylint: disable=redefined-builtin
      _message.Message._CheckCalledFromGeneratedFile()
      if is_extension:
        return _message.default_pool.FindExtensionByName(full_name)
      else:
        return _message.default_pool.FindFieldByName(full_name)

  def __init__(self, name, full_name, index, number, type, cpp_type, label,
               default_value, message_type, enum_type, containing_type,
               is_extension, extension_scope, options=None,
               serialized_options=None,
               has_default_value=True, containing_oneof=None, json_name=None,
               file=None):  # pylint: disable=redefined-builtin
    &#34;&#34;&#34;The arguments are as described in the description of FieldDescriptor
    attributes above.

    Note that containing_type may be None, and may be set later if necessary
    (to deal with circular references between message types, for example).
    Likewise for extension_scope.
    &#34;&#34;&#34;
    super(FieldDescriptor, self).__init__(
        options, serialized_options, &#39;FieldOptions&#39;)
    self.name = name
    self.full_name = full_name
    self.file = file
    self._camelcase_name = None
    if json_name is None:
      self.json_name = _ToJsonName(name)
    else:
      self.json_name = json_name
    self.index = index
    self.number = number
    self.type = type
    self.cpp_type = cpp_type
    self.label = label
    self.has_default_value = has_default_value
    self.default_value = default_value
    self.containing_type = containing_type
    self.message_type = message_type
    self.enum_type = enum_type
    self.is_extension = is_extension
    self.extension_scope = extension_scope
    self.containing_oneof = containing_oneof
    if api_implementation.Type() == &#39;cpp&#39;:
      if is_extension:
        self._cdescriptor = _message.default_pool.FindExtensionByName(full_name)
      else:
        self._cdescriptor = _message.default_pool.FindFieldByName(full_name)
    else:
      self._cdescriptor = None

  @property
  def camelcase_name(self):
    if self._camelcase_name is None:
      self._camelcase_name = _ToCamelCase(self.name)
    return self._camelcase_name

  @staticmethod
  def ProtoTypeToCppProtoType(proto_type):
    &#34;&#34;&#34;Converts from a Python proto type to a C++ Proto Type.

    The Python ProtocolBuffer classes specify both the &#39;Python&#39; datatype and the
    &#39;C++&#39; datatype - and they&#39;re not the same. This helper method should
    translate from one to another.

    Args:
      proto_type: the Python proto type (descriptor.FieldDescriptor.TYPE_*)
    Returns:
      descriptor.FieldDescriptor.CPPTYPE_*, the C++ type.
    Raises:
      TypeTransformationError: when the Python proto type isn&#39;t known.
    &#34;&#34;&#34;
    try:
      return FieldDescriptor._PYTHON_TO_CPP_PROTO_TYPE_MAP[proto_type]
    except KeyError:
      raise TypeTransformationError(&#39;Unknown proto_type: %s&#39; % proto_type)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_BOOL"><code class="name">var <span class="ident">CPPTYPE_BOOL</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_DOUBLE"><code class="name">var <span class="ident">CPPTYPE_DOUBLE</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_ENUM"><code class="name">var <span class="ident">CPPTYPE_ENUM</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_FLOAT"><code class="name">var <span class="ident">CPPTYPE_FLOAT</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_INT32"><code class="name">var <span class="ident">CPPTYPE_INT32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_INT64"><code class="name">var <span class="ident">CPPTYPE_INT64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_MESSAGE"><code class="name">var <span class="ident">CPPTYPE_MESSAGE</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_STRING"><code class="name">var <span class="ident">CPPTYPE_STRING</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_UINT32"><code class="name">var <span class="ident">CPPTYPE_UINT32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_UINT64"><code class="name">var <span class="ident">CPPTYPE_UINT64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.FIRST_RESERVED_FIELD_NUMBER"><code class="name">var <span class="ident">FIRST_RESERVED_FIELD_NUMBER</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.LABEL_OPTIONAL"><code class="name">var <span class="ident">LABEL_OPTIONAL</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.LABEL_REPEATED"><code class="name">var <span class="ident">LABEL_REPEATED</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.LABEL_REQUIRED"><code class="name">var <span class="ident">LABEL_REQUIRED</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.LAST_RESERVED_FIELD_NUMBER"><code class="name">var <span class="ident">LAST_RESERVED_FIELD_NUMBER</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.MAX_CPPTYPE"><code class="name">var <span class="ident">MAX_CPPTYPE</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.MAX_FIELD_NUMBER"><code class="name">var <span class="ident">MAX_FIELD_NUMBER</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.MAX_LABEL"><code class="name">var <span class="ident">MAX_LABEL</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.MAX_TYPE"><code class="name">var <span class="ident">MAX_TYPE</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_BOOL"><code class="name">var <span class="ident">TYPE_BOOL</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_BYTES"><code class="name">var <span class="ident">TYPE_BYTES</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_DOUBLE"><code class="name">var <span class="ident">TYPE_DOUBLE</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_ENUM"><code class="name">var <span class="ident">TYPE_ENUM</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_FIXED32"><code class="name">var <span class="ident">TYPE_FIXED32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_FIXED64"><code class="name">var <span class="ident">TYPE_FIXED64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_FLOAT"><code class="name">var <span class="ident">TYPE_FLOAT</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_GROUP"><code class="name">var <span class="ident">TYPE_GROUP</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_INT32"><code class="name">var <span class="ident">TYPE_INT32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_INT64"><code class="name">var <span class="ident">TYPE_INT64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_MESSAGE"><code class="name">var <span class="ident">TYPE_MESSAGE</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_SFIXED32"><code class="name">var <span class="ident">TYPE_SFIXED32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_SFIXED64"><code class="name">var <span class="ident">TYPE_SFIXED64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_SINT32"><code class="name">var <span class="ident">TYPE_SINT32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_SINT64"><code class="name">var <span class="ident">TYPE_SINT64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_STRING"><code class="name">var <span class="ident">TYPE_STRING</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_UINT32"><code class="name">var <span class="ident">TYPE_UINT32</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
<dt id="google.protobuf.descriptor.FieldDescriptor.TYPE_UINT64"><code class="name">var <span class="ident">TYPE_UINT64</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code>&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="google.protobuf.descriptor.FieldDescriptor.ProtoTypeToCppProtoType"><code class="name flex">
<span>def <span class="ident">ProtoTypeToCppProtoType</span></span>(<span>proto_type)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts from a Python proto type to a C++ Proto Type.</p>
<p>The Python ProtocolBuffer classes specify both the 'Python' datatype and the
'C++' datatype - and they're not the same. This helper method should
translate from one to another.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proto_type</code></strong></dt>
<dd>the Python proto type (descriptor.FieldDescriptor.TYPE_*)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>descriptor.FieldDescriptor.CPPTYPE_*, the C++ type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="google.protobuf.descriptor.TypeTransformationError" href="#google.protobuf.descriptor.TypeTransformationError"><code>TypeTransformationError</code></a></strong></dt>
<dd>when the Python proto type isn't known.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ProtoTypeToCppProtoType(proto_type):
  &#34;&#34;&#34;Converts from a Python proto type to a C++ Proto Type.

  The Python ProtocolBuffer classes specify both the &#39;Python&#39; datatype and the
  &#39;C++&#39; datatype - and they&#39;re not the same. This helper method should
  translate from one to another.

  Args:
    proto_type: the Python proto type (descriptor.FieldDescriptor.TYPE_*)
  Returns:
    descriptor.FieldDescriptor.CPPTYPE_*, the C++ type.
  Raises:
    TypeTransformationError: when the Python proto type isn&#39;t known.
  &#34;&#34;&#34;
  try:
    return FieldDescriptor._PYTHON_TO_CPP_PROTO_TYPE_MAP[proto_type]
  except KeyError:
    raise TypeTransformationError(&#39;Unknown proto_type: %s&#39; % proto_type)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="google.protobuf.descriptor.FieldDescriptor.camelcase_name"><code class="name">var <span class="ident">camelcase_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def camelcase_name(self):
  if self._camelcase_name is None:
    self._camelcase_name = _ToCamelCase(self.name)
  return self._camelcase_name</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.FileDescriptor"><code class="flex name class">
<span>class <span class="ident">FileDescriptor</span></span>
<span>(</span><span>name, package, options=None, serialized_options=None, serialized_pb=None, dependencies=None, public_dependencies=None, syntax=None, pool=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a file. Mimics the descriptor_pb2.FileDescriptorProto.</p>
<p>Note that enum_types_by_name, extensions_by_name, and dependencies
fields are only set by the message_factory module, and not by the
generated proto code.</p>
<p>name: name of file, relative to root of source tree.
package: name of the package
syntax: string indicating syntax of the file (can be "proto2" or "proto3")
serialized_pb: (str) Byte string of serialized
descriptor_pb2.FileDescriptorProto.
dependencies: List of other FileDescriptors this FileDescriptor depends on.
public_dependencies: A list of FileDescriptors, subset of the dependencies
above, which were declared as "public".
message_types_by_name: Dict of message names and their descriptors.
enum_types_by_name: Dict of enum names and their descriptors.
extensions_by_name: Dict of extension names and their descriptors.
services_by_name: Dict of services names and their descriptors.
pool: the DescriptorPool this descriptor belongs to.
When not passed to the
constructor, the global default pool is used.</p>
<p>Constructor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileDescriptor(DescriptorBase):
  &#34;&#34;&#34;Descriptor for a file. Mimics the descriptor_pb2.FileDescriptorProto.

  Note that enum_types_by_name, extensions_by_name, and dependencies
  fields are only set by the message_factory module, and not by the
  generated proto code.

  name: name of file, relative to root of source tree.
  package: name of the package
  syntax: string indicating syntax of the file (can be &#34;proto2&#34; or &#34;proto3&#34;)
  serialized_pb: (str) Byte string of serialized
    descriptor_pb2.FileDescriptorProto.
  dependencies: List of other FileDescriptors this FileDescriptor depends on.
  public_dependencies: A list of FileDescriptors, subset of the dependencies
    above, which were declared as &#34;public&#34;.
  message_types_by_name: Dict of message names and their descriptors.
  enum_types_by_name: Dict of enum names and their descriptors.
  extensions_by_name: Dict of extension names and their descriptors.
  services_by_name: Dict of services names and their descriptors.
  pool: the DescriptorPool this descriptor belongs to.  When not passed to the
    constructor, the global default pool is used.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.FileDescriptor

    def __new__(cls, name, package, options=None,
                serialized_options=None, serialized_pb=None,
                dependencies=None, public_dependencies=None,
                syntax=None, pool=None):
      # FileDescriptor() is called from various places, not only from generated
      # files, to register dynamic proto files and messages.
      # pylint: disable=g-explicit-bool-comparison
      if serialized_pb == &#39;&#39;:
        # Cpp generated code must be linked in if serialized_pb is &#39;&#39;
        try:
          return _message.default_pool.FindFileByName(name)
        except KeyError:
          raise RuntimeError(&#39;Please link in cpp generated lib for %s&#39; % (name))
      elif serialized_pb:
        return _message.default_pool.AddSerializedFile(serialized_pb)
      else:
        return super(FileDescriptor, cls).__new__(cls)

  def __init__(self, name, package, options=None,
               serialized_options=None, serialized_pb=None,
               dependencies=None, public_dependencies=None,
               syntax=None, pool=None):
    &#34;&#34;&#34;Constructor.&#34;&#34;&#34;
    super(FileDescriptor, self).__init__(
        options, serialized_options, &#39;FileOptions&#39;)

    if pool is None:
      from google.protobuf import descriptor_pool
      pool = descriptor_pool.Default()
    self.pool = pool
    self.message_types_by_name = {}
    self.name = name
    self.package = package
    self.syntax = syntax or &#34;proto2&#34;
    self.serialized_pb = serialized_pb

    self.enum_types_by_name = {}
    self.extensions_by_name = {}
    self.services_by_name = {}
    self.dependencies = (dependencies or [])
    self.public_dependencies = (public_dependencies or [])

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.FileDescriptorProto.

    Args:
      proto: An empty descriptor_pb2.FileDescriptorProto.
    &#34;&#34;&#34;
    proto.ParseFromString(self.serialized_pb)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.descriptor.FileDescriptor.CopyToProto"><code class="name flex">
<span>def <span class="ident">CopyToProto</span></span>(<span>self, proto)</span>
</code></dt>
<dd>
<section class="desc"><p>Copies this to a descriptor_pb2.FileDescriptorProto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proto</code></strong></dt>
<dd>An empty descriptor_pb2.FileDescriptorProto.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CopyToProto(self, proto):
  &#34;&#34;&#34;Copies this to a descriptor_pb2.FileDescriptorProto.

  Args:
    proto: An empty descriptor_pb2.FileDescriptorProto.
  &#34;&#34;&#34;
  proto.ParseFromString(self.serialized_pb)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.MethodDescriptor"><code class="flex name class">
<span>class <span class="ident">MethodDescriptor</span></span>
<span>(</span><span>name, full_name, index, containing_service, input_type, output_type, options=None, serialized_options=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a method in a service.</p>
<p>name: (str) Name of the method within the service.
full_name: (str) Full name of method.
index: (int) 0-indexed index of the method inside the service.
containing_service: (ServiceDescriptor) The service that contains this
method.
input_type: The descriptor of the message that this method accepts.
output_type: The descriptor of the message that this method returns.
options: (descriptor_pb2.MethodOptions) Method options message or
None to use default method options.</p>
<p>The arguments are as described in the description of MethodDescriptor
attributes above.</p>
<p>Note that containing_service may be None, and may be set later if necessary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MethodDescriptor(DescriptorBase):

  &#34;&#34;&#34;Descriptor for a method in a service.

  name: (str) Name of the method within the service.
  full_name: (str) Full name of method.
  index: (int) 0-indexed index of the method inside the service.
  containing_service: (ServiceDescriptor) The service that contains this
    method.
  input_type: The descriptor of the message that this method accepts.
  output_type: The descriptor of the message that this method returns.
  options: (descriptor_pb2.MethodOptions) Method options message or
    None to use default method options.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.MethodDescriptor

    def __new__(cls, name, full_name, index, containing_service,
                input_type, output_type, options=None, serialized_options=None):
      _message.Message._CheckCalledFromGeneratedFile()  # pylint: disable=protected-access
      return _message.default_pool.FindMethodByName(full_name)

  def __init__(self, name, full_name, index, containing_service,
               input_type, output_type, options=None, serialized_options=None):
    &#34;&#34;&#34;The arguments are as described in the description of MethodDescriptor
    attributes above.

    Note that containing_service may be None, and may be set later if necessary.
    &#34;&#34;&#34;
    super(MethodDescriptor, self).__init__(
        options, serialized_options, &#39;MethodOptions&#39;)
    self.name = name
    self.full_name = full_name
    self.index = index
    self.containing_service = containing_service
    self.input_type = input_type
    self.output_type = output_type</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.OneofDescriptor"><code class="flex name class">
<span>class <span class="ident">OneofDescriptor</span></span>
<span>(</span><span>name, full_name, index, containing_type, fields, options=None, serialized_options=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a oneof field.</p>
<p>name: (str) Name of the oneof field.
full_name: (str) Full name of the oneof field, including package name.
index: (int) 0-based index giving the order of the oneof field inside
its containing type.
containing_type: (Descriptor) Descriptor of the protocol message
type that contains this field.
Set by the Descriptor constructor
if we're passed into one.
fields: (list of FieldDescriptor) The list of field descriptors this
oneof can contain.</p>
<p>Arguments are as described in the attribute description above.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OneofDescriptor(DescriptorBase):
  &#34;&#34;&#34;Descriptor for a oneof field.

    name: (str) Name of the oneof field.
    full_name: (str) Full name of the oneof field, including package name.
    index: (int) 0-based index giving the order of the oneof field inside
      its containing type.
    containing_type: (Descriptor) Descriptor of the protocol message
      type that contains this field.  Set by the Descriptor constructor
      if we&#39;re passed into one.
    fields: (list of FieldDescriptor) The list of field descriptors this
      oneof can contain.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.OneofDescriptor

    def __new__(
        cls, name, full_name, index, containing_type, fields, options=None,
        serialized_options=None):
      _message.Message._CheckCalledFromGeneratedFile()
      return _message.default_pool.FindOneofByName(full_name)

  def __init__(
      self, name, full_name, index, containing_type, fields, options=None,
      serialized_options=None):
    &#34;&#34;&#34;Arguments are as described in the attribute description above.&#34;&#34;&#34;
    super(OneofDescriptor, self).__init__(
        options, serialized_options, &#39;OneofOptions&#39;)
    self.name = name
    self.full_name = full_name
    self.index = index
    self.containing_type = containing_type
    self.fields = fields</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.ServiceDescriptor"><code class="flex name class">
<span>class <span class="ident">ServiceDescriptor</span></span>
<span>(</span><span>name, full_name, index, methods, options=None, serialized_options=None, file=None, serialized_start=None, serialized_end=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Descriptor for a service.</p>
<p>name: (str) Name of the service.
full_name: (str) Full name of the service, including package name.
index: (int) 0-indexed index giving the order that this services
definition appears withing the .proto file.
methods: (list of MethodDescriptor) List of methods provided by this
service.
methods_by_name: (dict str -&gt; MethodDescriptor) Same MethodDescriptor
objects as in |methods_by_name|, but indexed by "name" attribute in each
MethodDescriptor.
options: (descriptor_pb2.ServiceOptions) Service options message or
None to use default service options.
file: (FileDescriptor) Reference to file info.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>options</code></strong></dt>
<dd>Protocol message options or None
to use default message options.</dd>
<dt><strong><code>options_class_name</code></strong></dt>
<dd>(str) The class name of the above options.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>(str) Name of this protocol message type.</dd>
<dt><strong><code>full_name</code></strong></dt>
<dd>(str) Fully-qualified name of this protocol message type,
which will include protocol "package" name and the name of any
enclosing types.</dd>
<dt><strong><code>file</code></strong></dt>
<dd>(FileDescriptor) Reference to file info.</dd>
<dt><strong><code>containing_type</code></strong></dt>
<dd>if provided, this is a nested descriptor, with this
descriptor as parent, otherwise None.</dd>
<dt><strong><code>serialized_start</code></strong></dt>
<dd>The start index (inclusive) in block in the
file.serialized_pb that describes this descriptor.</dd>
<dt><strong><code>serialized_end</code></strong></dt>
<dd>The end index (exclusive) in block in the
file.serialized_pb that describes this descriptor.</dd>
<dt><strong><code>serialized_options</code></strong></dt>
<dd>Protocol message serilized options or None.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServiceDescriptor(_NestedDescriptorBase):

  &#34;&#34;&#34;Descriptor for a service.

    name: (str) Name of the service.
    full_name: (str) Full name of the service, including package name.
    index: (int) 0-indexed index giving the order that this services
      definition appears withing the .proto file.
    methods: (list of MethodDescriptor) List of methods provided by this
      service.
    methods_by_name: (dict str -&gt; MethodDescriptor) Same MethodDescriptor
      objects as in |methods_by_name|, but indexed by &#34;name&#34; attribute in each
      MethodDescriptor.
    options: (descriptor_pb2.ServiceOptions) Service options message or
      None to use default service options.
    file: (FileDescriptor) Reference to file info.
  &#34;&#34;&#34;

  if _USE_C_DESCRIPTORS:
    _C_DESCRIPTOR_CLASS = _message.ServiceDescriptor

    def __new__(cls, name, full_name, index, methods, options=None,
                serialized_options=None, file=None,  # pylint: disable=redefined-builtin
                serialized_start=None, serialized_end=None):
      _message.Message._CheckCalledFromGeneratedFile()  # pylint: disable=protected-access
      return _message.default_pool.FindServiceByName(full_name)

  def __init__(self, name, full_name, index, methods, options=None,
               serialized_options=None, file=None,  # pylint: disable=redefined-builtin
               serialized_start=None, serialized_end=None):
    super(ServiceDescriptor, self).__init__(
        options, &#39;ServiceOptions&#39;, name, full_name, file,
        None, serialized_start=serialized_start,
        serialized_end=serialized_end, serialized_options=serialized_options)
    self.index = index
    self.methods = methods
    self.methods_by_name = dict((m.name, m) for m in methods)
    # Set the containing service for each method in this service.
    for method in self.methods:
      method.containing_service = self

  def FindMethodByName(self, name):
    &#34;&#34;&#34;Searches for the specified method, and returns its descriptor.&#34;&#34;&#34;
    return self.methods_by_name.get(name, None)

  def CopyToProto(self, proto):
    &#34;&#34;&#34;Copies this to a descriptor_pb2.ServiceDescriptorProto.

    Args:
      proto: An empty descriptor_pb2.ServiceDescriptorProto.
    &#34;&#34;&#34;
    # This function is overridden to give a better doc comment.
    super(ServiceDescriptor, self).CopyToProto(proto)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.descriptor._NestedDescriptorBase</li>
<li><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.descriptor.ServiceDescriptor.CopyToProto"><code class="name flex">
<span>def <span class="ident">CopyToProto</span></span>(<span>self, proto)</span>
</code></dt>
<dd>
<section class="desc"><p>Copies this to a descriptor_pb2.ServiceDescriptorProto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proto</code></strong></dt>
<dd>An empty descriptor_pb2.ServiceDescriptorProto.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CopyToProto(self, proto):
  &#34;&#34;&#34;Copies this to a descriptor_pb2.ServiceDescriptorProto.

  Args:
    proto: An empty descriptor_pb2.ServiceDescriptorProto.
  &#34;&#34;&#34;
  # This function is overridden to give a better doc comment.
  super(ServiceDescriptor, self).CopyToProto(proto)</code></pre>
</details>
</dd>
<dt id="google.protobuf.descriptor.ServiceDescriptor.FindMethodByName"><code class="name flex">
<span>def <span class="ident">FindMethodByName</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Searches for the specified method, and returns its descriptor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FindMethodByName(self, name):
  &#34;&#34;&#34;Searches for the specified method, and returns its descriptor.&#34;&#34;&#34;
  return self.methods_by_name.get(name, None)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.protobuf.descriptor.TypeTransformationError"><code class="flex name class">
<span>class <span class="ident">TypeTransformationError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Error transforming between python proto type and corresponding C++ type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeTransformationError(Error):
  &#34;&#34;&#34;Error transforming between python proto type and corresponding C++ type.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.protobuf.descriptor.Error" href="#google.protobuf.descriptor.Error">Error</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.protobuf" href="index.html">google.protobuf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="google.protobuf.descriptor.MakeDescriptor" href="#google.protobuf.descriptor.MakeDescriptor">MakeDescriptor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.protobuf.descriptor.Descriptor" href="#google.protobuf.descriptor.Descriptor">Descriptor</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.descriptor.Descriptor.CopyToProto" href="#google.protobuf.descriptor.Descriptor.CopyToProto">CopyToProto</a></code></li>
<li><code><a title="google.protobuf.descriptor.Descriptor.EnumValueName" href="#google.protobuf.descriptor.Descriptor.EnumValueName">EnumValueName</a></code></li>
<li><code><a title="google.protobuf.descriptor.Descriptor.fields_by_camelcase_name" href="#google.protobuf.descriptor.Descriptor.fields_by_camelcase_name">fields_by_camelcase_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.DescriptorBase" href="#google.protobuf.descriptor.DescriptorBase">DescriptorBase</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.descriptor.DescriptorBase.GetOptions" href="#google.protobuf.descriptor.DescriptorBase.GetOptions">GetOptions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.DescriptorMetaclass" href="#google.protobuf.descriptor.DescriptorMetaclass">DescriptorMetaclass</a></code></h4>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.EnumDescriptor" href="#google.protobuf.descriptor.EnumDescriptor">EnumDescriptor</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.descriptor.EnumDescriptor.CopyToProto" href="#google.protobuf.descriptor.EnumDescriptor.CopyToProto">CopyToProto</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.EnumValueDescriptor" href="#google.protobuf.descriptor.EnumValueDescriptor">EnumValueDescriptor</a></code></h4>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.Error" href="#google.protobuf.descriptor.Error">Error</a></code></h4>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.FieldDescriptor" href="#google.protobuf.descriptor.FieldDescriptor">FieldDescriptor</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_BOOL" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_BOOL">CPPTYPE_BOOL</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_DOUBLE" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_DOUBLE">CPPTYPE_DOUBLE</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_ENUM" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_ENUM">CPPTYPE_ENUM</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_FLOAT" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_FLOAT">CPPTYPE_FLOAT</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_INT32" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_INT32">CPPTYPE_INT32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_INT64" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_INT64">CPPTYPE_INT64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_MESSAGE" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_MESSAGE">CPPTYPE_MESSAGE</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_STRING" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_STRING">CPPTYPE_STRING</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_UINT32" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_UINT32">CPPTYPE_UINT32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.CPPTYPE_UINT64" href="#google.protobuf.descriptor.FieldDescriptor.CPPTYPE_UINT64">CPPTYPE_UINT64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.FIRST_RESERVED_FIELD_NUMBER" href="#google.protobuf.descriptor.FieldDescriptor.FIRST_RESERVED_FIELD_NUMBER">FIRST_RESERVED_FIELD_NUMBER</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.LABEL_OPTIONAL" href="#google.protobuf.descriptor.FieldDescriptor.LABEL_OPTIONAL">LABEL_OPTIONAL</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.LABEL_REPEATED" href="#google.protobuf.descriptor.FieldDescriptor.LABEL_REPEATED">LABEL_REPEATED</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.LABEL_REQUIRED" href="#google.protobuf.descriptor.FieldDescriptor.LABEL_REQUIRED">LABEL_REQUIRED</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.LAST_RESERVED_FIELD_NUMBER" href="#google.protobuf.descriptor.FieldDescriptor.LAST_RESERVED_FIELD_NUMBER">LAST_RESERVED_FIELD_NUMBER</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.MAX_CPPTYPE" href="#google.protobuf.descriptor.FieldDescriptor.MAX_CPPTYPE">MAX_CPPTYPE</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.MAX_FIELD_NUMBER" href="#google.protobuf.descriptor.FieldDescriptor.MAX_FIELD_NUMBER">MAX_FIELD_NUMBER</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.MAX_LABEL" href="#google.protobuf.descriptor.FieldDescriptor.MAX_LABEL">MAX_LABEL</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.MAX_TYPE" href="#google.protobuf.descriptor.FieldDescriptor.MAX_TYPE">MAX_TYPE</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.ProtoTypeToCppProtoType" href="#google.protobuf.descriptor.FieldDescriptor.ProtoTypeToCppProtoType">ProtoTypeToCppProtoType</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_BOOL" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_BOOL">TYPE_BOOL</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_BYTES" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_BYTES">TYPE_BYTES</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_DOUBLE" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_DOUBLE">TYPE_DOUBLE</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_ENUM" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_ENUM">TYPE_ENUM</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_FIXED32" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_FIXED32">TYPE_FIXED32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_FIXED64" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_FIXED64">TYPE_FIXED64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_FLOAT" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_FLOAT">TYPE_FLOAT</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_GROUP" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_GROUP">TYPE_GROUP</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_INT32" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_INT32">TYPE_INT32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_INT64" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_INT64">TYPE_INT64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_MESSAGE" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_MESSAGE">TYPE_MESSAGE</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_SFIXED32" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_SFIXED32">TYPE_SFIXED32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_SFIXED64" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_SFIXED64">TYPE_SFIXED64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_SINT32" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_SINT32">TYPE_SINT32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_SINT64" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_SINT64">TYPE_SINT64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_STRING" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_STRING">TYPE_STRING</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_UINT32" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_UINT32">TYPE_UINT32</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.TYPE_UINT64" href="#google.protobuf.descriptor.FieldDescriptor.TYPE_UINT64">TYPE_UINT64</a></code></li>
<li><code><a title="google.protobuf.descriptor.FieldDescriptor.camelcase_name" href="#google.protobuf.descriptor.FieldDescriptor.camelcase_name">camelcase_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.FileDescriptor" href="#google.protobuf.descriptor.FileDescriptor">FileDescriptor</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.descriptor.FileDescriptor.CopyToProto" href="#google.protobuf.descriptor.FileDescriptor.CopyToProto">CopyToProto</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.MethodDescriptor" href="#google.protobuf.descriptor.MethodDescriptor">MethodDescriptor</a></code></h4>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.OneofDescriptor" href="#google.protobuf.descriptor.OneofDescriptor">OneofDescriptor</a></code></h4>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.ServiceDescriptor" href="#google.protobuf.descriptor.ServiceDescriptor">ServiceDescriptor</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.descriptor.ServiceDescriptor.CopyToProto" href="#google.protobuf.descriptor.ServiceDescriptor.CopyToProto">CopyToProto</a></code></li>
<li><code><a title="google.protobuf.descriptor.ServiceDescriptor.FindMethodByName" href="#google.protobuf.descriptor.ServiceDescriptor.FindMethodByName">FindMethodByName</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.descriptor.TypeTransformationError" href="#google.protobuf.descriptor.TypeTransformationError">TypeTransformationError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>