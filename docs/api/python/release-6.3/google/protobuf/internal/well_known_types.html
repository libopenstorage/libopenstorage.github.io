<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.protobuf.internal.well_known_types API documentation</title>
<meta name="description" content="Contains well known classes â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.protobuf.internal.well_known_types</code></h1>
</header>
<section id="section-intro">
<p>Contains well known classes.</p>
<p>This files defines well known classes which need extra maintenance including:
- Any
- Duration
- FieldMask
- Struct
- Timestamp</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Protocol Buffers - Google&#39;s data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

&#34;&#34;&#34;Contains well known classes.

This files defines well known classes which need extra maintenance including:
  - Any
  - Duration
  - FieldMask
  - Struct
  - Timestamp
&#34;&#34;&#34;

__author__ = &#39;jieluo@google.com (Jie Luo)&#39;

import calendar
from datetime import datetime
from datetime import timedelta
import six

try:
  # Since python 3
  import collections.abc as collections_abc
except ImportError:
  # Won&#39;t work after python 3.8
  import collections as collections_abc

from google.protobuf.descriptor import FieldDescriptor

_TIMESTAMPFOMAT = &#39;%Y-%m-%dT%H:%M:%S&#39;
_NANOS_PER_SECOND = 1000000000
_NANOS_PER_MILLISECOND = 1000000
_NANOS_PER_MICROSECOND = 1000
_MILLIS_PER_SECOND = 1000
_MICROS_PER_SECOND = 1000000
_SECONDS_PER_DAY = 24 * 3600
_DURATION_SECONDS_MAX = 315576000000


class Any(object):
  &#34;&#34;&#34;Class for Any Message type.&#34;&#34;&#34;

  __slots__ = ()

  def Pack(self, msg, type_url_prefix=&#39;type.googleapis.com/&#39;,
           deterministic=None):
    &#34;&#34;&#34;Packs the specified message into current Any message.&#34;&#34;&#34;
    if len(type_url_prefix) &lt; 1 or type_url_prefix[-1] != &#39;/&#39;:
      self.type_url = &#39;%s/%s&#39; % (type_url_prefix, msg.DESCRIPTOR.full_name)
    else:
      self.type_url = &#39;%s%s&#39; % (type_url_prefix, msg.DESCRIPTOR.full_name)
    self.value = msg.SerializeToString(deterministic=deterministic)

  def Unpack(self, msg):
    &#34;&#34;&#34;Unpacks the current Any message into specified message.&#34;&#34;&#34;
    descriptor = msg.DESCRIPTOR
    if not self.Is(descriptor):
      return False
    msg.ParseFromString(self.value)
    return True

  def TypeName(self):
    &#34;&#34;&#34;Returns the protobuf type name of the inner message.&#34;&#34;&#34;
    # Only last part is to be used: b/25630112
    return self.type_url.split(&#39;/&#39;)[-1]

  def Is(self, descriptor):
    &#34;&#34;&#34;Checks if this Any represents the given protobuf type.&#34;&#34;&#34;
    return &#39;/&#39; in self.type_url and self.TypeName() == descriptor.full_name


_EPOCH_DATETIME = datetime.utcfromtimestamp(0)


class Timestamp(object):
  &#34;&#34;&#34;Class for Timestamp message type.&#34;&#34;&#34;

  __slots__ = ()

  def ToJsonString(self):
    &#34;&#34;&#34;Converts Timestamp to RFC 3339 date string format.

    Returns:
      A string converted from timestamp. The string is always Z-normalized
      and uses 3, 6 or 9 fractional digits as required to represent the
      exact time. Example of the return format: &#39;1972-01-01T10:00:20.021Z&#39;
    &#34;&#34;&#34;
    nanos = self.nanos % _NANOS_PER_SECOND
    total_sec = self.seconds + (self.nanos - nanos) // _NANOS_PER_SECOND
    seconds = total_sec % _SECONDS_PER_DAY
    days = (total_sec - seconds) // _SECONDS_PER_DAY
    dt = datetime(1970, 1, 1) + timedelta(days, seconds)

    result = dt.isoformat()
    if (nanos % 1e9) == 0:
      # If there are 0 fractional digits, the fractional
      # point &#39;.&#39; should be omitted when serializing.
      return result + &#39;Z&#39;
    if (nanos % 1e6) == 0:
      # Serialize 3 fractional digits.
      return result + &#39;.%03dZ&#39; % (nanos / 1e6)
    if (nanos % 1e3) == 0:
      # Serialize 6 fractional digits.
      return result + &#39;.%06dZ&#39; % (nanos / 1e3)
    # Serialize 9 fractional digits.
    return result + &#39;.%09dZ&#39; % nanos

  def FromJsonString(self, value):
    &#34;&#34;&#34;Parse a RFC 3339 date string format to Timestamp.

    Args:
      value: A date string. Any fractional digits (or none) and any offset are
          accepted as long as they fit into nano-seconds precision.
          Example of accepted format: &#39;1972-01-01T10:00:20.021-05:00&#39;

    Raises:
      ValueError: On parsing problems.
    &#34;&#34;&#34;
    timezone_offset = value.find(&#39;Z&#39;)
    if timezone_offset == -1:
      timezone_offset = value.find(&#39;+&#39;)
    if timezone_offset == -1:
      timezone_offset = value.rfind(&#39;-&#39;)
    if timezone_offset == -1:
      raise ValueError(
          &#39;Failed to parse timestamp: missing valid timezone offset.&#39;)
    time_value = value[0:timezone_offset]
    # Parse datetime and nanos.
    point_position = time_value.find(&#39;.&#39;)
    if point_position == -1:
      second_value = time_value
      nano_value = &#39;&#39;
    else:
      second_value = time_value[:point_position]
      nano_value = time_value[point_position + 1:]
    date_object = datetime.strptime(second_value, _TIMESTAMPFOMAT)
    td = date_object - datetime(1970, 1, 1)
    seconds = td.seconds + td.days * _SECONDS_PER_DAY
    if len(nano_value) &gt; 9:
      raise ValueError(
          &#39;Failed to parse Timestamp: nanos {0} more than &#39;
          &#39;9 fractional digits.&#39;.format(nano_value))
    if nano_value:
      nanos = round(float(&#39;0.&#39; + nano_value) * 1e9)
    else:
      nanos = 0
    # Parse timezone offsets.
    if value[timezone_offset] == &#39;Z&#39;:
      if len(value) != timezone_offset + 1:
        raise ValueError(&#39;Failed to parse timestamp: invalid trailing&#39;
                         &#39; data {0}.&#39;.format(value))
    else:
      timezone = value[timezone_offset:]
      pos = timezone.find(&#39;:&#39;)
      if pos == -1:
        raise ValueError(
            &#39;Invalid timezone offset value: {0}.&#39;.format(timezone))
      if timezone[0] == &#39;+&#39;:
        seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
      else:
        seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
    # Set seconds and nanos
    self.seconds = int(seconds)
    self.nanos = int(nanos)

  def GetCurrentTime(self):
    &#34;&#34;&#34;Get the current UTC into Timestamp.&#34;&#34;&#34;
    self.FromDatetime(datetime.utcnow())

  def ToNanoseconds(self):
    &#34;&#34;&#34;Converts Timestamp to nanoseconds since epoch.&#34;&#34;&#34;
    return self.seconds * _NANOS_PER_SECOND + self.nanos

  def ToMicroseconds(self):
    &#34;&#34;&#34;Converts Timestamp to microseconds since epoch.&#34;&#34;&#34;
    return (self.seconds * _MICROS_PER_SECOND +
            self.nanos // _NANOS_PER_MICROSECOND)

  def ToMilliseconds(self):
    &#34;&#34;&#34;Converts Timestamp to milliseconds since epoch.&#34;&#34;&#34;
    return (self.seconds * _MILLIS_PER_SECOND +
            self.nanos // _NANOS_PER_MILLISECOND)

  def ToSeconds(self):
    &#34;&#34;&#34;Converts Timestamp to seconds since epoch.&#34;&#34;&#34;
    return self.seconds

  def FromNanoseconds(self, nanos):
    &#34;&#34;&#34;Converts nanoseconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = nanos // _NANOS_PER_SECOND
    self.nanos = nanos % _NANOS_PER_SECOND

  def FromMicroseconds(self, micros):
    &#34;&#34;&#34;Converts microseconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = micros // _MICROS_PER_SECOND
    self.nanos = (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND

  def FromMilliseconds(self, millis):
    &#34;&#34;&#34;Converts milliseconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = millis // _MILLIS_PER_SECOND
    self.nanos = (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND

  def FromSeconds(self, seconds):
    &#34;&#34;&#34;Converts seconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = seconds
    self.nanos = 0

  def ToDatetime(self):
    &#34;&#34;&#34;Converts Timestamp to datetime.&#34;&#34;&#34;
    return _EPOCH_DATETIME + timedelta(
        seconds=self.seconds, microseconds=_RoundTowardZero(
            self.nanos, _NANOS_PER_MICROSECOND))

  def FromDatetime(self, dt):
    &#34;&#34;&#34;Converts datetime to Timestamp.&#34;&#34;&#34;
    # Using this guide: http://wiki.python.org/moin/WorkingWithTime
    # And this conversion guide: http://docs.python.org/library/time.html

    # Turn the date parameter into a tuple (struct_time) that can then be
    # manipulated into a long value of seconds.  During the conversion from
    # struct_time to long, the source date in UTC, and so it follows that the
    # correct transformation is calendar.timegm()
    self.seconds = calendar.timegm(dt.utctimetuple())
    self.nanos = dt.microsecond * _NANOS_PER_MICROSECOND


class Duration(object):
  &#34;&#34;&#34;Class for Duration message type.&#34;&#34;&#34;

  __slots__ = ()

  def ToJsonString(self):
    &#34;&#34;&#34;Converts Duration to string format.

    Returns:
      A string converted from self. The string format will contains
      3, 6, or 9 fractional digits depending on the precision required to
      represent the exact Duration value. For example: &#34;1s&#34;, &#34;1.010s&#34;,
      &#34;1.000000100s&#34;, &#34;-3.100s&#34;
    &#34;&#34;&#34;
    _CheckDurationValid(self.seconds, self.nanos)
    if self.seconds &lt; 0 or self.nanos &lt; 0:
      result = &#39;-&#39;
      seconds = - self.seconds + int((0 - self.nanos) // 1e9)
      nanos = (0 - self.nanos) % 1e9
    else:
      result = &#39;&#39;
      seconds = self.seconds + int(self.nanos // 1e9)
      nanos = self.nanos % 1e9
    result += &#39;%d&#39; % seconds
    if (nanos % 1e9) == 0:
      # If there are 0 fractional digits, the fractional
      # point &#39;.&#39; should be omitted when serializing.
      return result + &#39;s&#39;
    if (nanos % 1e6) == 0:
      # Serialize 3 fractional digits.
      return result + &#39;.%03ds&#39; % (nanos / 1e6)
    if (nanos % 1e3) == 0:
      # Serialize 6 fractional digits.
      return result + &#39;.%06ds&#39; % (nanos / 1e3)
    # Serialize 9 fractional digits.
    return result + &#39;.%09ds&#39; % nanos

  def FromJsonString(self, value):
    &#34;&#34;&#34;Converts a string to Duration.

    Args:
      value: A string to be converted. The string must end with &#39;s&#39;. Any
          fractional digits (or none) are accepted as long as they fit into
          precision. For example: &#34;1s&#34;, &#34;1.01s&#34;, &#34;1.0000001s&#34;, &#34;-3.100s

    Raises:
      ValueError: On parsing problems.
    &#34;&#34;&#34;
    if len(value) &lt; 1 or value[-1] != &#39;s&#39;:
      raise ValueError(
          &#39;Duration must end with letter &#34;s&#34;: {0}.&#39;.format(value))
    try:
      pos = value.find(&#39;.&#39;)
      if pos == -1:
        seconds = int(value[:-1])
        nanos = 0
      else:
        seconds = int(value[:pos])
        if value[0] == &#39;-&#39;:
          nanos = int(round(float(&#39;-0{0}&#39;.format(value[pos: -1])) *1e9))
        else:
          nanos = int(round(float(&#39;0{0}&#39;.format(value[pos: -1])) *1e9))
      _CheckDurationValid(seconds, nanos)
      self.seconds = seconds
      self.nanos = nanos
    except ValueError as e:
      raise ValueError(
          &#39;Couldn\&#39;t parse duration: {0} : {1}.&#39;.format(value, e))

  def ToNanoseconds(self):
    &#34;&#34;&#34;Converts a Duration to nanoseconds.&#34;&#34;&#34;
    return self.seconds * _NANOS_PER_SECOND + self.nanos

  def ToMicroseconds(self):
    &#34;&#34;&#34;Converts a Duration to microseconds.&#34;&#34;&#34;
    micros = _RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND)
    return self.seconds * _MICROS_PER_SECOND + micros

  def ToMilliseconds(self):
    &#34;&#34;&#34;Converts a Duration to milliseconds.&#34;&#34;&#34;
    millis = _RoundTowardZero(self.nanos, _NANOS_PER_MILLISECOND)
    return self.seconds * _MILLIS_PER_SECOND + millis

  def ToSeconds(self):
    &#34;&#34;&#34;Converts a Duration to seconds.&#34;&#34;&#34;
    return self.seconds

  def FromNanoseconds(self, nanos):
    &#34;&#34;&#34;Converts nanoseconds to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(nanos // _NANOS_PER_SECOND,
                            nanos % _NANOS_PER_SECOND)

  def FromMicroseconds(self, micros):
    &#34;&#34;&#34;Converts microseconds to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(
        micros // _MICROS_PER_SECOND,
        (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND)

  def FromMilliseconds(self, millis):
    &#34;&#34;&#34;Converts milliseconds to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(
        millis // _MILLIS_PER_SECOND,
        (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND)

  def FromSeconds(self, seconds):
    &#34;&#34;&#34;Converts seconds to Duration.&#34;&#34;&#34;
    self.seconds = seconds
    self.nanos = 0

  def ToTimedelta(self):
    &#34;&#34;&#34;Converts Duration to timedelta.&#34;&#34;&#34;
    return timedelta(
        seconds=self.seconds, microseconds=_RoundTowardZero(
            self.nanos, _NANOS_PER_MICROSECOND))

  def FromTimedelta(self, td):
    &#34;&#34;&#34;Converts timedelta to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(td.seconds + td.days * _SECONDS_PER_DAY,
                            td.microseconds * _NANOS_PER_MICROSECOND)

  def _NormalizeDuration(self, seconds, nanos):
    &#34;&#34;&#34;Set Duration by seconds and nanos.&#34;&#34;&#34;
    # Force nanos to be negative if the duration is negative.
    if seconds &lt; 0 and nanos &gt; 0:
      seconds += 1
      nanos -= _NANOS_PER_SECOND
    self.seconds = seconds
    self.nanos = nanos


def _CheckDurationValid(seconds, nanos):
  if seconds &lt; -_DURATION_SECONDS_MAX or seconds &gt; _DURATION_SECONDS_MAX:
    raise ValueError(
        &#39;Duration is not valid: Seconds {0} must be in range &#39;
        &#39;[-315576000000, 315576000000].&#39;.format(seconds))
  if nanos &lt;= -_NANOS_PER_SECOND or nanos &gt;= _NANOS_PER_SECOND:
    raise ValueError(
        &#39;Duration is not valid: Nanos {0} must be in range &#39;
        &#39;[-999999999, 999999999].&#39;.format(nanos))
  if (nanos &lt; 0 and seconds &gt; 0) or (nanos &gt; 0 and seconds &lt; 0):
    raise ValueError(
        &#39;Duration is not valid: Sign mismatch.&#39;)


def _RoundTowardZero(value, divider):
  &#34;&#34;&#34;Truncates the remainder part after division.&#34;&#34;&#34;
  # For some languanges, the sign of the remainder is implementation
  # dependent if any of the operands is negative. Here we enforce
  # &#34;rounded toward zero&#34; semantics. For example, for (-5) / 2 an
  # implementation may give -3 as the result with the remainder being
  # 1. This function ensures we always return -2 (closer to zero).
  result = value // divider
  remainder = value % divider
  if result &lt; 0 and remainder &gt; 0:
    return result + 1
  else:
    return result


class FieldMask(object):
  &#34;&#34;&#34;Class for FieldMask message type.&#34;&#34;&#34;

  __slots__ = ()

  def ToJsonString(self):
    &#34;&#34;&#34;Converts FieldMask to string according to proto3 JSON spec.&#34;&#34;&#34;
    camelcase_paths = []
    for path in self.paths:
      camelcase_paths.append(_SnakeCaseToCamelCase(path))
    return &#39;,&#39;.join(camelcase_paths)

  def FromJsonString(self, value):
    &#34;&#34;&#34;Converts string to FieldMask according to proto3 JSON spec.&#34;&#34;&#34;
    self.Clear()
    if value:
      for path in value.split(&#39;,&#39;):
        self.paths.append(_CamelCaseToSnakeCase(path))

  def IsValidForDescriptor(self, message_descriptor):
    &#34;&#34;&#34;Checks whether the FieldMask is valid for Message Descriptor.&#34;&#34;&#34;
    for path in self.paths:
      if not _IsValidPath(message_descriptor, path):
        return False
    return True

  def AllFieldsFromDescriptor(self, message_descriptor):
    &#34;&#34;&#34;Gets all direct fields of Message Descriptor to FieldMask.&#34;&#34;&#34;
    self.Clear()
    for field in message_descriptor.fields:
      self.paths.append(field.name)

  def CanonicalFormFromMask(self, mask):
    &#34;&#34;&#34;Converts a FieldMask to the canonical form.

    Removes paths that are covered by another path. For example,
    &#34;foo.bar&#34; is covered by &#34;foo&#34; and will be removed if &#34;foo&#34;
    is also in the FieldMask. Then sorts all paths in alphabetical order.

    Args:
      mask: The original FieldMask to be converted.
    &#34;&#34;&#34;
    tree = _FieldMaskTree(mask)
    tree.ToFieldMask(self)

  def Union(self, mask1, mask2):
    &#34;&#34;&#34;Merges mask1 and mask2 into this FieldMask.&#34;&#34;&#34;
    _CheckFieldMaskMessage(mask1)
    _CheckFieldMaskMessage(mask2)
    tree = _FieldMaskTree(mask1)
    tree.MergeFromFieldMask(mask2)
    tree.ToFieldMask(self)

  def Intersect(self, mask1, mask2):
    &#34;&#34;&#34;Intersects mask1 and mask2 into this FieldMask.&#34;&#34;&#34;
    _CheckFieldMaskMessage(mask1)
    _CheckFieldMaskMessage(mask2)
    tree = _FieldMaskTree(mask1)
    intersection = _FieldMaskTree()
    for path in mask2.paths:
      tree.IntersectPath(path, intersection)
    intersection.ToFieldMask(self)

  def MergeMessage(
      self, source, destination,
      replace_message_field=False, replace_repeated_field=False):
    &#34;&#34;&#34;Merges fields specified in FieldMask from source to destination.

    Args:
      source: Source message.
      destination: The destination message to be merged into.
      replace_message_field: Replace message field if True. Merge message
          field if False.
      replace_repeated_field: Replace repeated field if True. Append
          elements of repeated field if False.
    &#34;&#34;&#34;
    tree = _FieldMaskTree(self)
    tree.MergeMessage(
        source, destination, replace_message_field, replace_repeated_field)


def _IsValidPath(message_descriptor, path):
  &#34;&#34;&#34;Checks whether the path is valid for Message Descriptor.&#34;&#34;&#34;
  parts = path.split(&#39;.&#39;)
  last = parts.pop()
  for name in parts:
    field = message_descriptor.fields_by_name.get(name)
    if (field is None or
        field.label == FieldDescriptor.LABEL_REPEATED or
        field.type != FieldDescriptor.TYPE_MESSAGE):
      return False
    message_descriptor = field.message_type
  return last in message_descriptor.fields_by_name


def _CheckFieldMaskMessage(message):
  &#34;&#34;&#34;Raises ValueError if message is not a FieldMask.&#34;&#34;&#34;
  message_descriptor = message.DESCRIPTOR
  if (message_descriptor.name != &#39;FieldMask&#39; or
      message_descriptor.file.name != &#39;google/protobuf/field_mask.proto&#39;):
    raise ValueError(&#39;Message {0} is not a FieldMask.&#39;.format(
        message_descriptor.full_name))


def _SnakeCaseToCamelCase(path_name):
  &#34;&#34;&#34;Converts a path name from snake_case to camelCase.&#34;&#34;&#34;
  result = []
  after_underscore = False
  for c in path_name:
    if c.isupper():
      raise ValueError(
          &#39;Fail to print FieldMask to Json string: Path name &#39;
          &#39;{0} must not contain uppercase letters.&#39;.format(path_name))
    if after_underscore:
      if c.islower():
        result.append(c.upper())
        after_underscore = False
      else:
        raise ValueError(
            &#39;Fail to print FieldMask to Json string: The &#39;
            &#39;character after a &#34;_&#34; must be a lowercase letter &#39;
            &#39;in path name {0}.&#39;.format(path_name))
    elif c == &#39;_&#39;:
      after_underscore = True
    else:
      result += c

  if after_underscore:
    raise ValueError(&#39;Fail to print FieldMask to Json string: Trailing &#34;_&#34; &#39;
                     &#39;in path name {0}.&#39;.format(path_name))
  return &#39;&#39;.join(result)


def _CamelCaseToSnakeCase(path_name):
  &#34;&#34;&#34;Converts a field name from camelCase to snake_case.&#34;&#34;&#34;
  result = []
  for c in path_name:
    if c == &#39;_&#39;:
      raise ValueError(&#39;Fail to parse FieldMask: Path name &#39;
                       &#39;{0} must not contain &#34;_&#34;s.&#39;.format(path_name))
    if c.isupper():
      result += &#39;_&#39;
      result += c.lower()
    else:
      result += c
  return &#39;&#39;.join(result)


class _FieldMaskTree(object):
  &#34;&#34;&#34;Represents a FieldMask in a tree structure.

  For example, given a FieldMask &#34;foo.bar,foo.baz,bar.baz&#34;,
  the FieldMaskTree will be:
      [_root] -+- foo -+- bar
            |       |
            |       +- baz
            |
            +- bar --- baz
  In the tree, each leaf node represents a field path.
  &#34;&#34;&#34;

  __slots__ = (&#39;_root&#39;,)

  def __init__(self, field_mask=None):
    &#34;&#34;&#34;Initializes the tree by FieldMask.&#34;&#34;&#34;
    self._root = {}
    if field_mask:
      self.MergeFromFieldMask(field_mask)

  def MergeFromFieldMask(self, field_mask):
    &#34;&#34;&#34;Merges a FieldMask to the tree.&#34;&#34;&#34;
    for path in field_mask.paths:
      self.AddPath(path)

  def AddPath(self, path):
    &#34;&#34;&#34;Adds a field path into the tree.

    If the field path to add is a sub-path of an existing field path
    in the tree (i.e., a leaf node), it means the tree already matches
    the given path so nothing will be added to the tree. If the path
    matches an existing non-leaf node in the tree, that non-leaf node
    will be turned into a leaf node with all its children removed because
    the path matches all the node&#39;s children. Otherwise, a new path will
    be added.

    Args:
      path: The field path to add.
    &#34;&#34;&#34;
    node = self._root
    for name in path.split(&#39;.&#39;):
      if name not in node:
        node[name] = {}
      elif not node[name]:
        # Pre-existing empty node implies we already have this entire tree.
        return
      node = node[name]
    # Remove any sub-trees we might have had.
    node.clear()

  def ToFieldMask(self, field_mask):
    &#34;&#34;&#34;Converts the tree to a FieldMask.&#34;&#34;&#34;
    field_mask.Clear()
    _AddFieldPaths(self._root, &#39;&#39;, field_mask)

  def IntersectPath(self, path, intersection):
    &#34;&#34;&#34;Calculates the intersection part of a field path with this tree.

    Args:
      path: The field path to calculates.
      intersection: The out tree to record the intersection part.
    &#34;&#34;&#34;
    node = self._root
    for name in path.split(&#39;.&#39;):
      if name not in node:
        return
      elif not node[name]:
        intersection.AddPath(path)
        return
      node = node[name]
    intersection.AddLeafNodes(path, node)

  def AddLeafNodes(self, prefix, node):
    &#34;&#34;&#34;Adds leaf nodes begin with prefix to this tree.&#34;&#34;&#34;
    if not node:
      self.AddPath(prefix)
    for name in node:
      child_path = prefix + &#39;.&#39; + name
      self.AddLeafNodes(child_path, node[name])

  def MergeMessage(
      self, source, destination,
      replace_message, replace_repeated):
    &#34;&#34;&#34;Merge all fields specified by this tree from source to destination.&#34;&#34;&#34;
    _MergeMessage(
        self._root, source, destination, replace_message, replace_repeated)


def _StrConvert(value):
  &#34;&#34;&#34;Converts value to str if it is not.&#34;&#34;&#34;
  # This file is imported by c extension and some methods like ClearField
  # requires string for the field name. py2/py3 has different text
  # type and may use unicode.
  if not isinstance(value, str):
    return value.encode(&#39;utf-8&#39;)
  return value


def _MergeMessage(
    node, source, destination, replace_message, replace_repeated):
  &#34;&#34;&#34;Merge all fields specified by a sub-tree from source to destination.&#34;&#34;&#34;
  source_descriptor = source.DESCRIPTOR
  for name in node:
    child = node[name]
    field = source_descriptor.fields_by_name[name]
    if field is None:
      raise ValueError(&#39;Error: Can\&#39;t find field {0} in message {1}.&#39;.format(
          name, source_descriptor.full_name))
    if child:
      # Sub-paths are only allowed for singular message fields.
      if (field.label == FieldDescriptor.LABEL_REPEATED or
          field.cpp_type != FieldDescriptor.CPPTYPE_MESSAGE):
        raise ValueError(&#39;Error: Field {0} in message {1} is not a singular &#39;
                         &#39;message field and cannot have sub-fields.&#39;.format(
                             name, source_descriptor.full_name))
      if source.HasField(name):
        _MergeMessage(
            child, getattr(source, name), getattr(destination, name),
            replace_message, replace_repeated)
      continue
    if field.label == FieldDescriptor.LABEL_REPEATED:
      if replace_repeated:
        destination.ClearField(_StrConvert(name))
      repeated_source = getattr(source, name)
      repeated_destination = getattr(destination, name)
      repeated_destination.MergeFrom(repeated_source)
    else:
      if field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:
        if replace_message:
          destination.ClearField(_StrConvert(name))
        if source.HasField(name):
          getattr(destination, name).MergeFrom(getattr(source, name))
      else:
        setattr(destination, name, getattr(source, name))


def _AddFieldPaths(node, prefix, field_mask):
  &#34;&#34;&#34;Adds the field paths descended from node to field_mask.&#34;&#34;&#34;
  if not node and prefix:
    field_mask.paths.append(prefix)
    return
  for name in sorted(node):
    if prefix:
      child_path = prefix + &#39;.&#39; + name
    else:
      child_path = name
    _AddFieldPaths(node[name], child_path, field_mask)


_INT_OR_FLOAT = six.integer_types + (float,)


def _SetStructValue(struct_value, value):
  if value is None:
    struct_value.null_value = 0
  elif isinstance(value, bool):
    # Note: this check must come before the number check because in Python
    # True and False are also considered numbers.
    struct_value.bool_value = value
  elif isinstance(value, six.string_types):
    struct_value.string_value = value
  elif isinstance(value, _INT_OR_FLOAT):
    struct_value.number_value = value
  elif isinstance(value, (dict, Struct)):
    struct_value.struct_value.Clear()
    struct_value.struct_value.update(value)
  elif isinstance(value, (list, ListValue)):
    struct_value.list_value.Clear()
    struct_value.list_value.extend(value)
  else:
    raise ValueError(&#39;Unexpected type&#39;)


def _GetStructValue(struct_value):
  which = struct_value.WhichOneof(&#39;kind&#39;)
  if which == &#39;struct_value&#39;:
    return struct_value.struct_value
  elif which == &#39;null_value&#39;:
    return None
  elif which == &#39;number_value&#39;:
    return struct_value.number_value
  elif which == &#39;string_value&#39;:
    return struct_value.string_value
  elif which == &#39;bool_value&#39;:
    return struct_value.bool_value
  elif which == &#39;list_value&#39;:
    return struct_value.list_value
  elif which is None:
    raise ValueError(&#39;Value not set&#39;)


class Struct(object):
  &#34;&#34;&#34;Class for Struct message type.&#34;&#34;&#34;

  __slots__ = ()

  def __getitem__(self, key):
    return _GetStructValue(self.fields[key])

  def __contains__(self, item):
    return item in self.fields

  def __setitem__(self, key, value):
    _SetStructValue(self.fields[key], value)

  def __delitem__(self, key):
    del self.fields[key]

  def __len__(self):
    return len(self.fields)

  def __iter__(self):
    return iter(self.fields)

  def keys(self):  # pylint: disable=invalid-name
    return self.fields.keys()

  def values(self):  # pylint: disable=invalid-name
    return [self[key] for key in self]

  def items(self):  # pylint: disable=invalid-name
    return [(key, self[key]) for key in self]

  def get_or_create_list(self, key):
    &#34;&#34;&#34;Returns a list for this key, creating if it didn&#39;t exist already.&#34;&#34;&#34;
    if not self.fields[key].HasField(&#39;list_value&#39;):
      # Clear will mark list_value modified which will indeed create a list.
      self.fields[key].list_value.Clear()
    return self.fields[key].list_value

  def get_or_create_struct(self, key):
    &#34;&#34;&#34;Returns a struct for this key, creating if it didn&#39;t exist already.&#34;&#34;&#34;
    if not self.fields[key].HasField(&#39;struct_value&#39;):
      # Clear will mark struct_value modified which will indeed create a struct.
      self.fields[key].struct_value.Clear()
    return self.fields[key].struct_value

  def update(self, dictionary):  # pylint: disable=invalid-name
    for key, value in dictionary.items():
      _SetStructValue(self.fields[key], value)

collections_abc.MutableMapping.register(Struct)


class ListValue(object):
  &#34;&#34;&#34;Class for ListValue message type.&#34;&#34;&#34;

  __slots__ = ()

  def __len__(self):
    return len(self.values)

  def append(self, value):
    _SetStructValue(self.values.add(), value)

  def extend(self, elem_seq):
    for value in elem_seq:
      self.append(value)

  def __getitem__(self, index):
    &#34;&#34;&#34;Retrieves item by the specified index.&#34;&#34;&#34;
    return _GetStructValue(self.values.__getitem__(index))

  def __setitem__(self, index, value):
    _SetStructValue(self.values.__getitem__(index), value)

  def __delitem__(self, key):
    del self.values[key]

  def items(self):
    for i in range(len(self)):
      yield self[i]

  def add_struct(self):
    &#34;&#34;&#34;Appends and returns a struct value as the next value in the list.&#34;&#34;&#34;
    struct_value = self.values.add().struct_value
    # Clear will mark struct_value modified which will indeed create a struct.
    struct_value.Clear()
    return struct_value

  def add_list(self):
    &#34;&#34;&#34;Appends and returns a list value as the next value in the list.&#34;&#34;&#34;
    list_value = self.values.add().list_value
    # Clear will mark list_value modified which will indeed create a list.
    list_value.Clear()
    return list_value

collections_abc.MutableSequence.register(ListValue)


WKTBASES = {
    &#39;google.protobuf.Any&#39;: Any,
    &#39;google.protobuf.Duration&#39;: Duration,
    &#39;google.protobuf.FieldMask&#39;: FieldMask,
    &#39;google.protobuf.ListValue&#39;: ListValue,
    &#39;google.protobuf.Struct&#39;: Struct,
    &#39;google.protobuf.Timestamp&#39;: Timestamp,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.protobuf.internal.well_known_types.Any"><code class="flex name class">
<span>class <span class="ident">Any</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for Any Message type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(object):
  &#34;&#34;&#34;Class for Any Message type.&#34;&#34;&#34;

  __slots__ = ()

  def Pack(self, msg, type_url_prefix=&#39;type.googleapis.com/&#39;,
           deterministic=None):
    &#34;&#34;&#34;Packs the specified message into current Any message.&#34;&#34;&#34;
    if len(type_url_prefix) &lt; 1 or type_url_prefix[-1] != &#39;/&#39;:
      self.type_url = &#39;%s/%s&#39; % (type_url_prefix, msg.DESCRIPTOR.full_name)
    else:
      self.type_url = &#39;%s%s&#39; % (type_url_prefix, msg.DESCRIPTOR.full_name)
    self.value = msg.SerializeToString(deterministic=deterministic)

  def Unpack(self, msg):
    &#34;&#34;&#34;Unpacks the current Any message into specified message.&#34;&#34;&#34;
    descriptor = msg.DESCRIPTOR
    if not self.Is(descriptor):
      return False
    msg.ParseFromString(self.value)
    return True

  def TypeName(self):
    &#34;&#34;&#34;Returns the protobuf type name of the inner message.&#34;&#34;&#34;
    # Only last part is to be used: b/25630112
    return self.type_url.split(&#39;/&#39;)[-1]

  def Is(self, descriptor):
    &#34;&#34;&#34;Checks if this Any represents the given protobuf type.&#34;&#34;&#34;
    return &#39;/&#39; in self.type_url and self.TypeName() == descriptor.full_name</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.any_pb2.Any" href="../any_pb2.html#google.protobuf.any_pb2.Any">Any</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.well_known_types.Any.Is"><code class="name flex">
<span>def <span class="ident">Is</span></span>(<span>self, descriptor)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if this Any represents the given protobuf type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Is(self, descriptor):
  &#34;&#34;&#34;Checks if this Any represents the given protobuf type.&#34;&#34;&#34;
  return &#39;/&#39; in self.type_url and self.TypeName() == descriptor.full_name</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Any.Pack"><code class="name flex">
<span>def <span class="ident">Pack</span></span>(<span>self, msg, type_url_prefix='type.googleapis.com/', deterministic=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Packs the specified message into current Any message.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Pack(self, msg, type_url_prefix=&#39;type.googleapis.com/&#39;,
         deterministic=None):
  &#34;&#34;&#34;Packs the specified message into current Any message.&#34;&#34;&#34;
  if len(type_url_prefix) &lt; 1 or type_url_prefix[-1] != &#39;/&#39;:
    self.type_url = &#39;%s/%s&#39; % (type_url_prefix, msg.DESCRIPTOR.full_name)
  else:
    self.type_url = &#39;%s%s&#39; % (type_url_prefix, msg.DESCRIPTOR.full_name)
  self.value = msg.SerializeToString(deterministic=deterministic)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Any.TypeName"><code class="name flex">
<span>def <span class="ident">TypeName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the protobuf type name of the inner message.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TypeName(self):
  &#34;&#34;&#34;Returns the protobuf type name of the inner message.&#34;&#34;&#34;
  # Only last part is to be used: b/25630112
  return self.type_url.split(&#39;/&#39;)[-1]</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Any.Unpack"><code class="name flex">
<span>def <span class="ident">Unpack</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<section class="desc"><p>Unpacks the current Any message into specified message.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Unpack(self, msg):
  &#34;&#34;&#34;Unpacks the current Any message into specified message.&#34;&#34;&#34;
  descriptor = msg.DESCRIPTOR
  if not self.Is(descriptor):
    return False
  msg.ParseFromString(self.value)
  return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration"><code class="flex name class">
<span>class <span class="ident">Duration</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for Duration message type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Duration(object):
  &#34;&#34;&#34;Class for Duration message type.&#34;&#34;&#34;

  __slots__ = ()

  def ToJsonString(self):
    &#34;&#34;&#34;Converts Duration to string format.

    Returns:
      A string converted from self. The string format will contains
      3, 6, or 9 fractional digits depending on the precision required to
      represent the exact Duration value. For example: &#34;1s&#34;, &#34;1.010s&#34;,
      &#34;1.000000100s&#34;, &#34;-3.100s&#34;
    &#34;&#34;&#34;
    _CheckDurationValid(self.seconds, self.nanos)
    if self.seconds &lt; 0 or self.nanos &lt; 0:
      result = &#39;-&#39;
      seconds = - self.seconds + int((0 - self.nanos) // 1e9)
      nanos = (0 - self.nanos) % 1e9
    else:
      result = &#39;&#39;
      seconds = self.seconds + int(self.nanos // 1e9)
      nanos = self.nanos % 1e9
    result += &#39;%d&#39; % seconds
    if (nanos % 1e9) == 0:
      # If there are 0 fractional digits, the fractional
      # point &#39;.&#39; should be omitted when serializing.
      return result + &#39;s&#39;
    if (nanos % 1e6) == 0:
      # Serialize 3 fractional digits.
      return result + &#39;.%03ds&#39; % (nanos / 1e6)
    if (nanos % 1e3) == 0:
      # Serialize 6 fractional digits.
      return result + &#39;.%06ds&#39; % (nanos / 1e3)
    # Serialize 9 fractional digits.
    return result + &#39;.%09ds&#39; % nanos

  def FromJsonString(self, value):
    &#34;&#34;&#34;Converts a string to Duration.

    Args:
      value: A string to be converted. The string must end with &#39;s&#39;. Any
          fractional digits (or none) are accepted as long as they fit into
          precision. For example: &#34;1s&#34;, &#34;1.01s&#34;, &#34;1.0000001s&#34;, &#34;-3.100s

    Raises:
      ValueError: On parsing problems.
    &#34;&#34;&#34;
    if len(value) &lt; 1 or value[-1] != &#39;s&#39;:
      raise ValueError(
          &#39;Duration must end with letter &#34;s&#34;: {0}.&#39;.format(value))
    try:
      pos = value.find(&#39;.&#39;)
      if pos == -1:
        seconds = int(value[:-1])
        nanos = 0
      else:
        seconds = int(value[:pos])
        if value[0] == &#39;-&#39;:
          nanos = int(round(float(&#39;-0{0}&#39;.format(value[pos: -1])) *1e9))
        else:
          nanos = int(round(float(&#39;0{0}&#39;.format(value[pos: -1])) *1e9))
      _CheckDurationValid(seconds, nanos)
      self.seconds = seconds
      self.nanos = nanos
    except ValueError as e:
      raise ValueError(
          &#39;Couldn\&#39;t parse duration: {0} : {1}.&#39;.format(value, e))

  def ToNanoseconds(self):
    &#34;&#34;&#34;Converts a Duration to nanoseconds.&#34;&#34;&#34;
    return self.seconds * _NANOS_PER_SECOND + self.nanos

  def ToMicroseconds(self):
    &#34;&#34;&#34;Converts a Duration to microseconds.&#34;&#34;&#34;
    micros = _RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND)
    return self.seconds * _MICROS_PER_SECOND + micros

  def ToMilliseconds(self):
    &#34;&#34;&#34;Converts a Duration to milliseconds.&#34;&#34;&#34;
    millis = _RoundTowardZero(self.nanos, _NANOS_PER_MILLISECOND)
    return self.seconds * _MILLIS_PER_SECOND + millis

  def ToSeconds(self):
    &#34;&#34;&#34;Converts a Duration to seconds.&#34;&#34;&#34;
    return self.seconds

  def FromNanoseconds(self, nanos):
    &#34;&#34;&#34;Converts nanoseconds to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(nanos // _NANOS_PER_SECOND,
                            nanos % _NANOS_PER_SECOND)

  def FromMicroseconds(self, micros):
    &#34;&#34;&#34;Converts microseconds to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(
        micros // _MICROS_PER_SECOND,
        (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND)

  def FromMilliseconds(self, millis):
    &#34;&#34;&#34;Converts milliseconds to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(
        millis // _MILLIS_PER_SECOND,
        (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND)

  def FromSeconds(self, seconds):
    &#34;&#34;&#34;Converts seconds to Duration.&#34;&#34;&#34;
    self.seconds = seconds
    self.nanos = 0

  def ToTimedelta(self):
    &#34;&#34;&#34;Converts Duration to timedelta.&#34;&#34;&#34;
    return timedelta(
        seconds=self.seconds, microseconds=_RoundTowardZero(
            self.nanos, _NANOS_PER_MICROSECOND))

  def FromTimedelta(self, td):
    &#34;&#34;&#34;Converts timedelta to Duration.&#34;&#34;&#34;
    self._NormalizeDuration(td.seconds + td.days * _SECONDS_PER_DAY,
                            td.microseconds * _NANOS_PER_MICROSECOND)

  def _NormalizeDuration(self, seconds, nanos):
    &#34;&#34;&#34;Set Duration by seconds and nanos.&#34;&#34;&#34;
    # Force nanos to be negative if the duration is negative.
    if seconds &lt; 0 and nanos &gt; 0:
      seconds += 1
      nanos -= _NANOS_PER_SECOND
    self.seconds = seconds
    self.nanos = nanos</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.duration_pb2.Duration" href="../duration_pb2.html#google.protobuf.duration_pb2.Duration">Duration</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.well_known_types.Duration.FromJsonString"><code class="name flex">
<span>def <span class="ident">FromJsonString</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a string to Duration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>A string to be converted. The string must end with 's'. Any
fractional digits (or none) are accepted as long as they fit into
precision. For example: "1s", "1.01s", "1.0000001s", "-3.100s</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>On parsing problems.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromJsonString(self, value):
  &#34;&#34;&#34;Converts a string to Duration.

  Args:
    value: A string to be converted. The string must end with &#39;s&#39;. Any
        fractional digits (or none) are accepted as long as they fit into
        precision. For example: &#34;1s&#34;, &#34;1.01s&#34;, &#34;1.0000001s&#34;, &#34;-3.100s

  Raises:
    ValueError: On parsing problems.
  &#34;&#34;&#34;
  if len(value) &lt; 1 or value[-1] != &#39;s&#39;:
    raise ValueError(
        &#39;Duration must end with letter &#34;s&#34;: {0}.&#39;.format(value))
  try:
    pos = value.find(&#39;.&#39;)
    if pos == -1:
      seconds = int(value[:-1])
      nanos = 0
    else:
      seconds = int(value[:pos])
      if value[0] == &#39;-&#39;:
        nanos = int(round(float(&#39;-0{0}&#39;.format(value[pos: -1])) *1e9))
      else:
        nanos = int(round(float(&#39;0{0}&#39;.format(value[pos: -1])) *1e9))
    _CheckDurationValid(seconds, nanos)
    self.seconds = seconds
    self.nanos = nanos
  except ValueError as e:
    raise ValueError(
        &#39;Couldn\&#39;t parse duration: {0} : {1}.&#39;.format(value, e))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.FromMicroseconds"><code class="name flex">
<span>def <span class="ident">FromMicroseconds</span></span>(<span>self, micros)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts microseconds to Duration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromMicroseconds(self, micros):
  &#34;&#34;&#34;Converts microseconds to Duration.&#34;&#34;&#34;
  self._NormalizeDuration(
      micros // _MICROS_PER_SECOND,
      (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.FromMilliseconds"><code class="name flex">
<span>def <span class="ident">FromMilliseconds</span></span>(<span>self, millis)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts milliseconds to Duration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromMilliseconds(self, millis):
  &#34;&#34;&#34;Converts milliseconds to Duration.&#34;&#34;&#34;
  self._NormalizeDuration(
      millis // _MILLIS_PER_SECOND,
      (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.FromNanoseconds"><code class="name flex">
<span>def <span class="ident">FromNanoseconds</span></span>(<span>self, nanos)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts nanoseconds to Duration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromNanoseconds(self, nanos):
  &#34;&#34;&#34;Converts nanoseconds to Duration.&#34;&#34;&#34;
  self._NormalizeDuration(nanos // _NANOS_PER_SECOND,
                          nanos % _NANOS_PER_SECOND)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.FromSeconds"><code class="name flex">
<span>def <span class="ident">FromSeconds</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts seconds to Duration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromSeconds(self, seconds):
  &#34;&#34;&#34;Converts seconds to Duration.&#34;&#34;&#34;
  self.seconds = seconds
  self.nanos = 0</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.FromTimedelta"><code class="name flex">
<span>def <span class="ident">FromTimedelta</span></span>(<span>self, td)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts timedelta to Duration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromTimedelta(self, td):
  &#34;&#34;&#34;Converts timedelta to Duration.&#34;&#34;&#34;
  self._NormalizeDuration(td.seconds + td.days * _SECONDS_PER_DAY,
                          td.microseconds * _NANOS_PER_MICROSECOND)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.ToJsonString"><code class="name flex">
<span>def <span class="ident">ToJsonString</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Duration to string format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>string</code> <code>converted</code> <code>from</code> <code>self.</code> <code>The</code> <code>string</code> <code>format</code> <code>will</code> <code>contains</code></dt>
<dd>&nbsp;</dd>
<dt><code>3</code>, <code>6</code>, or <code>9</code> <code>fractional</code> <code>digits</code> <code>depending</code> <code>on</code> <code>the</code> <code>precision</code> <code>required</code> <code>to</code></dt>
<dd>&nbsp;</dd>
<dt><code>represent</code> <code>the</code> <code>exact</code> <a title="google.protobuf.internal.well_known_types.Duration" href="#google.protobuf.internal.well_known_types.Duration"><code>Duration</code></a> <code>value.</code> <code>For</code> <code>example</code>: <code>"1s"</code>, <code>"1.010s"</code>,</dt>
<dd>&nbsp;</dd>
</dl>
<p>"1.000000100s", "-3.100s"</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToJsonString(self):
  &#34;&#34;&#34;Converts Duration to string format.

  Returns:
    A string converted from self. The string format will contains
    3, 6, or 9 fractional digits depending on the precision required to
    represent the exact Duration value. For example: &#34;1s&#34;, &#34;1.010s&#34;,
    &#34;1.000000100s&#34;, &#34;-3.100s&#34;
  &#34;&#34;&#34;
  _CheckDurationValid(self.seconds, self.nanos)
  if self.seconds &lt; 0 or self.nanos &lt; 0:
    result = &#39;-&#39;
    seconds = - self.seconds + int((0 - self.nanos) // 1e9)
    nanos = (0 - self.nanos) % 1e9
  else:
    result = &#39;&#39;
    seconds = self.seconds + int(self.nanos // 1e9)
    nanos = self.nanos % 1e9
  result += &#39;%d&#39; % seconds
  if (nanos % 1e9) == 0:
    # If there are 0 fractional digits, the fractional
    # point &#39;.&#39; should be omitted when serializing.
    return result + &#39;s&#39;
  if (nanos % 1e6) == 0:
    # Serialize 3 fractional digits.
    return result + &#39;.%03ds&#39; % (nanos / 1e6)
  if (nanos % 1e3) == 0:
    # Serialize 6 fractional digits.
    return result + &#39;.%06ds&#39; % (nanos / 1e3)
  # Serialize 9 fractional digits.
  return result + &#39;.%09ds&#39; % nanos</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.ToMicroseconds"><code class="name flex">
<span>def <span class="ident">ToMicroseconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a Duration to microseconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToMicroseconds(self):
  &#34;&#34;&#34;Converts a Duration to microseconds.&#34;&#34;&#34;
  micros = _RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND)
  return self.seconds * _MICROS_PER_SECOND + micros</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.ToMilliseconds"><code class="name flex">
<span>def <span class="ident">ToMilliseconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a Duration to milliseconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToMilliseconds(self):
  &#34;&#34;&#34;Converts a Duration to milliseconds.&#34;&#34;&#34;
  millis = _RoundTowardZero(self.nanos, _NANOS_PER_MILLISECOND)
  return self.seconds * _MILLIS_PER_SECOND + millis</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.ToNanoseconds"><code class="name flex">
<span>def <span class="ident">ToNanoseconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a Duration to nanoseconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToNanoseconds(self):
  &#34;&#34;&#34;Converts a Duration to nanoseconds.&#34;&#34;&#34;
  return self.seconds * _NANOS_PER_SECOND + self.nanos</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.ToSeconds"><code class="name flex">
<span>def <span class="ident">ToSeconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a Duration to seconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToSeconds(self):
  &#34;&#34;&#34;Converts a Duration to seconds.&#34;&#34;&#34;
  return self.seconds</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Duration.ToTimedelta"><code class="name flex">
<span>def <span class="ident">ToTimedelta</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Duration to timedelta.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToTimedelta(self):
  &#34;&#34;&#34;Converts Duration to timedelta.&#34;&#34;&#34;
  return timedelta(
      seconds=self.seconds, microseconds=_RoundTowardZero(
          self.nanos, _NANOS_PER_MICROSECOND))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask"><code class="flex name class">
<span>class <span class="ident">FieldMask</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for FieldMask message type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldMask(object):
  &#34;&#34;&#34;Class for FieldMask message type.&#34;&#34;&#34;

  __slots__ = ()

  def ToJsonString(self):
    &#34;&#34;&#34;Converts FieldMask to string according to proto3 JSON spec.&#34;&#34;&#34;
    camelcase_paths = []
    for path in self.paths:
      camelcase_paths.append(_SnakeCaseToCamelCase(path))
    return &#39;,&#39;.join(camelcase_paths)

  def FromJsonString(self, value):
    &#34;&#34;&#34;Converts string to FieldMask according to proto3 JSON spec.&#34;&#34;&#34;
    self.Clear()
    if value:
      for path in value.split(&#39;,&#39;):
        self.paths.append(_CamelCaseToSnakeCase(path))

  def IsValidForDescriptor(self, message_descriptor):
    &#34;&#34;&#34;Checks whether the FieldMask is valid for Message Descriptor.&#34;&#34;&#34;
    for path in self.paths:
      if not _IsValidPath(message_descriptor, path):
        return False
    return True

  def AllFieldsFromDescriptor(self, message_descriptor):
    &#34;&#34;&#34;Gets all direct fields of Message Descriptor to FieldMask.&#34;&#34;&#34;
    self.Clear()
    for field in message_descriptor.fields:
      self.paths.append(field.name)

  def CanonicalFormFromMask(self, mask):
    &#34;&#34;&#34;Converts a FieldMask to the canonical form.

    Removes paths that are covered by another path. For example,
    &#34;foo.bar&#34; is covered by &#34;foo&#34; and will be removed if &#34;foo&#34;
    is also in the FieldMask. Then sorts all paths in alphabetical order.

    Args:
      mask: The original FieldMask to be converted.
    &#34;&#34;&#34;
    tree = _FieldMaskTree(mask)
    tree.ToFieldMask(self)

  def Union(self, mask1, mask2):
    &#34;&#34;&#34;Merges mask1 and mask2 into this FieldMask.&#34;&#34;&#34;
    _CheckFieldMaskMessage(mask1)
    _CheckFieldMaskMessage(mask2)
    tree = _FieldMaskTree(mask1)
    tree.MergeFromFieldMask(mask2)
    tree.ToFieldMask(self)

  def Intersect(self, mask1, mask2):
    &#34;&#34;&#34;Intersects mask1 and mask2 into this FieldMask.&#34;&#34;&#34;
    _CheckFieldMaskMessage(mask1)
    _CheckFieldMaskMessage(mask2)
    tree = _FieldMaskTree(mask1)
    intersection = _FieldMaskTree()
    for path in mask2.paths:
      tree.IntersectPath(path, intersection)
    intersection.ToFieldMask(self)

  def MergeMessage(
      self, source, destination,
      replace_message_field=False, replace_repeated_field=False):
    &#34;&#34;&#34;Merges fields specified in FieldMask from source to destination.

    Args:
      source: Source message.
      destination: The destination message to be merged into.
      replace_message_field: Replace message field if True. Merge message
          field if False.
      replace_repeated_field: Replace repeated field if True. Append
          elements of repeated field if False.
    &#34;&#34;&#34;
    tree = _FieldMaskTree(self)
    tree.MergeMessage(
        source, destination, replace_message_field, replace_repeated_field)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.field_mask_pb2.FieldMask" href="../field_mask_pb2.html#google.protobuf.field_mask_pb2.FieldMask">FieldMask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.well_known_types.FieldMask.AllFieldsFromDescriptor"><code class="name flex">
<span>def <span class="ident">AllFieldsFromDescriptor</span></span>(<span>self, message_descriptor)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets all direct fields of Message Descriptor to FieldMask.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AllFieldsFromDescriptor(self, message_descriptor):
  &#34;&#34;&#34;Gets all direct fields of Message Descriptor to FieldMask.&#34;&#34;&#34;
  self.Clear()
  for field in message_descriptor.fields:
    self.paths.append(field.name)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.CanonicalFormFromMask"><code class="name flex">
<span>def <span class="ident">CanonicalFormFromMask</span></span>(<span>self, mask)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts a FieldMask to the canonical form.</p>
<p>Removes paths that are covered by another path. For example,
"foo.bar" is covered by "foo" and will be removed if "foo"
is also in the FieldMask. Then sorts all paths in alphabetical order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mask</code></strong></dt>
<dd>The original FieldMask to be converted.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CanonicalFormFromMask(self, mask):
  &#34;&#34;&#34;Converts a FieldMask to the canonical form.

  Removes paths that are covered by another path. For example,
  &#34;foo.bar&#34; is covered by &#34;foo&#34; and will be removed if &#34;foo&#34;
  is also in the FieldMask. Then sorts all paths in alphabetical order.

  Args:
    mask: The original FieldMask to be converted.
  &#34;&#34;&#34;
  tree = _FieldMaskTree(mask)
  tree.ToFieldMask(self)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.FromJsonString"><code class="name flex">
<span>def <span class="ident">FromJsonString</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts string to FieldMask according to proto3 JSON spec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromJsonString(self, value):
  &#34;&#34;&#34;Converts string to FieldMask according to proto3 JSON spec.&#34;&#34;&#34;
  self.Clear()
  if value:
    for path in value.split(&#39;,&#39;):
      self.paths.append(_CamelCaseToSnakeCase(path))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.Intersect"><code class="name flex">
<span>def <span class="ident">Intersect</span></span>(<span>self, mask1, mask2)</span>
</code></dt>
<dd>
<section class="desc"><p>Intersects mask1 and mask2 into this FieldMask.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Intersect(self, mask1, mask2):
  &#34;&#34;&#34;Intersects mask1 and mask2 into this FieldMask.&#34;&#34;&#34;
  _CheckFieldMaskMessage(mask1)
  _CheckFieldMaskMessage(mask2)
  tree = _FieldMaskTree(mask1)
  intersection = _FieldMaskTree()
  for path in mask2.paths:
    tree.IntersectPath(path, intersection)
  intersection.ToFieldMask(self)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.IsValidForDescriptor"><code class="name flex">
<span>def <span class="ident">IsValidForDescriptor</span></span>(<span>self, message_descriptor)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether the FieldMask is valid for Message Descriptor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsValidForDescriptor(self, message_descriptor):
  &#34;&#34;&#34;Checks whether the FieldMask is valid for Message Descriptor.&#34;&#34;&#34;
  for path in self.paths:
    if not _IsValidPath(message_descriptor, path):
      return False
  return True</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.MergeMessage"><code class="name flex">
<span>def <span class="ident">MergeMessage</span></span>(<span>self, source, destination, replace_message_field=False, replace_repeated_field=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Merges fields specified in FieldMask from source to destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>Source message.</dd>
<dt><strong><code>destination</code></strong></dt>
<dd>The destination message to be merged into.</dd>
<dt><strong><code>replace_message_field</code></strong></dt>
<dd>Replace message field if True. Merge message
field if False.</dd>
<dt><strong><code>replace_repeated_field</code></strong></dt>
<dd>Replace repeated field if True. Append
elements of repeated field if False.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MergeMessage(
    self, source, destination,
    replace_message_field=False, replace_repeated_field=False):
  &#34;&#34;&#34;Merges fields specified in FieldMask from source to destination.

  Args:
    source: Source message.
    destination: The destination message to be merged into.
    replace_message_field: Replace message field if True. Merge message
        field if False.
    replace_repeated_field: Replace repeated field if True. Append
        elements of repeated field if False.
  &#34;&#34;&#34;
  tree = _FieldMaskTree(self)
  tree.MergeMessage(
      source, destination, replace_message_field, replace_repeated_field)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.ToJsonString"><code class="name flex">
<span>def <span class="ident">ToJsonString</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts FieldMask to string according to proto3 JSON spec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToJsonString(self):
  &#34;&#34;&#34;Converts FieldMask to string according to proto3 JSON spec.&#34;&#34;&#34;
  camelcase_paths = []
  for path in self.paths:
    camelcase_paths.append(_SnakeCaseToCamelCase(path))
  return &#39;,&#39;.join(camelcase_paths)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.FieldMask.Union"><code class="name flex">
<span>def <span class="ident">Union</span></span>(<span>self, mask1, mask2)</span>
</code></dt>
<dd>
<section class="desc"><p>Merges mask1 and mask2 into this FieldMask.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Union(self, mask1, mask2):
  &#34;&#34;&#34;Merges mask1 and mask2 into this FieldMask.&#34;&#34;&#34;
  _CheckFieldMaskMessage(mask1)
  _CheckFieldMaskMessage(mask2)
  tree = _FieldMaskTree(mask1)
  tree.MergeFromFieldMask(mask2)
  tree.ToFieldMask(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.well_known_types.ListValue"><code class="flex name class">
<span>class <span class="ident">ListValue</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for ListValue message type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListValue(object):
  &#34;&#34;&#34;Class for ListValue message type.&#34;&#34;&#34;

  __slots__ = ()

  def __len__(self):
    return len(self.values)

  def append(self, value):
    _SetStructValue(self.values.add(), value)

  def extend(self, elem_seq):
    for value in elem_seq:
      self.append(value)

  def __getitem__(self, index):
    &#34;&#34;&#34;Retrieves item by the specified index.&#34;&#34;&#34;
    return _GetStructValue(self.values.__getitem__(index))

  def __setitem__(self, index, value):
    _SetStructValue(self.values.__getitem__(index), value)

  def __delitem__(self, key):
    del self.values[key]

  def items(self):
    for i in range(len(self)):
      yield self[i]

  def add_struct(self):
    &#34;&#34;&#34;Appends and returns a struct value as the next value in the list.&#34;&#34;&#34;
    struct_value = self.values.add().struct_value
    # Clear will mark struct_value modified which will indeed create a struct.
    struct_value.Clear()
    return struct_value

  def add_list(self):
    &#34;&#34;&#34;Appends and returns a list value as the next value in the list.&#34;&#34;&#34;
    list_value = self.values.add().list_value
    # Clear will mark list_value modified which will indeed create a list.
    list_value.Clear()
    return list_value</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.struct_pb2.ListValue" href="../struct_pb2.html#google.protobuf.struct_pb2.ListValue">ListValue</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.well_known_types.ListValue.add_list"><code class="name flex">
<span>def <span class="ident">add_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Appends and returns a list value as the next value in the list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_list(self):
  &#34;&#34;&#34;Appends and returns a list value as the next value in the list.&#34;&#34;&#34;
  list_value = self.values.add().list_value
  # Clear will mark list_value modified which will indeed create a list.
  list_value.Clear()
  return list_value</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.ListValue.add_struct"><code class="name flex">
<span>def <span class="ident">add_struct</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Appends and returns a struct value as the next value in the list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_struct(self):
  &#34;&#34;&#34;Appends and returns a struct value as the next value in the list.&#34;&#34;&#34;
  struct_value = self.values.add().struct_value
  # Clear will mark struct_value modified which will indeed create a struct.
  struct_value.Clear()
  return struct_value</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.ListValue.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value):
  _SetStructValue(self.values.add(), value)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.ListValue.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, elem_seq)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, elem_seq):
  for value in elem_seq:
    self.append(value)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.ListValue.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
  for i in range(len(self)):
    yield self[i]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.well_known_types.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for Struct message type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(object):
  &#34;&#34;&#34;Class for Struct message type.&#34;&#34;&#34;

  __slots__ = ()

  def __getitem__(self, key):
    return _GetStructValue(self.fields[key])

  def __contains__(self, item):
    return item in self.fields

  def __setitem__(self, key, value):
    _SetStructValue(self.fields[key], value)

  def __delitem__(self, key):
    del self.fields[key]

  def __len__(self):
    return len(self.fields)

  def __iter__(self):
    return iter(self.fields)

  def keys(self):  # pylint: disable=invalid-name
    return self.fields.keys()

  def values(self):  # pylint: disable=invalid-name
    return [self[key] for key in self]

  def items(self):  # pylint: disable=invalid-name
    return [(key, self[key]) for key in self]

  def get_or_create_list(self, key):
    &#34;&#34;&#34;Returns a list for this key, creating if it didn&#39;t exist already.&#34;&#34;&#34;
    if not self.fields[key].HasField(&#39;list_value&#39;):
      # Clear will mark list_value modified which will indeed create a list.
      self.fields[key].list_value.Clear()
    return self.fields[key].list_value

  def get_or_create_struct(self, key):
    &#34;&#34;&#34;Returns a struct for this key, creating if it didn&#39;t exist already.&#34;&#34;&#34;
    if not self.fields[key].HasField(&#39;struct_value&#39;):
      # Clear will mark struct_value modified which will indeed create a struct.
      self.fields[key].struct_value.Clear()
    return self.fields[key].struct_value

  def update(self, dictionary):  # pylint: disable=invalid-name
    for key, value in dictionary.items():
      _SetStructValue(self.fields[key], value)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.struct_pb2.Struct" href="../struct_pb2.html#google.protobuf.struct_pb2.Struct">Struct</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.well_known_types.Struct.get_or_create_list"><code class="name flex">
<span>def <span class="ident">get_or_create_list</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list for this key, creating if it didn't exist already.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_list(self, key):
  &#34;&#34;&#34;Returns a list for this key, creating if it didn&#39;t exist already.&#34;&#34;&#34;
  if not self.fields[key].HasField(&#39;list_value&#39;):
    # Clear will mark list_value modified which will indeed create a list.
    self.fields[key].list_value.Clear()
  return self.fields[key].list_value</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Struct.get_or_create_struct"><code class="name flex">
<span>def <span class="ident">get_or_create_struct</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a struct for this key, creating if it didn't exist already.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_create_struct(self, key):
  &#34;&#34;&#34;Returns a struct for this key, creating if it didn&#39;t exist already.&#34;&#34;&#34;
  if not self.fields[key].HasField(&#39;struct_value&#39;):
    # Clear will mark struct_value modified which will indeed create a struct.
    self.fields[key].struct_value.Clear()
  return self.fields[key].struct_value</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):  # pylint: disable=invalid-name
  return [(key, self[key]) for key in self]</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):  # pylint: disable=invalid-name
  return self.fields.keys()</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, dictionary)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, dictionary):  # pylint: disable=invalid-name
  for key, value in dictionary.items():
    _SetStructValue(self.fields[key], value)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):  # pylint: disable=invalid-name
  return [self[key] for key in self]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp"><code class="flex name class">
<span>class <span class="ident">Timestamp</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for Timestamp message type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timestamp(object):
  &#34;&#34;&#34;Class for Timestamp message type.&#34;&#34;&#34;

  __slots__ = ()

  def ToJsonString(self):
    &#34;&#34;&#34;Converts Timestamp to RFC 3339 date string format.

    Returns:
      A string converted from timestamp. The string is always Z-normalized
      and uses 3, 6 or 9 fractional digits as required to represent the
      exact time. Example of the return format: &#39;1972-01-01T10:00:20.021Z&#39;
    &#34;&#34;&#34;
    nanos = self.nanos % _NANOS_PER_SECOND
    total_sec = self.seconds + (self.nanos - nanos) // _NANOS_PER_SECOND
    seconds = total_sec % _SECONDS_PER_DAY
    days = (total_sec - seconds) // _SECONDS_PER_DAY
    dt = datetime(1970, 1, 1) + timedelta(days, seconds)

    result = dt.isoformat()
    if (nanos % 1e9) == 0:
      # If there are 0 fractional digits, the fractional
      # point &#39;.&#39; should be omitted when serializing.
      return result + &#39;Z&#39;
    if (nanos % 1e6) == 0:
      # Serialize 3 fractional digits.
      return result + &#39;.%03dZ&#39; % (nanos / 1e6)
    if (nanos % 1e3) == 0:
      # Serialize 6 fractional digits.
      return result + &#39;.%06dZ&#39; % (nanos / 1e3)
    # Serialize 9 fractional digits.
    return result + &#39;.%09dZ&#39; % nanos

  def FromJsonString(self, value):
    &#34;&#34;&#34;Parse a RFC 3339 date string format to Timestamp.

    Args:
      value: A date string. Any fractional digits (or none) and any offset are
          accepted as long as they fit into nano-seconds precision.
          Example of accepted format: &#39;1972-01-01T10:00:20.021-05:00&#39;

    Raises:
      ValueError: On parsing problems.
    &#34;&#34;&#34;
    timezone_offset = value.find(&#39;Z&#39;)
    if timezone_offset == -1:
      timezone_offset = value.find(&#39;+&#39;)
    if timezone_offset == -1:
      timezone_offset = value.rfind(&#39;-&#39;)
    if timezone_offset == -1:
      raise ValueError(
          &#39;Failed to parse timestamp: missing valid timezone offset.&#39;)
    time_value = value[0:timezone_offset]
    # Parse datetime and nanos.
    point_position = time_value.find(&#39;.&#39;)
    if point_position == -1:
      second_value = time_value
      nano_value = &#39;&#39;
    else:
      second_value = time_value[:point_position]
      nano_value = time_value[point_position + 1:]
    date_object = datetime.strptime(second_value, _TIMESTAMPFOMAT)
    td = date_object - datetime(1970, 1, 1)
    seconds = td.seconds + td.days * _SECONDS_PER_DAY
    if len(nano_value) &gt; 9:
      raise ValueError(
          &#39;Failed to parse Timestamp: nanos {0} more than &#39;
          &#39;9 fractional digits.&#39;.format(nano_value))
    if nano_value:
      nanos = round(float(&#39;0.&#39; + nano_value) * 1e9)
    else:
      nanos = 0
    # Parse timezone offsets.
    if value[timezone_offset] == &#39;Z&#39;:
      if len(value) != timezone_offset + 1:
        raise ValueError(&#39;Failed to parse timestamp: invalid trailing&#39;
                         &#39; data {0}.&#39;.format(value))
    else:
      timezone = value[timezone_offset:]
      pos = timezone.find(&#39;:&#39;)
      if pos == -1:
        raise ValueError(
            &#39;Invalid timezone offset value: {0}.&#39;.format(timezone))
      if timezone[0] == &#39;+&#39;:
        seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
      else:
        seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
    # Set seconds and nanos
    self.seconds = int(seconds)
    self.nanos = int(nanos)

  def GetCurrentTime(self):
    &#34;&#34;&#34;Get the current UTC into Timestamp.&#34;&#34;&#34;
    self.FromDatetime(datetime.utcnow())

  def ToNanoseconds(self):
    &#34;&#34;&#34;Converts Timestamp to nanoseconds since epoch.&#34;&#34;&#34;
    return self.seconds * _NANOS_PER_SECOND + self.nanos

  def ToMicroseconds(self):
    &#34;&#34;&#34;Converts Timestamp to microseconds since epoch.&#34;&#34;&#34;
    return (self.seconds * _MICROS_PER_SECOND +
            self.nanos // _NANOS_PER_MICROSECOND)

  def ToMilliseconds(self):
    &#34;&#34;&#34;Converts Timestamp to milliseconds since epoch.&#34;&#34;&#34;
    return (self.seconds * _MILLIS_PER_SECOND +
            self.nanos // _NANOS_PER_MILLISECOND)

  def ToSeconds(self):
    &#34;&#34;&#34;Converts Timestamp to seconds since epoch.&#34;&#34;&#34;
    return self.seconds

  def FromNanoseconds(self, nanos):
    &#34;&#34;&#34;Converts nanoseconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = nanos // _NANOS_PER_SECOND
    self.nanos = nanos % _NANOS_PER_SECOND

  def FromMicroseconds(self, micros):
    &#34;&#34;&#34;Converts microseconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = micros // _MICROS_PER_SECOND
    self.nanos = (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND

  def FromMilliseconds(self, millis):
    &#34;&#34;&#34;Converts milliseconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = millis // _MILLIS_PER_SECOND
    self.nanos = (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND

  def FromSeconds(self, seconds):
    &#34;&#34;&#34;Converts seconds since epoch to Timestamp.&#34;&#34;&#34;
    self.seconds = seconds
    self.nanos = 0

  def ToDatetime(self):
    &#34;&#34;&#34;Converts Timestamp to datetime.&#34;&#34;&#34;
    return _EPOCH_DATETIME + timedelta(
        seconds=self.seconds, microseconds=_RoundTowardZero(
            self.nanos, _NANOS_PER_MICROSECOND))

  def FromDatetime(self, dt):
    &#34;&#34;&#34;Converts datetime to Timestamp.&#34;&#34;&#34;
    # Using this guide: http://wiki.python.org/moin/WorkingWithTime
    # And this conversion guide: http://docs.python.org/library/time.html

    # Turn the date parameter into a tuple (struct_time) that can then be
    # manipulated into a long value of seconds.  During the conversion from
    # struct_time to long, the source date in UTC, and so it follows that the
    # correct transformation is calendar.timegm()
    self.seconds = calendar.timegm(dt.utctimetuple())
    self.nanos = dt.microsecond * _NANOS_PER_MICROSECOND</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="google.protobuf.timestamp_pb2.Timestamp" href="../timestamp_pb2.html#google.protobuf.timestamp_pb2.Timestamp">Timestamp</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="google.protobuf.internal.well_known_types.Timestamp.FromDatetime"><code class="name flex">
<span>def <span class="ident">FromDatetime</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts datetime to Timestamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromDatetime(self, dt):
  &#34;&#34;&#34;Converts datetime to Timestamp.&#34;&#34;&#34;
  # Using this guide: http://wiki.python.org/moin/WorkingWithTime
  # And this conversion guide: http://docs.python.org/library/time.html

  # Turn the date parameter into a tuple (struct_time) that can then be
  # manipulated into a long value of seconds.  During the conversion from
  # struct_time to long, the source date in UTC, and so it follows that the
  # correct transformation is calendar.timegm()
  self.seconds = calendar.timegm(dt.utctimetuple())
  self.nanos = dt.microsecond * _NANOS_PER_MICROSECOND</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.FromJsonString"><code class="name flex">
<span>def <span class="ident">FromJsonString</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Parse a RFC 3339 date string format to Timestamp.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>A date string. Any fractional digits (or none) and any offset are
accepted as long as they fit into nano-seconds precision.
Example of accepted format: '1972-01-01T10:00:20.021-05:00'</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>On parsing problems.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromJsonString(self, value):
  &#34;&#34;&#34;Parse a RFC 3339 date string format to Timestamp.

  Args:
    value: A date string. Any fractional digits (or none) and any offset are
        accepted as long as they fit into nano-seconds precision.
        Example of accepted format: &#39;1972-01-01T10:00:20.021-05:00&#39;

  Raises:
    ValueError: On parsing problems.
  &#34;&#34;&#34;
  timezone_offset = value.find(&#39;Z&#39;)
  if timezone_offset == -1:
    timezone_offset = value.find(&#39;+&#39;)
  if timezone_offset == -1:
    timezone_offset = value.rfind(&#39;-&#39;)
  if timezone_offset == -1:
    raise ValueError(
        &#39;Failed to parse timestamp: missing valid timezone offset.&#39;)
  time_value = value[0:timezone_offset]
  # Parse datetime and nanos.
  point_position = time_value.find(&#39;.&#39;)
  if point_position == -1:
    second_value = time_value
    nano_value = &#39;&#39;
  else:
    second_value = time_value[:point_position]
    nano_value = time_value[point_position + 1:]
  date_object = datetime.strptime(second_value, _TIMESTAMPFOMAT)
  td = date_object - datetime(1970, 1, 1)
  seconds = td.seconds + td.days * _SECONDS_PER_DAY
  if len(nano_value) &gt; 9:
    raise ValueError(
        &#39;Failed to parse Timestamp: nanos {0} more than &#39;
        &#39;9 fractional digits.&#39;.format(nano_value))
  if nano_value:
    nanos = round(float(&#39;0.&#39; + nano_value) * 1e9)
  else:
    nanos = 0
  # Parse timezone offsets.
  if value[timezone_offset] == &#39;Z&#39;:
    if len(value) != timezone_offset + 1:
      raise ValueError(&#39;Failed to parse timestamp: invalid trailing&#39;
                       &#39; data {0}.&#39;.format(value))
  else:
    timezone = value[timezone_offset:]
    pos = timezone.find(&#39;:&#39;)
    if pos == -1:
      raise ValueError(
          &#39;Invalid timezone offset value: {0}.&#39;.format(timezone))
    if timezone[0] == &#39;+&#39;:
      seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
    else:
      seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
  # Set seconds and nanos
  self.seconds = int(seconds)
  self.nanos = int(nanos)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.FromMicroseconds"><code class="name flex">
<span>def <span class="ident">FromMicroseconds</span></span>(<span>self, micros)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts microseconds since epoch to Timestamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromMicroseconds(self, micros):
  &#34;&#34;&#34;Converts microseconds since epoch to Timestamp.&#34;&#34;&#34;
  self.seconds = micros // _MICROS_PER_SECOND
  self.nanos = (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.FromMilliseconds"><code class="name flex">
<span>def <span class="ident">FromMilliseconds</span></span>(<span>self, millis)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts milliseconds since epoch to Timestamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromMilliseconds(self, millis):
  &#34;&#34;&#34;Converts milliseconds since epoch to Timestamp.&#34;&#34;&#34;
  self.seconds = millis // _MILLIS_PER_SECOND
  self.nanos = (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.FromNanoseconds"><code class="name flex">
<span>def <span class="ident">FromNanoseconds</span></span>(<span>self, nanos)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts nanoseconds since epoch to Timestamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromNanoseconds(self, nanos):
  &#34;&#34;&#34;Converts nanoseconds since epoch to Timestamp.&#34;&#34;&#34;
  self.seconds = nanos // _NANOS_PER_SECOND
  self.nanos = nanos % _NANOS_PER_SECOND</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.FromSeconds"><code class="name flex">
<span>def <span class="ident">FromSeconds</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts seconds since epoch to Timestamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FromSeconds(self, seconds):
  &#34;&#34;&#34;Converts seconds since epoch to Timestamp.&#34;&#34;&#34;
  self.seconds = seconds
  self.nanos = 0</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.GetCurrentTime"><code class="name flex">
<span>def <span class="ident">GetCurrentTime</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the current UTC into Timestamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCurrentTime(self):
  &#34;&#34;&#34;Get the current UTC into Timestamp.&#34;&#34;&#34;
  self.FromDatetime(datetime.utcnow())</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.ToDatetime"><code class="name flex">
<span>def <span class="ident">ToDatetime</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Timestamp to datetime.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToDatetime(self):
  &#34;&#34;&#34;Converts Timestamp to datetime.&#34;&#34;&#34;
  return _EPOCH_DATETIME + timedelta(
      seconds=self.seconds, microseconds=_RoundTowardZero(
          self.nanos, _NANOS_PER_MICROSECOND))</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.ToJsonString"><code class="name flex">
<span>def <span class="ident">ToJsonString</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Timestamp to RFC 3339 date string format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>string</code> <code>converted</code> <code>from</code> <code>timestamp.</code> <code>The</code> <code>string</code> <code>is</code> <code>always</code> <code>Z</code>-<code>normalized</code></dt>
<dd>&nbsp;</dd>
<dt><code>and</code> <code>uses</code> <code>3</code>, <code>6</code> or <code>9</code> <code>fractional</code> <code>digits</code> <code>as</code> <code>required</code> <code>to</code> <code>represent</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>exact</code> <code>time.</code> <code>Example</code> of <code>the</code> <code>return</code> <code>format</code>: <code>'1972</code>-<code>01</code>-<code>01T10</code>:<code>00</code>:<code>20.021Z'</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToJsonString(self):
  &#34;&#34;&#34;Converts Timestamp to RFC 3339 date string format.

  Returns:
    A string converted from timestamp. The string is always Z-normalized
    and uses 3, 6 or 9 fractional digits as required to represent the
    exact time. Example of the return format: &#39;1972-01-01T10:00:20.021Z&#39;
  &#34;&#34;&#34;
  nanos = self.nanos % _NANOS_PER_SECOND
  total_sec = self.seconds + (self.nanos - nanos) // _NANOS_PER_SECOND
  seconds = total_sec % _SECONDS_PER_DAY
  days = (total_sec - seconds) // _SECONDS_PER_DAY
  dt = datetime(1970, 1, 1) + timedelta(days, seconds)

  result = dt.isoformat()
  if (nanos % 1e9) == 0:
    # If there are 0 fractional digits, the fractional
    # point &#39;.&#39; should be omitted when serializing.
    return result + &#39;Z&#39;
  if (nanos % 1e6) == 0:
    # Serialize 3 fractional digits.
    return result + &#39;.%03dZ&#39; % (nanos / 1e6)
  if (nanos % 1e3) == 0:
    # Serialize 6 fractional digits.
    return result + &#39;.%06dZ&#39; % (nanos / 1e3)
  # Serialize 9 fractional digits.
  return result + &#39;.%09dZ&#39; % nanos</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.ToMicroseconds"><code class="name flex">
<span>def <span class="ident">ToMicroseconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Timestamp to microseconds since epoch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToMicroseconds(self):
  &#34;&#34;&#34;Converts Timestamp to microseconds since epoch.&#34;&#34;&#34;
  return (self.seconds * _MICROS_PER_SECOND +
          self.nanos // _NANOS_PER_MICROSECOND)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.ToMilliseconds"><code class="name flex">
<span>def <span class="ident">ToMilliseconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Timestamp to milliseconds since epoch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToMilliseconds(self):
  &#34;&#34;&#34;Converts Timestamp to milliseconds since epoch.&#34;&#34;&#34;
  return (self.seconds * _MILLIS_PER_SECOND +
          self.nanos // _NANOS_PER_MILLISECOND)</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.ToNanoseconds"><code class="name flex">
<span>def <span class="ident">ToNanoseconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Timestamp to nanoseconds since epoch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToNanoseconds(self):
  &#34;&#34;&#34;Converts Timestamp to nanoseconds since epoch.&#34;&#34;&#34;
  return self.seconds * _NANOS_PER_SECOND + self.nanos</code></pre>
</details>
</dd>
<dt id="google.protobuf.internal.well_known_types.Timestamp.ToSeconds"><code class="name flex">
<span>def <span class="ident">ToSeconds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts Timestamp to seconds since epoch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ToSeconds(self):
  &#34;&#34;&#34;Converts Timestamp to seconds since epoch.&#34;&#34;&#34;
  return self.seconds</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.protobuf.internal" href="index.html">google.protobuf.internal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.protobuf.internal.well_known_types.Any" href="#google.protobuf.internal.well_known_types.Any">Any</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.well_known_types.Any.Is" href="#google.protobuf.internal.well_known_types.Any.Is">Is</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Any.Pack" href="#google.protobuf.internal.well_known_types.Any.Pack">Pack</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Any.TypeName" href="#google.protobuf.internal.well_known_types.Any.TypeName">TypeName</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Any.Unpack" href="#google.protobuf.internal.well_known_types.Any.Unpack">Unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.well_known_types.Duration" href="#google.protobuf.internal.well_known_types.Duration">Duration</a></code></h4>
<ul class="two-column">
<li><code><a title="google.protobuf.internal.well_known_types.Duration.FromJsonString" href="#google.protobuf.internal.well_known_types.Duration.FromJsonString">FromJsonString</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.FromMicroseconds" href="#google.protobuf.internal.well_known_types.Duration.FromMicroseconds">FromMicroseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.FromMilliseconds" href="#google.protobuf.internal.well_known_types.Duration.FromMilliseconds">FromMilliseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.FromNanoseconds" href="#google.protobuf.internal.well_known_types.Duration.FromNanoseconds">FromNanoseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.FromSeconds" href="#google.protobuf.internal.well_known_types.Duration.FromSeconds">FromSeconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.FromTimedelta" href="#google.protobuf.internal.well_known_types.Duration.FromTimedelta">FromTimedelta</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.ToJsonString" href="#google.protobuf.internal.well_known_types.Duration.ToJsonString">ToJsonString</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.ToMicroseconds" href="#google.protobuf.internal.well_known_types.Duration.ToMicroseconds">ToMicroseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.ToMilliseconds" href="#google.protobuf.internal.well_known_types.Duration.ToMilliseconds">ToMilliseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.ToNanoseconds" href="#google.protobuf.internal.well_known_types.Duration.ToNanoseconds">ToNanoseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.ToSeconds" href="#google.protobuf.internal.well_known_types.Duration.ToSeconds">ToSeconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Duration.ToTimedelta" href="#google.protobuf.internal.well_known_types.Duration.ToTimedelta">ToTimedelta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.well_known_types.FieldMask" href="#google.protobuf.internal.well_known_types.FieldMask">FieldMask</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.AllFieldsFromDescriptor" href="#google.protobuf.internal.well_known_types.FieldMask.AllFieldsFromDescriptor">AllFieldsFromDescriptor</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.CanonicalFormFromMask" href="#google.protobuf.internal.well_known_types.FieldMask.CanonicalFormFromMask">CanonicalFormFromMask</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.FromJsonString" href="#google.protobuf.internal.well_known_types.FieldMask.FromJsonString">FromJsonString</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.Intersect" href="#google.protobuf.internal.well_known_types.FieldMask.Intersect">Intersect</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.IsValidForDescriptor" href="#google.protobuf.internal.well_known_types.FieldMask.IsValidForDescriptor">IsValidForDescriptor</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.MergeMessage" href="#google.protobuf.internal.well_known_types.FieldMask.MergeMessage">MergeMessage</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.ToJsonString" href="#google.protobuf.internal.well_known_types.FieldMask.ToJsonString">ToJsonString</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.FieldMask.Union" href="#google.protobuf.internal.well_known_types.FieldMask.Union">Union</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.well_known_types.ListValue" href="#google.protobuf.internal.well_known_types.ListValue">ListValue</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.well_known_types.ListValue.add_list" href="#google.protobuf.internal.well_known_types.ListValue.add_list">add_list</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.ListValue.add_struct" href="#google.protobuf.internal.well_known_types.ListValue.add_struct">add_struct</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.ListValue.append" href="#google.protobuf.internal.well_known_types.ListValue.append">append</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.ListValue.extend" href="#google.protobuf.internal.well_known_types.ListValue.extend">extend</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.ListValue.items" href="#google.protobuf.internal.well_known_types.ListValue.items">items</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.well_known_types.Struct" href="#google.protobuf.internal.well_known_types.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="google.protobuf.internal.well_known_types.Struct.get_or_create_list" href="#google.protobuf.internal.well_known_types.Struct.get_or_create_list">get_or_create_list</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Struct.get_or_create_struct" href="#google.protobuf.internal.well_known_types.Struct.get_or_create_struct">get_or_create_struct</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Struct.items" href="#google.protobuf.internal.well_known_types.Struct.items">items</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Struct.keys" href="#google.protobuf.internal.well_known_types.Struct.keys">keys</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Struct.update" href="#google.protobuf.internal.well_known_types.Struct.update">update</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Struct.values" href="#google.protobuf.internal.well_known_types.Struct.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.protobuf.internal.well_known_types.Timestamp" href="#google.protobuf.internal.well_known_types.Timestamp">Timestamp</a></code></h4>
<ul class="two-column">
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.FromDatetime" href="#google.protobuf.internal.well_known_types.Timestamp.FromDatetime">FromDatetime</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.FromJsonString" href="#google.protobuf.internal.well_known_types.Timestamp.FromJsonString">FromJsonString</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.FromMicroseconds" href="#google.protobuf.internal.well_known_types.Timestamp.FromMicroseconds">FromMicroseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.FromMilliseconds" href="#google.protobuf.internal.well_known_types.Timestamp.FromMilliseconds">FromMilliseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.FromNanoseconds" href="#google.protobuf.internal.well_known_types.Timestamp.FromNanoseconds">FromNanoseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.FromSeconds" href="#google.protobuf.internal.well_known_types.Timestamp.FromSeconds">FromSeconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.GetCurrentTime" href="#google.protobuf.internal.well_known_types.Timestamp.GetCurrentTime">GetCurrentTime</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.ToDatetime" href="#google.protobuf.internal.well_known_types.Timestamp.ToDatetime">ToDatetime</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.ToJsonString" href="#google.protobuf.internal.well_known_types.Timestamp.ToJsonString">ToJsonString</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.ToMicroseconds" href="#google.protobuf.internal.well_known_types.Timestamp.ToMicroseconds">ToMicroseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.ToMilliseconds" href="#google.protobuf.internal.well_known_types.Timestamp.ToMilliseconds">ToMilliseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.ToNanoseconds" href="#google.protobuf.internal.well_known_types.Timestamp.ToNanoseconds">ToNanoseconds</a></code></li>
<li><code><a title="google.protobuf.internal.well_known_types.Timestamp.ToSeconds" href="#google.protobuf.internal.well_known_types.Timestamp.ToSeconds">ToSeconds</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>