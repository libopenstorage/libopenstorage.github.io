<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>google.oauth2.service_account API documentation</title>
<meta name="description" content="Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>google.oauth2.service_account</code></h1>
</header>
<section id="section-intro">
<p>Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0</p>
<p>This module implements the JWT Profile for OAuth 2.0 Authorization Grants
as defined by <code>RFC 7523</code>_ with particular support for how this RFC is
implemented in Google's infrastructure. Google refers to these credentials
as <em>Service Accounts</em>.</p>
<p>Service accounts are used for server-to-server communication, such as
interactions between a web application server and a Google service. The
service account belongs to your application instead of to an individual end
user. In contrast to other OAuth 2.0 profiles, no users are involved and your
application "acts" as the service account.</p>
<p>Typically an application uses a service account when the application uses
Google APIs to work with its own data rather than a user's data. For example,
an application that uses Google Cloud Datastore for data persistence would use
a service account to authenticate its calls to the Google Cloud Datastore API.
However, an application that needs to access a user's Drive documents would
use the normal OAuth 2.0 profile.</p>
<p>Additionally, Google Apps domain administrators can grant service accounts
<code>domain-wide delegation</code>_ authority to access user data on behalf of users in
the domain.</p>
<p>This profile uses a JWT to acquire an OAuth 2.0 access token. The JWT is used
in place of the usual authorization token returned during the standard
OAuth 2.0 Authorization Code grant. The JWT is only used for this purpose, as
the acquired access token is used as the bearer token when making requests
using these credentials.</p>
<p>This profile differs from normal OAuth 2.0 profile because no user consent
step is required. The use of the private key allows this profile to assert
identity directly.</p>
<p>This profile also differs from the :mod:<a title="google.auth.jwt" href="../auth/jwt.html"><code>google.auth.jwt</code></a> authentication
because the JWT credentials use the JWT directly as the bearer token. This
profile instead only uses the JWT to obtain an OAuth 2.0 access token. The
obtained OAuth 2.0 access token is used as the bearer token.</p>
<h2 id="domain-wide-delegation">Domain-wide delegation</h2>
<p>Domain-wide delegation allows a service account to access user data on
behalf of any user in a Google Apps domain without consent from the user.
For example, an application that uses the Google Calendar API to add events to
the calendars of all users in a Google Apps domain would use a service account
to access the Google Calendar API on behalf of users.</p>
<p>The Google Apps administrator must explicitly authorize the service account to
do this. This authorization step is referred to as "delegating domain-wide
authority" to a service account.</p>
<p>You can use domain-wise delegation by creating a set of credentials with a
specific subject using :meth:<code>~Credentials.with_subject</code>.</p>
<p>.. _RFC 7523: <a href="https://tools.ietf.org/html/rfc7523">https://tools.ietf.org/html/rfc7523</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0

This module implements the JWT Profile for OAuth 2.0 Authorization Grants
as defined by `RFC 7523`_ with particular support for how this RFC is
implemented in Google&#39;s infrastructure. Google refers to these credentials
as *Service Accounts*.

Service accounts are used for server-to-server communication, such as
interactions between a web application server and a Google service. The
service account belongs to your application instead of to an individual end
user. In contrast to other OAuth 2.0 profiles, no users are involved and your
application &#34;acts&#34; as the service account.

Typically an application uses a service account when the application uses
Google APIs to work with its own data rather than a user&#39;s data. For example,
an application that uses Google Cloud Datastore for data persistence would use
a service account to authenticate its calls to the Google Cloud Datastore API.
However, an application that needs to access a user&#39;s Drive documents would
use the normal OAuth 2.0 profile.

Additionally, Google Apps domain administrators can grant service accounts
`domain-wide delegation`_ authority to access user data on behalf of users in
the domain.

This profile uses a JWT to acquire an OAuth 2.0 access token. The JWT is used
in place of the usual authorization token returned during the standard
OAuth 2.0 Authorization Code grant. The JWT is only used for this purpose, as
the acquired access token is used as the bearer token when making requests
using these credentials.

This profile differs from normal OAuth 2.0 profile because no user consent
step is required. The use of the private key allows this profile to assert
identity directly.

This profile also differs from the :mod:`google.auth.jwt` authentication
because the JWT credentials use the JWT directly as the bearer token. This
profile instead only uses the JWT to obtain an OAuth 2.0 access token. The
obtained OAuth 2.0 access token is used as the bearer token.

Domain-wide delegation
----------------------

Domain-wide delegation allows a service account to access user data on
behalf of any user in a Google Apps domain without consent from the user.
For example, an application that uses the Google Calendar API to add events to
the calendars of all users in a Google Apps domain would use a service account
to access the Google Calendar API on behalf of users.

The Google Apps administrator must explicitly authorize the service account to
do this. This authorization step is referred to as &#34;delegating domain-wide
authority&#34; to a service account.

You can use domain-wise delegation by creating a set of credentials with a
specific subject using :meth:`~Credentials.with_subject`.

.. _RFC 7523: https://tools.ietf.org/html/rfc7523
&#34;&#34;&#34;

import copy
import datetime

from google.auth import _helpers
from google.auth import _service_account_info
from google.auth import credentials
from google.auth import jwt
from google.oauth2 import _client

_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds


class Credentials(credentials.Signing, credentials.Scoped, credentials.Credentials):
    &#34;&#34;&#34;Service account credentials

    Usually, you&#39;ll create these credentials with one of the helper
    constructors. To create credentials using a Google service account
    private key JSON file::

        credentials = service_account.Credentials.from_service_account_file(
            &#39;service-account.json&#39;)

    Or if you already have the service account file loaded::

        service_account_info = json.load(open(&#39;service_account.json&#39;))
        credentials = service_account.Credentials.from_service_account_info(
            service_account_info)

    Both helper methods pass on arguments to the constructor, so you can
    specify additional scopes and a subject if necessary::

        credentials = service_account.Credentials.from_service_account_file(
            &#39;service-account.json&#39;,
            scopes=[&#39;email&#39;],
            subject=&#39;user@example.com&#39;)

    The credentials are considered immutable. If you want to modify the scopes
    or the subject used for delegation, use :meth:`with_scopes` or
    :meth:`with_subject`::

        scoped_credentials = credentials.with_scopes([&#39;email&#39;])
        delegated_credentials = credentials.with_subject(subject)
    &#34;&#34;&#34;

    def __init__(
        self,
        signer,
        service_account_email,
        token_uri,
        scopes=None,
        subject=None,
        project_id=None,
        additional_claims=None,
    ):
        &#34;&#34;&#34;
        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            service_account_email (str): The service account&#39;s email.
            scopes (Sequence[str]): Scopes to request during the authorization
                grant.
            token_uri (str): The OAuth 2.0 Token URI.
            subject (str): For domain-wide delegation, the email address of the
                user to for which to request delegated access.
            project_id  (str): Project ID associated with the service account
                credential.
            additional_claims (Mapping[str, str]): Any additional claims for
                the JWT assertion used in the authorization grant.

        .. note:: Typically one of the helper constructors
            :meth:`from_service_account_file` or
            :meth:`from_service_account_info` are used instead of calling the
            constructor directly.
        &#34;&#34;&#34;
        super(Credentials, self).__init__()

        self._scopes = scopes
        self._signer = signer
        self._service_account_email = service_account_email
        self._subject = subject
        self._project_id = project_id
        self._token_uri = token_uri

        if additional_claims is not None:
            self._additional_claims = additional_claims
        else:
            self._additional_claims = {}

    @classmethod
    def _from_signer_and_info(cls, signer, info, **kwargs):
        &#34;&#34;&#34;Creates a Credentials instance from a signer and service account
        info.

        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            info (Mapping[str, str]): The service account info.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.jwt.Credentials: The constructed credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        return cls(
            signer,
            service_account_email=info[&#34;client_email&#34;],
            token_uri=info[&#34;token_uri&#34;],
            project_id=info.get(&#34;project_id&#34;),
            **kwargs
        )

    @classmethod
    def from_service_account_info(cls, info, **kwargs):
        &#34;&#34;&#34;Creates a Credentials instance from parsed service account info.

        Args:
            info (Mapping[str, str]): The service account info in Google
                format.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.Credentials: The constructed
                credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        signer = _service_account_info.from_dict(
            info, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    @classmethod
    def from_service_account_file(cls, filename, **kwargs):
        &#34;&#34;&#34;Creates a Credentials instance from a service account json file.

        Args:
            filename (str): The path to the service account json file.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.Credentials: The constructed
                credentials.
        &#34;&#34;&#34;
        info, signer = _service_account_info.from_filename(
            filename, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    @property
    def service_account_email(self):
        &#34;&#34;&#34;The service account email.&#34;&#34;&#34;
        return self._service_account_email

    @property
    def project_id(self):
        &#34;&#34;&#34;Project ID associated with this credential.&#34;&#34;&#34;
        return self._project_id

    @property
    def requires_scopes(self):
        &#34;&#34;&#34;Checks if the credentials requires scopes.

        Returns:
            bool: True if there are no scopes set otherwise False.
        &#34;&#34;&#34;
        return True if not self._scopes else False

    @_helpers.copy_docstring(credentials.Scoped)
    def with_scopes(self, scopes):
        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            scopes=scopes,
            token_uri=self._token_uri,
            subject=self._subject,
            project_id=self._project_id,
            additional_claims=self._additional_claims.copy(),
        )

    def with_subject(self, subject):
        &#34;&#34;&#34;Create a copy of these credentials with the specified subject.

        Args:
            subject (str): The subject claim.

        Returns:
            google.auth.service_account.Credentials: A new credentials
                instance.
        &#34;&#34;&#34;
        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            scopes=self._scopes,
            token_uri=self._token_uri,
            subject=subject,
            project_id=self._project_id,
            additional_claims=self._additional_claims.copy(),
        )

    def with_claims(self, additional_claims):
        &#34;&#34;&#34;Returns a copy of these credentials with modified claims.

        Args:
            additional_claims (Mapping[str, str]): Any additional claims for
                the JWT payload. This will be merged with the current
                additional claims.

        Returns:
            google.auth.service_account.Credentials: A new credentials
                instance.
        &#34;&#34;&#34;
        new_additional_claims = copy.deepcopy(self._additional_claims)
        new_additional_claims.update(additional_claims or {})

        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            scopes=self._scopes,
            token_uri=self._token_uri,
            subject=self._subject,
            project_id=self._project_id,
            additional_claims=new_additional_claims,
        )

    def _make_authorization_grant_assertion(self):
        &#34;&#34;&#34;Create the OAuth 2.0 assertion.

        This assertion is used during the OAuth 2.0 grant to acquire an
        access token.

        Returns:
            bytes: The authorization grant assertion.
        &#34;&#34;&#34;
        now = _helpers.utcnow()
        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
        expiry = now + lifetime

        payload = {
            &#34;iat&#34;: _helpers.datetime_to_secs(now),
            &#34;exp&#34;: _helpers.datetime_to_secs(expiry),
            # The issuer must be the service account email.
            &#34;iss&#34;: self._service_account_email,
            # The audience must be the auth token endpoint&#39;s URI
            &#34;aud&#34;: self._token_uri,
            &#34;scope&#34;: _helpers.scopes_to_string(self._scopes or ()),
        }

        payload.update(self._additional_claims)

        # The subject can be a user email for domain-wide delegation.
        if self._subject:
            payload.setdefault(&#34;sub&#34;, self._subject)

        token = jwt.encode(self._signer, payload)

        return token

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        assertion = self._make_authorization_grant_assertion()
        access_token, expiry, _ = _client.jwt_grant(request, self._token_uri, assertion)
        self.token = access_token
        self.expiry = expiry

    @_helpers.copy_docstring(credentials.Signing)
    def sign_bytes(self, message):
        return self._signer.sign(message)

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer(self):
        return self._signer

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer_email(self):
        return self._service_account_email


class IDTokenCredentials(credentials.Signing, credentials.Credentials):
    &#34;&#34;&#34;Open ID Connect ID Token-based service account credentials.

    These credentials are largely similar to :class:`.Credentials`, but instead
    of using an OAuth 2.0 Access Token as the bearer token, they use an Open
    ID Connect ID Token as the bearer token. These credentials are useful when
    communicating to services that require ID Tokens and can not accept access
    tokens.

    Usually, you&#39;ll create these credentials with one of the helper
    constructors. To create credentials using a Google service account
    private key JSON file::

        credentials = (
            service_account.IDTokenCredentials.from_service_account_file(
                &#39;service-account.json&#39;))

    Or if you already have the service account file loaded::

        service_account_info = json.load(open(&#39;service_account.json&#39;))
        credentials = (
            service_account.IDTokenCredentials.from_service_account_info(
                service_account_info))

    Both helper methods pass on arguments to the constructor, so you can
    specify additional scopes and a subject if necessary::

        credentials = (
            service_account.IDTokenCredentials.from_service_account_file(
                &#39;service-account.json&#39;,
                scopes=[&#39;email&#39;],
                subject=&#39;user@example.com&#39;))
`
    The credentials are considered immutable. If you want to modify the scopes
    or the subject used for delegation, use :meth:`with_scopes` or
    :meth:`with_subject`::

        scoped_credentials = credentials.with_scopes([&#39;email&#39;])
        delegated_credentials = credentials.with_subject(subject)

    &#34;&#34;&#34;

    def __init__(
        self,
        signer,
        service_account_email,
        token_uri,
        target_audience,
        additional_claims=None,
    ):
        &#34;&#34;&#34;
        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            service_account_email (str): The service account&#39;s email.
            token_uri (str): The OAuth 2.0 Token URI.
            target_audience (str): The intended audience for these credentials,
                used when requesting the ID Token. The ID Token&#39;s ``aud`` claim
                will be set to this string.
            additional_claims (Mapping[str, str]): Any additional claims for
                the JWT assertion used in the authorization grant.

        .. note:: Typically one of the helper constructors
            :meth:`from_service_account_file` or
            :meth:`from_service_account_info` are used instead of calling the
            constructor directly.
        &#34;&#34;&#34;
        super(IDTokenCredentials, self).__init__()
        self._signer = signer
        self._service_account_email = service_account_email
        self._token_uri = token_uri
        self._target_audience = target_audience

        if additional_claims is not None:
            self._additional_claims = additional_claims
        else:
            self._additional_claims = {}

    @classmethod
    def _from_signer_and_info(cls, signer, info, **kwargs):
        &#34;&#34;&#34;Creates a credentials instance from a signer and service account
        info.

        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            info (Mapping[str, str]): The service account info.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.jwt.IDTokenCredentials: The constructed credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        kwargs.setdefault(&#34;service_account_email&#34;, info[&#34;client_email&#34;])
        kwargs.setdefault(&#34;token_uri&#34;, info[&#34;token_uri&#34;])
        return cls(signer, **kwargs)

    @classmethod
    def from_service_account_info(cls, info, **kwargs):
        &#34;&#34;&#34;Creates a credentials instance from parsed service account info.

        Args:
            info (Mapping[str, str]): The service account info in Google
                format.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.IDTokenCredentials: The constructed
                credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        signer = _service_account_info.from_dict(
            info, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    @classmethod
    def from_service_account_file(cls, filename, **kwargs):
        &#34;&#34;&#34;Creates a credentials instance from a service account json file.

        Args:
            filename (str): The path to the service account json file.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.IDTokenCredentials: The constructed
                credentials.
        &#34;&#34;&#34;
        info, signer = _service_account_info.from_filename(
            filename, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    def with_target_audience(self, target_audience):
        &#34;&#34;&#34;Create a copy of these credentials with the specified target
        audience.

        Args:
            target_audience (str): The intended audience for these credentials,
            used when requesting the ID Token.

        Returns:
            google.auth.service_account.IDTokenCredentials: A new credentials
                instance.
        &#34;&#34;&#34;
        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            token_uri=self._token_uri,
            target_audience=target_audience,
            additional_claims=self._additional_claims.copy(),
        )

    def _make_authorization_grant_assertion(self):
        &#34;&#34;&#34;Create the OAuth 2.0 assertion.

        This assertion is used during the OAuth 2.0 grant to acquire an
        ID token.

        Returns:
            bytes: The authorization grant assertion.
        &#34;&#34;&#34;
        now = _helpers.utcnow()
        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
        expiry = now + lifetime

        payload = {
            &#34;iat&#34;: _helpers.datetime_to_secs(now),
            &#34;exp&#34;: _helpers.datetime_to_secs(expiry),
            # The issuer must be the service account email.
            &#34;iss&#34;: self.service_account_email,
            # The audience must be the auth token endpoint&#39;s URI
            &#34;aud&#34;: self._token_uri,
            # The target audience specifies which service the ID token is
            # intended for.
            &#34;target_audience&#34;: self._target_audience,
        }

        payload.update(self._additional_claims)

        token = jwt.encode(self._signer, payload)

        return token

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        assertion = self._make_authorization_grant_assertion()
        access_token, expiry, _ = _client.id_token_jwt_grant(
            request, self._token_uri, assertion
        )
        self.token = access_token
        self.expiry = expiry

    @property
    def service_account_email(self):
        &#34;&#34;&#34;The service account email.&#34;&#34;&#34;
        return self._service_account_email

    @_helpers.copy_docstring(credentials.Signing)
    def sign_bytes(self, message):
        return self._signer.sign(message)

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer(self):
        return self._signer

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer_email(self):
        return self._service_account_email</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="google.oauth2.service_account.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
<span>(</span><span>signer, service_account_email, token_uri, scopes=None, subject=None, project_id=None, additional_claims=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Service account credentials</p>
<p>Usually, you'll create these credentials with one of the helper
constructors. To create credentials using a Google service account
private key JSON file::</p>
<pre><code>credentials = service_account.Credentials.from_service_account_file(
    'service-account.json')
</code></pre>
<p>Or if you already have the service account file loaded::</p>
<pre><code>service_account_info = json.load(open('service_account.json'))
credentials = service_account.Credentials.from_service_account_info(
    service_account_info)
</code></pre>
<p>Both helper methods pass on arguments to the constructor, so you can
specify additional scopes and a subject if necessary::</p>
<pre><code>credentials = service_account.Credentials.from_service_account_file(
    'service-account.json',
    scopes=['email'],
    subject='user@example.com')
</code></pre>
<p>The credentials are considered immutable. If you want to modify the scopes
or the subject used for delegation, use :meth:<code>with_scopes</code> or
:meth:<code>with_subject</code>::</p>
<pre><code>scoped_credentials = credentials.with_scopes(['email'])
delegated_credentials = credentials.with_subject(subject)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signer</code></strong> :&ensp;<a title="google.auth.crypt.Signer" href="../auth/crypt/index.html#google.auth.crypt.Signer"><code>Signer</code></a></dt>
<dd>The signer used to sign JWTs.</dd>
<dt><strong><code>service_account_email</code></strong> :&ensp;<code>str</code></dt>
<dd>The service account's email.</dd>
<dt><strong><code>scopes</code></strong> :&ensp;<code>Sequence</code>[<code>str</code>]</dt>
<dd>Scopes to request during the authorization
grant.</dd>
<dt><strong><code>token_uri</code></strong> :&ensp;<code>str</code></dt>
<dd>The OAuth 2.0 Token URI.</dd>
<dt><strong><code>subject</code></strong> :&ensp;<code>str</code></dt>
<dd>For domain-wide delegation, the email address of the
user to for which to request delegated access.</dd>
<dt>project_id
(str): Project ID associated with the service account</dt>
<dt>credential.</dt>
<dt><strong><code>additional_claims</code></strong> :&ensp;<code>Mapping</code>[<code>str</code>, <code>str</code>]</dt>
<dd>Any additional claims for
the JWT assertion used in the authorization grant.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Typically one of the helper constructors</p>
<p>:meth:<code>from_service_account_file</code> or
:meth:<code>from_service_account_info</code> are used instead of calling the
constructor directly.</p>
</div></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(credentials.Signing, credentials.Scoped, credentials.Credentials):
    &#34;&#34;&#34;Service account credentials

    Usually, you&#39;ll create these credentials with one of the helper
    constructors. To create credentials using a Google service account
    private key JSON file::

        credentials = service_account.Credentials.from_service_account_file(
            &#39;service-account.json&#39;)

    Or if you already have the service account file loaded::

        service_account_info = json.load(open(&#39;service_account.json&#39;))
        credentials = service_account.Credentials.from_service_account_info(
            service_account_info)

    Both helper methods pass on arguments to the constructor, so you can
    specify additional scopes and a subject if necessary::

        credentials = service_account.Credentials.from_service_account_file(
            &#39;service-account.json&#39;,
            scopes=[&#39;email&#39;],
            subject=&#39;user@example.com&#39;)

    The credentials are considered immutable. If you want to modify the scopes
    or the subject used for delegation, use :meth:`with_scopes` or
    :meth:`with_subject`::

        scoped_credentials = credentials.with_scopes([&#39;email&#39;])
        delegated_credentials = credentials.with_subject(subject)
    &#34;&#34;&#34;

    def __init__(
        self,
        signer,
        service_account_email,
        token_uri,
        scopes=None,
        subject=None,
        project_id=None,
        additional_claims=None,
    ):
        &#34;&#34;&#34;
        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            service_account_email (str): The service account&#39;s email.
            scopes (Sequence[str]): Scopes to request during the authorization
                grant.
            token_uri (str): The OAuth 2.0 Token URI.
            subject (str): For domain-wide delegation, the email address of the
                user to for which to request delegated access.
            project_id  (str): Project ID associated with the service account
                credential.
            additional_claims (Mapping[str, str]): Any additional claims for
                the JWT assertion used in the authorization grant.

        .. note:: Typically one of the helper constructors
            :meth:`from_service_account_file` or
            :meth:`from_service_account_info` are used instead of calling the
            constructor directly.
        &#34;&#34;&#34;
        super(Credentials, self).__init__()

        self._scopes = scopes
        self._signer = signer
        self._service_account_email = service_account_email
        self._subject = subject
        self._project_id = project_id
        self._token_uri = token_uri

        if additional_claims is not None:
            self._additional_claims = additional_claims
        else:
            self._additional_claims = {}

    @classmethod
    def _from_signer_and_info(cls, signer, info, **kwargs):
        &#34;&#34;&#34;Creates a Credentials instance from a signer and service account
        info.

        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            info (Mapping[str, str]): The service account info.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.jwt.Credentials: The constructed credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        return cls(
            signer,
            service_account_email=info[&#34;client_email&#34;],
            token_uri=info[&#34;token_uri&#34;],
            project_id=info.get(&#34;project_id&#34;),
            **kwargs
        )

    @classmethod
    def from_service_account_info(cls, info, **kwargs):
        &#34;&#34;&#34;Creates a Credentials instance from parsed service account info.

        Args:
            info (Mapping[str, str]): The service account info in Google
                format.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.Credentials: The constructed
                credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        signer = _service_account_info.from_dict(
            info, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    @classmethod
    def from_service_account_file(cls, filename, **kwargs):
        &#34;&#34;&#34;Creates a Credentials instance from a service account json file.

        Args:
            filename (str): The path to the service account json file.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.Credentials: The constructed
                credentials.
        &#34;&#34;&#34;
        info, signer = _service_account_info.from_filename(
            filename, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    @property
    def service_account_email(self):
        &#34;&#34;&#34;The service account email.&#34;&#34;&#34;
        return self._service_account_email

    @property
    def project_id(self):
        &#34;&#34;&#34;Project ID associated with this credential.&#34;&#34;&#34;
        return self._project_id

    @property
    def requires_scopes(self):
        &#34;&#34;&#34;Checks if the credentials requires scopes.

        Returns:
            bool: True if there are no scopes set otherwise False.
        &#34;&#34;&#34;
        return True if not self._scopes else False

    @_helpers.copy_docstring(credentials.Scoped)
    def with_scopes(self, scopes):
        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            scopes=scopes,
            token_uri=self._token_uri,
            subject=self._subject,
            project_id=self._project_id,
            additional_claims=self._additional_claims.copy(),
        )

    def with_subject(self, subject):
        &#34;&#34;&#34;Create a copy of these credentials with the specified subject.

        Args:
            subject (str): The subject claim.

        Returns:
            google.auth.service_account.Credentials: A new credentials
                instance.
        &#34;&#34;&#34;
        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            scopes=self._scopes,
            token_uri=self._token_uri,
            subject=subject,
            project_id=self._project_id,
            additional_claims=self._additional_claims.copy(),
        )

    def with_claims(self, additional_claims):
        &#34;&#34;&#34;Returns a copy of these credentials with modified claims.

        Args:
            additional_claims (Mapping[str, str]): Any additional claims for
                the JWT payload. This will be merged with the current
                additional claims.

        Returns:
            google.auth.service_account.Credentials: A new credentials
                instance.
        &#34;&#34;&#34;
        new_additional_claims = copy.deepcopy(self._additional_claims)
        new_additional_claims.update(additional_claims or {})

        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            scopes=self._scopes,
            token_uri=self._token_uri,
            subject=self._subject,
            project_id=self._project_id,
            additional_claims=new_additional_claims,
        )

    def _make_authorization_grant_assertion(self):
        &#34;&#34;&#34;Create the OAuth 2.0 assertion.

        This assertion is used during the OAuth 2.0 grant to acquire an
        access token.

        Returns:
            bytes: The authorization grant assertion.
        &#34;&#34;&#34;
        now = _helpers.utcnow()
        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
        expiry = now + lifetime

        payload = {
            &#34;iat&#34;: _helpers.datetime_to_secs(now),
            &#34;exp&#34;: _helpers.datetime_to_secs(expiry),
            # The issuer must be the service account email.
            &#34;iss&#34;: self._service_account_email,
            # The audience must be the auth token endpoint&#39;s URI
            &#34;aud&#34;: self._token_uri,
            &#34;scope&#34;: _helpers.scopes_to_string(self._scopes or ()),
        }

        payload.update(self._additional_claims)

        # The subject can be a user email for domain-wide delegation.
        if self._subject:
            payload.setdefault(&#34;sub&#34;, self._subject)

        token = jwt.encode(self._signer, payload)

        return token

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        assertion = self._make_authorization_grant_assertion()
        access_token, expiry, _ = _client.jwt_grant(request, self._token_uri, assertion)
        self.token = access_token
        self.expiry = expiry

    @_helpers.copy_docstring(credentials.Signing)
    def sign_bytes(self, message):
        return self._signer.sign(message)

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer(self):
        return self._signer

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer_email(self):
        return self._service_account_email</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.auth.credentials.Signing" href="../auth/credentials.html#google.auth.credentials.Signing">Signing</a></li>
<li><a title="google.auth.credentials.Scoped" href="../auth/credentials.html#google.auth.credentials.Scoped">Scoped</a></li>
<li><a title="google.auth.credentials.ReadOnlyScoped" href="../auth/credentials.html#google.auth.credentials.ReadOnlyScoped">ReadOnlyScoped</a></li>
<li><a title="google.auth.credentials.Credentials" href="../auth/credentials.html#google.auth.credentials.Credentials">Credentials</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="google.oauth2.service_account.Credentials.from_service_account_file"><code class="name flex">
<span>def <span class="ident">from_service_account_file</span></span>(<span>filename, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a Credentials instance from a service account json file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the service account json file.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional arguments to pass to the constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.Credentials</code>: <code>The</code> <code>constructed</code></dt>
<dd>credentials.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_service_account_file(cls, filename, **kwargs):
    &#34;&#34;&#34;Creates a Credentials instance from a service account json file.

    Args:
        filename (str): The path to the service account json file.
        kwargs: Additional arguments to pass to the constructor.

    Returns:
        google.auth.service_account.Credentials: The constructed
            credentials.
    &#34;&#34;&#34;
    info, signer = _service_account_info.from_filename(
        filename, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
    )
    return cls._from_signer_and_info(signer, info, **kwargs)</code></pre>
</details>
</dd>
<dt id="google.oauth2.service_account.Credentials.from_service_account_info"><code class="name flex">
<span>def <span class="ident">from_service_account_info</span></span>(<span>info, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a Credentials instance from parsed service account info.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>Mapping</code>[<code>str</code>, <code>str</code>]</dt>
<dd>The service account info in Google
format.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional arguments to pass to the constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.Credentials</code>: <code>The</code> <code>constructed</code></dt>
<dd>credentials.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>If the info is not in the expected format.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_service_account_info(cls, info, **kwargs):
    &#34;&#34;&#34;Creates a Credentials instance from parsed service account info.

    Args:
        info (Mapping[str, str]): The service account info in Google
            format.
        kwargs: Additional arguments to pass to the constructor.

    Returns:
        google.auth.service_account.Credentials: The constructed
            credentials.

    Raises:
        ValueError: If the info is not in the expected format.
    &#34;&#34;&#34;
    signer = _service_account_info.from_dict(
        info, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
    )
    return cls._from_signer_and_info(signer, info, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="google.oauth2.service_account.Credentials.project_id"><code class="name">var <span class="ident">project_id</span></code></dt>
<dd>
<section class="desc"><p>Project ID associated with this credential.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def project_id(self):
    &#34;&#34;&#34;Project ID associated with this credential.&#34;&#34;&#34;
    return self._project_id</code></pre>
</details>
</dd>
<dt id="google.oauth2.service_account.Credentials.requires_scopes"><code class="name">var <span class="ident">requires_scopes</span></code></dt>
<dd>
<section class="desc"><p>Checks if the credentials requires scopes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if there are no scopes set otherwise False.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def requires_scopes(self):
    &#34;&#34;&#34;Checks if the credentials requires scopes.

    Returns:
        bool: True if there are no scopes set otherwise False.
    &#34;&#34;&#34;
    return True if not self._scopes else False</code></pre>
</details>
</dd>
<dt id="google.oauth2.service_account.Credentials.service_account_email"><code class="name">var <span class="ident">service_account_email</span></code></dt>
<dd>
<section class="desc"><p>The service account email.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def service_account_email(self):
    &#34;&#34;&#34;The service account email.&#34;&#34;&#34;
    return self._service_account_email</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.oauth2.service_account.Credentials.with_claims"><code class="name flex">
<span>def <span class="ident">with_claims</span></span>(<span>self, additional_claims)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a copy of these credentials with modified claims.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>additional_claims</code></strong> :&ensp;<code>Mapping</code>[<code>str</code>, <code>str</code>]</dt>
<dd>Any additional claims for
the JWT payload. This will be merged with the current
additional claims.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.Credentials</code>: <code>A</code> <code>new</code> <code>credentials</code></dt>
<dd>instance.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_claims(self, additional_claims):
    &#34;&#34;&#34;Returns a copy of these credentials with modified claims.

    Args:
        additional_claims (Mapping[str, str]): Any additional claims for
            the JWT payload. This will be merged with the current
            additional claims.

    Returns:
        google.auth.service_account.Credentials: A new credentials
            instance.
    &#34;&#34;&#34;
    new_additional_claims = copy.deepcopy(self._additional_claims)
    new_additional_claims.update(additional_claims or {})

    return self.__class__(
        self._signer,
        service_account_email=self._service_account_email,
        scopes=self._scopes,
        token_uri=self._token_uri,
        subject=self._subject,
        project_id=self._project_id,
        additional_claims=new_additional_claims,
    )</code></pre>
</details>
</dd>
<dt id="google.oauth2.service_account.Credentials.with_subject"><code class="name flex">
<span>def <span class="ident">with_subject</span></span>(<span>self, subject)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a copy of these credentials with the specified subject.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subject</code></strong> :&ensp;<code>str</code></dt>
<dd>The subject claim.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.Credentials</code>: <code>A</code> <code>new</code> <code>credentials</code></dt>
<dd>instance.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_subject(self, subject):
    &#34;&#34;&#34;Create a copy of these credentials with the specified subject.

    Args:
        subject (str): The subject claim.

    Returns:
        google.auth.service_account.Credentials: A new credentials
            instance.
    &#34;&#34;&#34;
    return self.__class__(
        self._signer,
        service_account_email=self._service_account_email,
        scopes=self._scopes,
        token_uri=self._token_uri,
        subject=subject,
        project_id=self._project_id,
        additional_claims=self._additional_claims.copy(),
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.auth.credentials.Signing" href="../auth/credentials.html#google.auth.credentials.Signing">Signing</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Signing.sign_bytes" href="../auth/credentials.html#google.auth.credentials.Signing.sign_bytes">sign_bytes</a></code></li>
<li><code><a title="google.auth.credentials.Signing.signer" href="../auth/credentials.html#google.auth.credentials.Signing.signer">signer</a></code></li>
<li><code><a title="google.auth.credentials.Signing.signer_email" href="../auth/credentials.html#google.auth.credentials.Signing.signer_email">signer_email</a></code></li>
</ul>
</li>
<li><code><b><a title="google.auth.credentials.Scoped" href="../auth/credentials.html#google.auth.credentials.Scoped">Scoped</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Scoped.with_scopes" href="../auth/credentials.html#google.auth.credentials.Scoped.with_scopes">with_scopes</a></code></li>
</ul>
</li>
<li><code><b><a title="google.auth.credentials.Scoped" href="../auth/credentials.html#google.auth.credentials.Scoped">Scoped</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Scoped.has_scopes" href="../auth/credentials.html#google.auth.credentials.ReadOnlyScoped.has_scopes">has_scopes</a></code></li>
<li><code><a title="google.auth.credentials.Scoped.scopes" href="../auth/credentials.html#google.auth.credentials.ReadOnlyScoped.scopes">scopes</a></code></li>
</ul>
</li>
<li><code><b><a title="google.auth.credentials.Credentials" href="../auth/credentials.html#google.auth.credentials.Credentials">Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Credentials.refresh" href="../auth/credentials.html#google.auth.credentials.Credentials.refresh">refresh</a></code></li>
</ul>
</li>
<li><code><b><a title="google.auth.credentials.Credentials" href="../auth/credentials.html#google.auth.credentials.Credentials">Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Credentials.apply" href="../auth/credentials.html#google.auth.credentials.Credentials.apply">apply</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.before_request" href="../auth/credentials.html#google.auth.credentials.Credentials.before_request">before_request</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.expired" href="../auth/credentials.html#google.auth.credentials.Credentials.expired">expired</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.expiry" href="../auth/credentials.html#google.auth.credentials.Credentials.expiry">expiry</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.token" href="../auth/credentials.html#google.auth.credentials.Credentials.token">token</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.valid" href="../auth/credentials.html#google.auth.credentials.Credentials.valid">valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="google.oauth2.service_account.IDTokenCredentials"><code class="flex name class">
<span>class <span class="ident">IDTokenCredentials</span></span>
<span>(</span><span>signer, service_account_email, token_uri, target_audience, additional_claims=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Open ID Connect ID Token-based service account credentials.</p>
<pre><code>These credentials are largely similar to :class:`.Credentials`, but instead
of using an OAuth 2.0 Access Token as the bearer token, they use an Open
ID Connect ID Token as the bearer token. These credentials are useful when
communicating to services that require ID Tokens and can not accept access
tokens.

Usually, you'll create these credentials with one of the helper
constructors. To create credentials using a Google service account
private key JSON file::

    credentials = (
        service_account.IDTokenCredentials.from_service_account_file(
            'service-account.json'))

Or if you already have the service account file loaded::

    service_account_info = json.load(open('service_account.json'))
    credentials = (
        service_account.IDTokenCredentials.from_service_account_info(
            service_account_info))

Both helper methods pass on arguments to the constructor, so you can
specify additional scopes and a subject if necessary::

    credentials = (
        service_account.IDTokenCredentials.from_service_account_file(
            'service-account.json',
            scopes=['email'],
            subject='user@example.com'))
</code></pre>
<p><code>The credentials are considered immutable. If you want to modify the scopes
or the subject used for delegation, use :meth:</code>with_scopes<code>or
:meth:</code>with_subject`::</p>
<pre><code>    scoped_credentials = credentials.with_scopes(['email'])
    delegated_credentials = credentials.with_subject(subject)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signer</code></strong> :&ensp;<code>google.auth.crypt.Signer</code></dt>
<dd>The signer used to sign JWTs.</dd>
<dt><strong><code>service_account_email</code></strong> :&ensp;<code>str</code></dt>
<dd>The service account's email.</dd>
<dt><strong><code>token_uri</code></strong> :&ensp;<code>str</code></dt>
<dd>The OAuth 2.0 Token URI.</dd>
<dt><strong><code>target_audience</code></strong> :&ensp;<code>str</code></dt>
<dd>The intended audience for these credentials,
used when requesting the ID Token. The ID Token's <code>aud</code> claim
will be set to this string.</dd>
<dt><strong><code>additional_claims</code></strong> :&ensp;<code>Mapping</code>[<code>str</code>, <code>str</code>]</dt>
<dd>Any additional claims for
the JWT assertion used in the authorization grant.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Typically one of the helper constructors</p>
<p>:meth:<code>from_service_account_file</code> or
:meth:<code>from_service_account_info</code> are used instead of calling the
constructor directly.</p>
</div></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IDTokenCredentials(credentials.Signing, credentials.Credentials):
    &#34;&#34;&#34;Open ID Connect ID Token-based service account credentials.

    These credentials are largely similar to :class:`.Credentials`, but instead
    of using an OAuth 2.0 Access Token as the bearer token, they use an Open
    ID Connect ID Token as the bearer token. These credentials are useful when
    communicating to services that require ID Tokens and can not accept access
    tokens.

    Usually, you&#39;ll create these credentials with one of the helper
    constructors. To create credentials using a Google service account
    private key JSON file::

        credentials = (
            service_account.IDTokenCredentials.from_service_account_file(
                &#39;service-account.json&#39;))

    Or if you already have the service account file loaded::

        service_account_info = json.load(open(&#39;service_account.json&#39;))
        credentials = (
            service_account.IDTokenCredentials.from_service_account_info(
                service_account_info))

    Both helper methods pass on arguments to the constructor, so you can
    specify additional scopes and a subject if necessary::

        credentials = (
            service_account.IDTokenCredentials.from_service_account_file(
                &#39;service-account.json&#39;,
                scopes=[&#39;email&#39;],
                subject=&#39;user@example.com&#39;))
`
    The credentials are considered immutable. If you want to modify the scopes
    or the subject used for delegation, use :meth:`with_scopes` or
    :meth:`with_subject`::

        scoped_credentials = credentials.with_scopes([&#39;email&#39;])
        delegated_credentials = credentials.with_subject(subject)

    &#34;&#34;&#34;

    def __init__(
        self,
        signer,
        service_account_email,
        token_uri,
        target_audience,
        additional_claims=None,
    ):
        &#34;&#34;&#34;
        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            service_account_email (str): The service account&#39;s email.
            token_uri (str): The OAuth 2.0 Token URI.
            target_audience (str): The intended audience for these credentials,
                used when requesting the ID Token. The ID Token&#39;s ``aud`` claim
                will be set to this string.
            additional_claims (Mapping[str, str]): Any additional claims for
                the JWT assertion used in the authorization grant.

        .. note:: Typically one of the helper constructors
            :meth:`from_service_account_file` or
            :meth:`from_service_account_info` are used instead of calling the
            constructor directly.
        &#34;&#34;&#34;
        super(IDTokenCredentials, self).__init__()
        self._signer = signer
        self._service_account_email = service_account_email
        self._token_uri = token_uri
        self._target_audience = target_audience

        if additional_claims is not None:
            self._additional_claims = additional_claims
        else:
            self._additional_claims = {}

    @classmethod
    def _from_signer_and_info(cls, signer, info, **kwargs):
        &#34;&#34;&#34;Creates a credentials instance from a signer and service account
        info.

        Args:
            signer (google.auth.crypt.Signer): The signer used to sign JWTs.
            info (Mapping[str, str]): The service account info.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.jwt.IDTokenCredentials: The constructed credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        kwargs.setdefault(&#34;service_account_email&#34;, info[&#34;client_email&#34;])
        kwargs.setdefault(&#34;token_uri&#34;, info[&#34;token_uri&#34;])
        return cls(signer, **kwargs)

    @classmethod
    def from_service_account_info(cls, info, **kwargs):
        &#34;&#34;&#34;Creates a credentials instance from parsed service account info.

        Args:
            info (Mapping[str, str]): The service account info in Google
                format.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.IDTokenCredentials: The constructed
                credentials.

        Raises:
            ValueError: If the info is not in the expected format.
        &#34;&#34;&#34;
        signer = _service_account_info.from_dict(
            info, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    @classmethod
    def from_service_account_file(cls, filename, **kwargs):
        &#34;&#34;&#34;Creates a credentials instance from a service account json file.

        Args:
            filename (str): The path to the service account json file.
            kwargs: Additional arguments to pass to the constructor.

        Returns:
            google.auth.service_account.IDTokenCredentials: The constructed
                credentials.
        &#34;&#34;&#34;
        info, signer = _service_account_info.from_filename(
            filename, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
        )
        return cls._from_signer_and_info(signer, info, **kwargs)

    def with_target_audience(self, target_audience):
        &#34;&#34;&#34;Create a copy of these credentials with the specified target
        audience.

        Args:
            target_audience (str): The intended audience for these credentials,
            used when requesting the ID Token.

        Returns:
            google.auth.service_account.IDTokenCredentials: A new credentials
                instance.
        &#34;&#34;&#34;
        return self.__class__(
            self._signer,
            service_account_email=self._service_account_email,
            token_uri=self._token_uri,
            target_audience=target_audience,
            additional_claims=self._additional_claims.copy(),
        )

    def _make_authorization_grant_assertion(self):
        &#34;&#34;&#34;Create the OAuth 2.0 assertion.

        This assertion is used during the OAuth 2.0 grant to acquire an
        ID token.

        Returns:
            bytes: The authorization grant assertion.
        &#34;&#34;&#34;
        now = _helpers.utcnow()
        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)
        expiry = now + lifetime

        payload = {
            &#34;iat&#34;: _helpers.datetime_to_secs(now),
            &#34;exp&#34;: _helpers.datetime_to_secs(expiry),
            # The issuer must be the service account email.
            &#34;iss&#34;: self.service_account_email,
            # The audience must be the auth token endpoint&#39;s URI
            &#34;aud&#34;: self._token_uri,
            # The target audience specifies which service the ID token is
            # intended for.
            &#34;target_audience&#34;: self._target_audience,
        }

        payload.update(self._additional_claims)

        token = jwt.encode(self._signer, payload)

        return token

    @_helpers.copy_docstring(credentials.Credentials)
    def refresh(self, request):
        assertion = self._make_authorization_grant_assertion()
        access_token, expiry, _ = _client.id_token_jwt_grant(
            request, self._token_uri, assertion
        )
        self.token = access_token
        self.expiry = expiry

    @property
    def service_account_email(self):
        &#34;&#34;&#34;The service account email.&#34;&#34;&#34;
        return self._service_account_email

    @_helpers.copy_docstring(credentials.Signing)
    def sign_bytes(self, message):
        return self._signer.sign(message)

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer(self):
        return self._signer

    @property
    @_helpers.copy_docstring(credentials.Signing)
    def signer_email(self):
        return self._service_account_email</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="google.auth.credentials.Signing" href="../auth/credentials.html#google.auth.credentials.Signing">Signing</a></li>
<li><a title="google.auth.credentials.Credentials" href="../auth/credentials.html#google.auth.credentials.Credentials">Credentials</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="google.oauth2.service_account.IDTokenCredentials.from_service_account_file"><code class="name flex">
<span>def <span class="ident">from_service_account_file</span></span>(<span>filename, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a credentials instance from a service account json file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the service account json file.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional arguments to pass to the constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.IDTokenCredentials</code>: <code>The</code> <code>constructed</code></dt>
<dd>credentials.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_service_account_file(cls, filename, **kwargs):
    &#34;&#34;&#34;Creates a credentials instance from a service account json file.

    Args:
        filename (str): The path to the service account json file.
        kwargs: Additional arguments to pass to the constructor.

    Returns:
        google.auth.service_account.IDTokenCredentials: The constructed
            credentials.
    &#34;&#34;&#34;
    info, signer = _service_account_info.from_filename(
        filename, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
    )
    return cls._from_signer_and_info(signer, info, **kwargs)</code></pre>
</details>
</dd>
<dt id="google.oauth2.service_account.IDTokenCredentials.from_service_account_info"><code class="name flex">
<span>def <span class="ident">from_service_account_info</span></span>(<span>info, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a credentials instance from parsed service account info.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>Mapping</code>[<code>str</code>, <code>str</code>]</dt>
<dd>The service account info in Google
format.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional arguments to pass to the constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.IDTokenCredentials</code>: <code>The</code> <code>constructed</code></dt>
<dd>credentials.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>If the info is not in the expected format.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_service_account_info(cls, info, **kwargs):
    &#34;&#34;&#34;Creates a credentials instance from parsed service account info.

    Args:
        info (Mapping[str, str]): The service account info in Google
            format.
        kwargs: Additional arguments to pass to the constructor.

    Returns:
        google.auth.service_account.IDTokenCredentials: The constructed
            credentials.

    Raises:
        ValueError: If the info is not in the expected format.
    &#34;&#34;&#34;
    signer = _service_account_info.from_dict(
        info, require=[&#34;client_email&#34;, &#34;token_uri&#34;]
    )
    return cls._from_signer_and_info(signer, info, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="google.oauth2.service_account.IDTokenCredentials.service_account_email"><code class="name">var <span class="ident">service_account_email</span></code></dt>
<dd>
<section class="desc"><p>The service account email.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def service_account_email(self):
    &#34;&#34;&#34;The service account email.&#34;&#34;&#34;
    return self._service_account_email</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="google.oauth2.service_account.IDTokenCredentials.with_target_audience"><code class="name flex">
<span>def <span class="ident">with_target_audience</span></span>(<span>self, target_audience)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a copy of these credentials with the specified target
audience.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_audience</code></strong> :&ensp;<code>str</code></dt>
<dd>The intended audience for these credentials,</dd>
</dl>
<p>used when requesting the ID Token.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>google.auth.service_account.IDTokenCredentials</code>: <code>A</code> <code>new</code> <code>credentials</code></dt>
<dd>instance.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_target_audience(self, target_audience):
    &#34;&#34;&#34;Create a copy of these credentials with the specified target
    audience.

    Args:
        target_audience (str): The intended audience for these credentials,
        used when requesting the ID Token.

    Returns:
        google.auth.service_account.IDTokenCredentials: A new credentials
            instance.
    &#34;&#34;&#34;
    return self.__class__(
        self._signer,
        service_account_email=self._service_account_email,
        token_uri=self._token_uri,
        target_audience=target_audience,
        additional_claims=self._additional_claims.copy(),
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="google.auth.credentials.Signing" href="../auth/credentials.html#google.auth.credentials.Signing">Signing</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Signing.sign_bytes" href="../auth/credentials.html#google.auth.credentials.Signing.sign_bytes">sign_bytes</a></code></li>
<li><code><a title="google.auth.credentials.Signing.signer" href="../auth/credentials.html#google.auth.credentials.Signing.signer">signer</a></code></li>
<li><code><a title="google.auth.credentials.Signing.signer_email" href="../auth/credentials.html#google.auth.credentials.Signing.signer_email">signer_email</a></code></li>
</ul>
</li>
<li><code><b><a title="google.auth.credentials.Credentials" href="../auth/credentials.html#google.auth.credentials.Credentials">Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Credentials.refresh" href="../auth/credentials.html#google.auth.credentials.Credentials.refresh">refresh</a></code></li>
</ul>
</li>
<li><code><b><a title="google.auth.credentials.Credentials" href="../auth/credentials.html#google.auth.credentials.Credentials">Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="google.auth.credentials.Credentials.apply" href="../auth/credentials.html#google.auth.credentials.Credentials.apply">apply</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.before_request" href="../auth/credentials.html#google.auth.credentials.Credentials.before_request">before_request</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.expired" href="../auth/credentials.html#google.auth.credentials.Credentials.expired">expired</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.expiry" href="../auth/credentials.html#google.auth.credentials.Credentials.expiry">expiry</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.token" href="../auth/credentials.html#google.auth.credentials.Credentials.token">token</a></code></li>
<li><code><a title="google.auth.credentials.Credentials.valid" href="../auth/credentials.html#google.auth.credentials.Credentials.valid">valid</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#domain-wide-delegation">Domain-wide delegation</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="google.oauth2" href="index.html">google.oauth2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="google.oauth2.service_account.Credentials" href="#google.oauth2.service_account.Credentials">Credentials</a></code></h4>
<ul class="">
<li><code><a title="google.oauth2.service_account.Credentials.from_service_account_file" href="#google.oauth2.service_account.Credentials.from_service_account_file">from_service_account_file</a></code></li>
<li><code><a title="google.oauth2.service_account.Credentials.from_service_account_info" href="#google.oauth2.service_account.Credentials.from_service_account_info">from_service_account_info</a></code></li>
<li><code><a title="google.oauth2.service_account.Credentials.project_id" href="#google.oauth2.service_account.Credentials.project_id">project_id</a></code></li>
<li><code><a title="google.oauth2.service_account.Credentials.requires_scopes" href="#google.oauth2.service_account.Credentials.requires_scopes">requires_scopes</a></code></li>
<li><code><a title="google.oauth2.service_account.Credentials.service_account_email" href="#google.oauth2.service_account.Credentials.service_account_email">service_account_email</a></code></li>
<li><code><a title="google.oauth2.service_account.Credentials.with_claims" href="#google.oauth2.service_account.Credentials.with_claims">with_claims</a></code></li>
<li><code><a title="google.oauth2.service_account.Credentials.with_subject" href="#google.oauth2.service_account.Credentials.with_subject">with_subject</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="google.oauth2.service_account.IDTokenCredentials" href="#google.oauth2.service_account.IDTokenCredentials">IDTokenCredentials</a></code></h4>
<ul class="">
<li><code><a title="google.oauth2.service_account.IDTokenCredentials.from_service_account_file" href="#google.oauth2.service_account.IDTokenCredentials.from_service_account_file">from_service_account_file</a></code></li>
<li><code><a title="google.oauth2.service_account.IDTokenCredentials.from_service_account_info" href="#google.oauth2.service_account.IDTokenCredentials.from_service_account_info">from_service_account_info</a></code></li>
<li><code><a title="google.oauth2.service_account.IDTokenCredentials.service_account_email" href="#google.oauth2.service_account.IDTokenCredentials.service_account_email">service_account_email</a></code></li>
<li><code><a title="google.oauth2.service_account.IDTokenCredentials.with_target_audience" href="#google.oauth2.service_account.IDTokenCredentials.with_target_audience">with_target_audience</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>